<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  <meta name="generator" content="pandoc">
  <!-- Global site tag (gtag.js) - Google Analytics -->
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-126809681-1"></script>
<script>
  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());

  gtag('config', 'UA-126809681-1');
</script>

  <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes">
  <link href="https://fonts.googleapis.com/css?family=Inconsolata|Roboto:300,300i,700" rel="stylesheet">
  <meta name="author" content="Andre Popovitch">
  <meta name="dcterms.date" content="2018-10-27">
  <title>Wise Man’s Haskell</title>
  <style type="text/css">code{white-space: pre;}</style>
  <style type="text/css">
a.sourceLine { display: inline-block; line-height: 1.25; }
a.sourceLine { pointer-events: none; color: inherit; text-decoration: inherit; }
a.sourceLine:empty { height: 1.2em; }
.sourceCode { overflow: visible; }
code.sourceCode { white-space: pre; position: relative; }
div.sourceCode { margin: 1em 0; }
pre.sourceCode { margin: 0; }
@media screen {
div.sourceCode { overflow: auto; }
}
@media print {
code.sourceCode { white-space: pre-wrap; }
a.sourceLine { text-indent: -1em; padding-left: 1em; }
}
pre.numberSource a.sourceLine
  { position: relative; left: -4em; }
pre.numberSource a.sourceLine::before
  { content: attr(data-line-number);
    position: relative; left: -1em; text-align: right; vertical-align: baseline;
    border: none; pointer-events: all; display: inline-block;
    -webkit-touch-callout: none; -webkit-user-select: none;
    -khtml-user-select: none; -moz-user-select: none;
    -ms-user-select: none; user-select: none;
    padding: 0 4px; width: 4em;
    color: #aaaaaa;
  }
pre.numberSource { margin-left: 3em; border-left: 1px solid #aaaaaa;  padding-left: 4px; }
div.sourceCode
  {  }
@media screen {
a.sourceLine::before { text-decoration: underline; }
}
code span.al { color: #ff0000; font-weight: bold; } /* Alert */
code span.an { color: #60a0b0; font-weight: bold; font-style: italic; } /* Annotation */
code span.at { color: #7d9029; } /* Attribute */
code span.bn { color: #40a070; } /* BaseN */
code span.bu { } /* BuiltIn */
code span.cf { color: #007020; font-weight: bold; } /* ControlFlow */
code span.ch { color: #4070a0; } /* Char */
code span.cn { color: #880000; } /* Constant */
code span.co { color: #60a0b0; font-style: italic; } /* Comment */
code span.cv { color: #60a0b0; font-weight: bold; font-style: italic; } /* CommentVar */
code span.do { color: #ba2121; font-style: italic; } /* Documentation */
code span.dt { color: #902000; } /* DataType */
code span.dv { color: #40a070; } /* DecVal */
code span.er { color: #ff0000; font-weight: bold; } /* Error */
code span.ex { } /* Extension */
code span.fl { color: #40a070; } /* Float */
code span.fu { color: #06287e; } /* Function */
code span.im { } /* Import */
code span.in { color: #60a0b0; font-weight: bold; font-style: italic; } /* Information */
code span.kw { color: #007020; font-weight: bold; } /* Keyword */
code span.op { color: #666666; } /* Operator */
code span.ot { color: #007020; } /* Other */
code span.pp { color: #bc7a00; } /* Preprocessor */
code span.sc { color: #4070a0; } /* SpecialChar */
code span.ss { color: #bb6688; } /* SpecialString */
code span.st { color: #4070a0; } /* String */
code span.va { color: #19177c; } /* Variable */
code span.vs { color: #4070a0; } /* VerbatimString */
code span.wa { color: #60a0b0; font-weight: bold; font-style: italic; } /* Warning */
  </style>
  <style type="text/css">
  @charset "UTF-8";


/* Tufte CSS styles */
html { font-size: 15px; }

body { width: 87.5%;
       margin-left: auto;
       margin-right: auto;
       padding-left: 12.5%;
       font-family: 'Roboto', sans-serif;
       background-color: #fffff8;
       color: #111;
       max-width: 1400px;
       counter-reset: sidenote-counter; }

h1 { font-weight: 400;
     margin-top: 4rem;
     margin-bottom: 1.5rem;
     font-size: 3.2rem;
     line-height: 1; }

h2 { font-style: italic;
     font-weight: 400;
     margin-top: 2.1rem;
     margin-bottom: 0;
     font-size: 2.2rem;
     line-height: 1; }

h3 { font-style: italic;
     font-weight: 400;
     font-size: 1.7rem;
     margin-top: 2rem;
     margin-bottom: 0;
     line-height: 1; }

hr { display: block;
     height: 1px;
     width: 55%;
     border: 0;
     border-top: 1px solid #ccc;
     margin: 1em 0;
     padding: 0; }

p.subtitle { font-style: italic;
             margin-top: 1rem;
             margin-bottom: 1rem;
             font-size: 1.8rem;
             display: block;
             line-height: 1; }

.danger { color: red; }

article { position: relative;
          padding: 5rem 0rem; }

section { padding-top: 1rem;
          padding-bottom: 1rem; }

p, ol, ul { font-size: 1.4rem; }

p { line-height: 2rem;
    margin-top: 1.4rem;
    margin-bottom: 1.4rem;
    padding-right: 0;
    vertical-align: baseline; }

/* Chapter Epigraphs */
div.epigraph { margin: 5em 0; }

div.epigraph > blockquote { margin-top: 3em;
                            margin-bottom: 3em; }

div.epigraph > blockquote, div.epigraph > blockquote > p { font-style: italic; }

div.epigraph > blockquote > footer { font-style: normal; }

div.epigraph > blockquote > footer > cite { font-style: italic; }
/* end chapter epigraphs styles */

blockquote { font-size: 1rem; }

blockquote p { width: 55%;
               margin-right: 40px; }

blockquote footer { width: 55%;
                    font-size: 1.1rem;
                    text-align: right; }

section>ol, section>ul { width: 45%;
                         -webkit-padding-start: 5%;
                         -webkit-padding-end: 5%; }

li { padding: 0.5rem 0; }

figure { padding: 0;
         border: 0;
         font-size: 100%;
         font: inherit;
         vertical-align: baseline;
         max-width: 55%;
         -webkit-margin-start: 0;
         -webkit-margin-end: 0;
         margin: 0 0 3em 0; }

figcaption { float: right;
             clear: right;
             margin-top: 0;
             margin-bottom: 0;
             font-size: 1.1rem;
             line-height: 1.6;
             vertical-align: baseline;
             position: relative;
             max-width: 40%; }

figure.fullwidth figcaption { margin-right: 24%; }

/* Links: replicate underline that clears descenders */
a:link, a:visited { color: inherit; }

a:link { text-decoration: none;
         background: -webkit-linear-gradient(#fffff8, #fffff8), -webkit-linear-gradient(#fffff8, #fffff8), -webkit-linear-gradient(#333, #333);
         background: linear-gradient(#fffff8, #fffff8), linear-gradient(#fffff8, #fffff8), linear-gradient(#333, #333);
         -webkit-background-size: 0.05em 1px, 0.05em 1px, 1px 1px;
         -moz-background-size: 0.05em 1px, 0.05em 1px, 1px 1px;
         background-size: 0.05em 1px, 0.05em 1px, 1px 1px;
         background-repeat: no-repeat, no-repeat, repeat-x;
         text-shadow: 0.03em 0 #fffff8, -0.03em 0 #fffff8, 0 0.03em #fffff8, 0 -0.03em #fffff8, 0.06em 0 #fffff8, -0.06em 0 #fffff8, 0.09em 0 #fffff8, -0.09em 0 #fffff8, 0.12em 0 #fffff8, -0.12em 0 #fffff8, 0.15em 0 #fffff8, -0.15em 0 #fffff8;
         background-position: 0% 93%, 100% 93%, 0% 93%; }

@media screen and (-webkit-min-device-pixel-ratio: 0) { a:link { background-position-y: 87%, 87%, 87%; } }

a:link::selection { text-shadow: 0.03em 0 #b4d5fe, -0.03em 0 #b4d5fe, 0 0.03em #b4d5fe, 0 -0.03em #b4d5fe, 0.06em 0 #b4d5fe, -0.06em 0 #b4d5fe, 0.09em 0 #b4d5fe, -0.09em 0 #b4d5fe, 0.12em 0 #b4d5fe, -0.12em 0 #b4d5fe, 0.15em 0 #b4d5fe, -0.15em 0 #b4d5fe;
                    background: #b4d5fe; }

a:link::-moz-selection { text-shadow: 0.03em 0 #b4d5fe, -0.03em 0 #b4d5fe, 0 0.03em #b4d5fe, 0 -0.03em #b4d5fe, 0.06em 0 #b4d5fe, -0.06em 0 #b4d5fe, 0.09em 0 #b4d5fe, -0.09em 0 #b4d5fe, 0.12em 0 #b4d5fe, -0.12em 0 #b4d5fe, 0.15em 0 #b4d5fe, -0.15em 0 #b4d5fe;
                         background: #b4d5fe; }

/* Sidenotes, margin notes, figures, captions */
img { max-width: 100%; }

.sidenote, .marginnote { float: right;
                         clear: right;
                         margin-right: -60%;
                         width: 50%;
                         margin-top: 0;
                         margin-bottom: 0;
                         font-size: 1.1rem;
                         line-height: 1.3;
                         vertical-align: baseline;
                         position: relative; }

.sidenote-number { counter-increment: sidenote-counter; }

.sidenote-number:after, .sidenote:before { content: counter(sidenote-counter) " ";
                                           position: relative;
                                           vertical-align: baseline; }

.sidenote-number:after { content: counter(sidenote-counter);
                         font-size: 1rem;
                         top: -0.5rem;
                         left: 0.1rem; }

.sidenote:before { content: counter(sidenote-counter) " ";
                   top: -0.5rem; }

blockquote .sidenote, blockquote .marginnote { margin-right: -82%;
                                               min-width: 59%;
                                               text-align: left; }    

p, footer, table { width: 55%; }

div.fullwidth, table.fullwidth { width: 100%; }

div.table-wrapper { overflow-x: auto;
                    font-family: "Trebuchet MS", "Gill Sans", "Gill Sans MT", sans-serif; }

.sans { font-family: "Gill Sans", "Gill Sans MT", Calibri, sans-serif;
        letter-spacing: .03em; }

code { font-family: 'Inconsolata', Consolas, "Liberation Mono", Menlo, Courier, monospace;
       font-size: 1.0rem;
       line-height: 1.42; }

.sans > code { font-size: 1.2rem; }

h1 > code, h2 > code, h3 > code { font-size: 0.80em; }

.marginnote > code, .sidenote > code { font-size: 1rem; }

pre.code { font-size: 0.9rem;
           width: 52.5%;
           margin-left: 2.5%;
           overflow-x: auto; }

pre.code.fullwidth { width: 90%; }

.fullwidth { max-width: 90%;
             clear:both; }

span.newthought { font-variant: small-caps;
                  font-size: 1.2em; }

input.margin-toggle { display: none; }

label.sidenote-number { display: inline; }

label.margin-toggle:not(.sidenote-number) { display: none; }

@media (max-width: 760px) { body { width: 84%;
                                   padding-left: 8%;
                                   padding-right: 8%; }
                            p, footer { width: 100%; }
                            pre.code { width: 97%; }
                            ul { width: 85%; }
                            figure { max-width: 90%; }
                            figcaption, figure.fullwidth figcaption { margin-right: 0%;
                                                                      max-width: none; }
                            blockquote { margin-left: 1.5em;
                                         margin-right: 0em; }
                            blockquote p, blockquote footer { width: 100%; }
                            label.margin-toggle:not(.sidenote-number) { display: inline; }
                            .sidenote, .marginnote { display: none; }
                            .margin-toggle:checked + .sidenote,
                            .margin-toggle:checked + .marginnote { display: block;
                                                                   float: left;
                                                                   left: 1rem;
                                                                   clear: both;
                                                                   width: 95%;
                                                                   margin: 1rem 2.5%;
                                                                   vertical-align: baseline;
                                                                   position: relative; }
                            label { cursor: pointer; }
                            div.table-wrapper, table { width: 85%; }
                            img { width: 100%; } }
  </style>
  <style type="text/css">
    .sourceCode {
      text-indent: 0em;
      overflow-wrap: normal;
      background-color: #F0F0E0;
      border-radius: .4em;
      padding-bottom: .1em;
      width: 55%;
    }
    .sourceLine {
      padding-left: .45em;
    }
    code { font-family: 'Inconsolata', Consolas, "Liberation Mono", Menlo, Courier, monospace;
        font-size: 1.0rem;
        line-height: 1.42; 
        background-color: #F0F0E0;
        border-radius: .2em;
        padding-left: .1em;
        padding-right: .1em;
        white-space: pre-wrap;       /* css-3 */
        white-space: -moz-pre-wrap;  /* Mozilla, since 1999 */
        white-space: -pre-wrap;      /* Opera 4-6 */
        white-space: -o-pre-wrap;    /* Opera 7 */
        word-wrap: break-word;       /* Internet Explorer 5.5+ */
        }
    .latex-sub, .latex-sup { text-transform: uppercase;
                         font-size: smaller;
                         position: relative; }

    .latex-sub { top: 0.2rem;
                margin-left: -0.1667rem;
                margin-right: -0.125rem; }

    .latex-sup { top: -0.2rem;
                margin-left: -0.36rem;
                margin-right: -0.15rem;
                text-shadow: none; }

    .latex::selection, .latex span:not(.latex-sup)::selection { text-shadow: 0.03em 0 #b4d5fe, -0.03em 0 #b4d5fe, 0 0.03em #b4d5fe, 0 -0.03em #b4d5fe, 0.06em 0 #b4d5fe, -0.06em 0 #b4d5fe, 0.09em 0 #b4d5fe, -0.09em 0 #b4d5fe, 0.12em 0 #b4d5fe, -0.12em 0 #b4d5fe, 0.15em 0 #b4d5fe, -0.15em 0 #b4d5fe;
                        background: #b4d5fe; }

    .latex::-moz-selection, .latex span:not(.latex-sup)::-moz-selection { text-shadow: 0.03em 0 #b4d5fe, -0.03em 0 #b4d5fe, 0 0.03em #b4d5fe, 0 -0.03em #b4d5fe, 0.06em 0 #b4d5fe, -0.06em 0 #b4d5fe, 0.09em 0 #b4d5fe, -0.09em 0 #b4d5fe, 0.12em 0 #b4d5fe, -0.12em 0 #b4d5fe, 0.15em 0 #b4d5fe, -0.15em 0 #b4d5fe;
    background: #b4d5fe; }

    table {
      border-top: 2px solid #111;
      border-bottom: 2px solid #111;
      font-size: 1.1rem;
    }
    th {
      border-bottom: 1px solid #111;
    }

    @media (max-width: 760px) {
    .sourceCode {
        width: 97%
      }
    }
  </style>
  <!--[if lt IE 9]>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/html5shiv/3.7.3/html5shiv-printshiv.min.js"></script>
  <![endif]-->
</head>
<body>
<header>
<h1 class="title">Wise Man’s Haskell</h1>
<p class="author">Andre Popovitch</p>
<p class="date">2018-10-27</p>
</header>
<nav id="TOC">
<ul>
<li><a href="#preface">Preface</a></li>
<li><a href="#functional-programming-and-purity">Functional Programming and Purity</a></li>
<li><a href="#getting-started">Getting started</a></li>
<li><a href="#types-and-type-signatures">Types and type signatures</a><ul>
<li><a href="#more-types">More types!</a></li>
<li><a href="#type-signatures">Type signatures</a></li>
<li><a href="#typeclasses">Typeclasses</a></li>
<li><a href="#handy-typeclasses-and-more-examples">Handy typeclasses and more examples</a></li>
</ul></li>
<li><a href="#lists-and-tuples">Lists and Tuples</a><ul>
<li><a href="#useful-functions-on-lists">Useful Functions on Lists</a></li>
<li><a href="#enumerations-and-infinite-lists">Enumerations and Infinite Lists</a></li>
<li><a href="#list-comprehensions">List Comprehensions</a></li>
<li><a href="#tuples">Tuples</a></li>
</ul></li>
<li><a href="#more-about-functions---useful-syntax">More About Functions - Useful Syntax</a><ul>
<li><a href="#pattern-matching">Pattern matching</a></li>
<li><a href="#ifthenelse">If/Then/Else</a></li>
<li><a href="#guards">Guards</a></li>
<li><a href="#let-expressions-and-where-statements">Let Expressions and Where Statements</a></li>
</ul></li>
<li><a href="#fixing-errors">Fixing Errors</a></li>
<li><a href="#problem-solving-practice">Problem Solving Practice</a></li>
<li><a href="#functions-first-class">Functions First Class</a><ul>
<li><a href="#currying">Currying</a></li>
<li><a href="#map">Map</a></li>
<li><a href="#filter">Filter</a></li>
<li><a href="#function-composition">Function composition</a></li>
<li><a href="#function-application">Function Application</a></li>
<li><a href="#folds">Folds</a></li>
</ul></li>
<li><a href="#a-brief-note-on-undefined">A Brief Note on Undefined</a></li>
<li><a href="#when-things-might-go-wrong.">When things might go wrong.</a></li>
<li><a href="#creating-new-data-types">Creating New Data Types</a><ul>
<li><a href="#basic-data-types">Basic data types</a></li>
<li><a href="#data-types-with-other-values">Data Types With Other Values</a></li>
<li><a href="#type-aliases">Type Aliases</a></li>
<li><a href="#parameterized-types">Parameterized Types</a></li>
<li><a href="#kinds">Kinds</a></li>
<li><a href="#making-our-own-typeclasses">Making Our Own Typeclasses</a></li>
</ul></li>
<li><a href="#recursion-practice">Recursion Practice</a></li>
<li><a href="#newtype">Newtype</a></li>
<li><a href="#writing-real-haskell-programs">Writing Real Haskell Programs</a><ul>
<li><a href="#environment">Environment</a></li>
<li><a href="#stack-projects">Stack Projects</a></li>
<li><a href="#definitions">Definitions</a></li>
<li><a href="#creating-a-project">Creating a Project</a></li>
<li><a href="#running-the-project">Running the Project</a></li>
<li><a href="#containing-impurity">Containing Impurity</a></li>
<li><a href="#the-sequencing-operator">The Sequencing Operator</a></li>
<li><a href="#the-bind-operator">The Bind Operator</a></li>
<li><a href="#do-notation">Do Notation</a></li>
<li><a href="#useful-io-functions">Useful IO Functions</a></li>
<li><a href="#project-1---a-text-adventure-game">Project 1 - A Text Adventure Game</a></li>
<li><a href="#exceptions">Exceptions</a></li>
<li><a href="#building-projects-for-distribution">Building Projects for Distribution</a></li>
</ul></li>
<li><a href="#more-helpful-typeclasses">More Helpful Typeclasses</a><ul>
<li><a href="#functors">Functors</a></li>
<li><a href="#monoids">Monoids</a></li>
<li><a href="#semigroups">Semigroups</a></li>
<li><a href="#applicatives">Applicatives</a></li>
<li><a href="#monads">Monads</a></li>
<li><a href="#monad-laws">Monad Laws</a></li>
</ul></li>
<li><a href="#more-monads">More Monads</a><ul>
<li><a href="#the-list-monad">The List Monad</a></li>
</ul></li>
<li><a href="#important-information-for-using-haskell">Important Information For Using Haskell</a><ul>
<li><a href="#getting-3rd-party-code-with-stack">Getting 3rd-Party Code With Stack</a></li>
<li><a href="#how-to-test-our-code">How To Test Our Code</a></li>
<li><a href="#reading-and-writing-documentation">Reading and Writing Documentation</a></li>
<li><a href="#warnings-and-editor-settings">Warnings and Editor Settings</a></li>
<li><a href="#what-are-all-these-files-anyway">What Are All These Files, Anyway</a></li>
<li><a href="#how-to-develop-and-debug">How to Develop and Debug</a></li>
</ul></li>
<li><a href="#generalized-algebraic-data-types-and-data-kinds">Generalized Algebraic Data Types and Data Kinds</a></li>
</ul>
</nav>
<h1 id="preface">Preface</h1>
<p><span class="newthought">I’m Andre Popovitch</span>. This is my book on learning Haskell, an excellent functional programming language. It’s not finished yet but hopefully, it will be soon - it should be useful already. I assume some programming knowledge, but nothing too in depth. If you’ve played with Python or Javascript and know how to open a command prompt/terminal, that’ll be plenty.</p>
<p><strong>What to do if you see a typo</strong>: <span class="citation" data-cites="likliklik">@likliklik</span> in the <a href="https://discord.gg/cUEkjJ">Functional Programming Discord</a>, <a href="mailto:haskell@andrepopovitch.com">email me</a>, or leave an issue on <a href="https://github.com/anchpop/wise_mans_haskell">the GitHub</a>.</p>
<p><span class="newthought">I wrote</span> this book because all the other good Haskell tutorials either cost money or were too verbose. That’s surprising, considering GHC (the most popular Haskell compiler) has been around since 1992. Hopefully, this will be better than ones that came before it, too.</p>
<p>This book is heavily inspired by <a href="http://learnyouahaskell.com/">Learn You A Haskell</a> by Miran Lipovača, <a href="http://haskellbook.com/">Haskell Programming From First Principles</a> by Christopher Allen Julie Moronuki, <a href="https://www.amazon.com/Programming-Haskell-Graham-Hutton/dp/0521692695">Programming in Haskell</a> by Graham Hutton, <a href="http://book.realworldhaskell.org/">Real World Haskell</a> by Bryan O’Sullivan, John Goerzen, and Don Stewart, and <a href="https://www.amazon.com/Petit-Prince-French-Antoine-Saint-Exup%C3%A9ry/dp/1502878267">Le Petit Prince</a> by Antoine de Saint-Exupéry.</p>
<p><span class="newthought">If you</span> have questions, feel free to <a href="mailto:haskell@andrepopovitch.com">email me</a>. A great resource is the #haskell channel in the <a href="https://discord.gg/cUEkjJ">Functional Programming Discord</a>.</p>
<p><strong>A note on exercises</strong>: I’ve put a few exercises in here, and they’re very important for reinforcing your knowledge. <strong>Don’t skip them</strong><label for="marginnote-1" class="margin-toggle">⊕</label> <input type="checkbox" id="marginnote-1" class="margin-toggle"/> <span class="marginnote">This book also has margin notes scattered throughout, I recommend reading them because they often provide extra context or supplemental info.</span></p>
<p>I said this book wouldn’t be verbose, so let’s move on. And have fun!</p>
<h1 id="functional-programming-and-purity">Functional Programming and Purity</h1>
<p>This section is for people with previous experience programming. If you have no previous experience, feel free to skip this chapter.</p>
<p><span class="newthought">Haskell is</span> strange among many languages you might be used to. It is a pure and functional programming language<label for="marginnote-2" class="margin-toggle">⊕</label> <input type="checkbox" id="marginnote-2" class="margin-toggle"/> <span class="marginnote">Haskell is also <em>lazy</em>, but we’ll touch on that later.</span>. If you know what this means, you can skip to the next chapter. Otherwise, read on!</p>
<ol type="1">
<li><p>Functionality is a somewhat vague concept. It doesn’t mean other languages are dysfunctional<label for="sidenote-1" class="margin-toggle sidenote-number"></label> <input type="checkbox" id="sidenote-1" class="margin-toggle"/> <span class="sidenote">Although they are.</span>. I’ll go into it more later, but there’s one simple thing you need to know first: Once set, variables cannot be changed<label for="marginnote-3" class="margin-toggle">⊕</label> <input type="checkbox" id="marginnote-3" class="margin-toggle"/> <span class="marginnote">When a variable changes, functional programmers sometimes call it a <em>mutation</em>. Mutations are not allowed in Haskell.</span>. If you write <code>a = 2</code>, you cannot follow it with <code>a = 3</code>. This seems limiting, but once you accept it, it allows you to make certain assumptions that are very freeing. One benefit is it makes programs simpler. No longer do you have to keep track of 100 different variables, all constantly changing<label for="sidenote-2" class="margin-toggle sidenote-number"></label> <input type="checkbox" id="sidenote-2" class="margin-toggle"/> <span class="sidenote">This is called having a lot of <em>statefulness</em> in your program, and many programmers try to avoid it even when using other types of programming languages.</span>. Another term for this is that everything in Haskell is <em>immutable</em>. There are other benefits too. For example, writing programs that run on multiple cores or the GPU becomes much easier. That’s essentially what is meant by “functional”. I’ll discuss this later.</p></li>
<li><p>Next up, Purity. When writing a function, the function’s output can depend only on its input, and all functions should be <em>side-effect free</em>, meaning they do nothing except return a result. Let me show you what I mean. The following example is in Python but does not require any Python-specific knowledge<label for="marginnote-4" class="margin-toggle">⊕</label> <input type="checkbox" id="marginnote-4" class="margin-toggle"/> <span class="marginnote">Any line beginning with a <code>#</code> is a comment in Python.</span>.</p></li>
</ol>
<div class="sourceCode" id="cb1"><pre class="sourceCode python"><code class="sourceCode python"><a class="sourceLine" id="cb1-1" data-line-number="1"><span class="kw">def</span> add(a, b):</a>
<a class="sourceLine" id="cb1-2" data-line-number="2">    <span class="cf">return</span> a <span class="op">+</span> b</a></code></pre></div>
<p>This is a pure function. If you call <code>add(1, 2)</code> it will return <code>3</code>, every time. It won’t do anything else. This means, in principle, this should be possible:</p>
<div class="sourceCode" id="cb2"><pre class="sourceCode python"><code class="sourceCode python"><a class="sourceLine" id="cb2-1" data-line-number="1"><span class="co"># This is a comment in Python.</span></a>
<a class="sourceLine" id="cb2-2" data-line-number="2"></a>
<a class="sourceLine" id="cb2-3" data-line-number="3"><span class="co"># Let&#39;s test our function.</span></a>
<a class="sourceLine" id="cb2-4" data-line-number="4">add(<span class="dv">1</span>, <span class="dv">2</span>) </a>
<a class="sourceLine" id="cb2-5" data-line-number="5"><span class="co"># 1 + 2 is evaluated, and the our &#39;add&#39; function returns 3 </span></a>
<a class="sourceLine" id="cb2-6" data-line-number="6"></a>
<a class="sourceLine" id="cb2-7" data-line-number="7"><span class="co"># Now, let&#39;s call it again</span></a>
<a class="sourceLine" id="cb2-8" data-line-number="8">add(<span class="dv">1</span>, <span class="dv">2</span>)</a>
<a class="sourceLine" id="cb2-9" data-line-number="9"><span class="co"># Since we already computed add(1, 2), it should be possible </span></a>
<a class="sourceLine" id="cb2-10" data-line-number="10"><span class="co"># for our programming language to make this faster for us by </span></a>
<a class="sourceLine" id="cb2-11" data-line-number="11"><span class="co"># remembering what add(1, 2) was last time and just reusing that.</span></a></code></pre></div>
<p>You can see pure functions offer some interesting possibilities. But, in most languages, there’s a catch. Let’s say we have a function, <code>isItWednesday()</code>, that returns <code>True</code> if it is currently Wednesday in your time zone, and <code>False</code> otherwise.</p>
<div class="sourceCode" id="cb3"><pre class="sourceCode python"><code class="sourceCode python"><a class="sourceLine" id="cb3-1" data-line-number="1"><span class="co"># Let&#39;s see if it&#39;s Wednesday.</span></a>
<a class="sourceLine" id="cb3-2" data-line-number="2">wed <span class="op">=</span> isItWednesday()</a>
<a class="sourceLine" id="cb3-3" data-line-number="3"></a>
<a class="sourceLine" id="cb3-4" data-line-number="4"><span class="co"># Here we do some other stuff in our program. Something that takes a long time, </span></a>
<a class="sourceLine" id="cb3-5" data-line-number="5"><span class="co"># maybe computing a billion digits of pi.</span></a>
<a class="sourceLine" id="cb3-6" data-line-number="6"><span class="co"># It doesn&#39;t matter what, just imagine there&#39;s a lot of work going on here.</span></a>
<a class="sourceLine" id="cb3-7" data-line-number="7"></a>
<a class="sourceLine" id="cb3-8" data-line-number="8"><span class="co"># Now a different part of our program wants to know if it&#39;s Wednesday. So we run:</span></a>
<a class="sourceLine" id="cb3-9" data-line-number="9">wed2 <span class="op">=</span> isItWednesday()</a>
<a class="sourceLine" id="cb3-10" data-line-number="10"><span class="co"># Can the programming language do what it did for add(1, 2), </span></a>
<a class="sourceLine" id="cb3-11" data-line-number="11"><span class="co"># and just replace this call to isItWednesday() with the result of the previous one?</span></a></code></pre></div>
<p>What do you think? No, it can’t! Because if you started your program at 11:59 Wednesday night, then by the time you were done computing digits of pi, it might not be Wednesday anymore! The issue is that <code>isItWednesday()</code> was not a pure function. Its output depends on things outside of its input. In Haskell, all functions have to be pure, unless you specifically say they aren’t. This lets the compiler do all sorts of interesting optimizations which I’ll discuss later.</p>
<h1 id="getting-started">Getting started</h1>
<p><span class="newthought">To program</span> in Haskell, you should be familiar with how to navigate your terminal<label for="marginnote-5" class="margin-toggle">⊕</label> <input type="checkbox" id="marginnote-5" class="margin-toggle"/> <span class="marginnote">If you’re on Windows, what you call the command prompt is called the “terminal” elsewhere. Also, you should install <a href="http://cmder.net/">Full Cmder</a>, and use that instead of <code>cmd</code>.</span>. To actually use Haskell, you should download and install <a href="https://www.haskell.org/platform/">The Haskell Platform</a>, which has everything you need to get started quickly. It includes GHC<label for="marginnote-6" class="margin-toggle">⊕</label> <input type="checkbox" id="marginnote-6" class="margin-toggle"/> <span class="marginnote"><strong>GHC</strong> stands for <em>Glasgow Haskell Compiler</em></span>, the most popular Haskell compiler, along with useful tools such as Stack and Cabal.</p>
<p>Once you’ve done that, open a terminal and type <code>ghci</code><label for="marginnote-7" class="margin-toggle">⊕</label> <input type="checkbox" id="marginnote-7" class="margin-toggle"/> <span class="marginnote">The <em>i</em> in GHCi stands for <em>interpreter</em>, which is a simple interface for playing with Haskell</span>. If you already had one open, you might need to close and reopen it. Once you’ve entered that, you should see something like:</p>
<div class="sourceCode" id="cb4"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb4-1" data-line-number="1"><span class="dt">GHCi</span>, version <span class="fl">8.4</span><span class="fu">.</span><span class="dv">3</span><span class="fu">:</span> http<span class="fu">://</span>www<span class="fu">.</span>haskell<span class="fu">.</span>org<span class="fu">/</span>ghc<span class="fu">/</span>  <span class="fu">:?</span> for help</a>
<a class="sourceLine" id="cb4-2" data-line-number="2"><span class="dt">Prelude</span><span class="fu">&gt;</span></a></code></pre></div>
<p>If you need to get out of GHCi, you can type <code>:quit</code><label for="marginnote-8" class="margin-toggle">⊕</label> <input type="checkbox" id="marginnote-8" class="margin-toggle"/> <span class="marginnote"><code>:q</code> will work instead of <code>:quit</code>, if you feel the need to save a couple keystrokes.</span>.</p>
<p>Where you see <code>Prelude&gt;</code> is you can type Haskell expressions or statements, and see what they evaluate to. If you type an expression, GHCi will tell you the result of that expression. Try entering our friend from the last chapter, <code>1 + 2</code>.</p>
<div class="sourceCode" id="cb5"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb5-1" data-line-number="1"><span class="dt">Prelude</span><span class="fu">&gt;</span> <span class="dv">1</span> <span class="fu">+</span> <span class="dv">2</span></a>
<a class="sourceLine" id="cb5-2" data-line-number="2"><span class="dv">3</span></a></code></pre></div>
<p>If you try that and see <code>3</code>, all is well. You can also try <code>-</code> for subtraction<label for="marginnote-9" class="margin-toggle">⊕</label> <input type="checkbox" id="marginnote-9" class="margin-toggle"/> <span class="marginnote"><code>-</code> can also be used to negate a number, such as turning <code>3</code> to <code>-3</code>.</span>, <code>*</code> for multiplication, <code>/</code> for division, and <code>^</code> for exponentiation, and <code>`rem`</code> for remainder<label for="marginnote-10" class="margin-toggle">⊕</label> <input type="checkbox" id="marginnote-10" class="margin-toggle"/> <span class="marginnote"><code>`rem`</code> divides two numbers and returns the remainder. It’s usually used to check if two numbers are divisible</span>. If you play around with these in GHCi, it might look something like this (To explain what I’m doing, I sometimes annotate my playing with <em>comments</em>, which begin with two <code>--</code> hyphens and are strictly for educational purposes):</p>
<div class="sourceCode" id="cb6"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb6-1" data-line-number="1"><span class="co">-- This is what comments look like.</span></a>
<a class="sourceLine" id="cb6-2" data-line-number="2"><span class="co">-- You can type a comment into GHCi, but it won&#39;t do anything.</span></a>
<a class="sourceLine" id="cb6-3" data-line-number="3"><span class="dt">Prelude</span><span class="fu">&gt;</span> (<span class="dv">13</span> <span class="fu">*</span> <span class="dv">4</span>) <span class="fu">/</span> <span class="dv">3</span></a>
<a class="sourceLine" id="cb6-4" data-line-number="4"><span class="fl">17.333333333333332</span></a>
<a class="sourceLine" id="cb6-5" data-line-number="5"><span class="dt">Prelude</span><span class="fu">&gt;</span> <span class="dv">3</span> <span class="fu">^</span> <span class="dv">3</span> <span class="fu">^</span> <span class="dv">3</span> <span class="fu">^</span> <span class="dv">2</span></a>
<a class="sourceLine" id="cb6-6" data-line-number="6"><span class="co">-- Omitted, but it&#39;s a pretty big number.</span></a>
<a class="sourceLine" id="cb6-7" data-line-number="7"></a>
<a class="sourceLine" id="cb6-8" data-line-number="8"><span class="co">-- Let&#39;s check if some numbers are divisible by 3 using `rem`, </span></a>
<a class="sourceLine" id="cb6-9" data-line-number="9"><span class="co">-- which tells us the remainder of the left argument divided by the right.</span></a>
<a class="sourceLine" id="cb6-10" data-line-number="10"><span class="dt">Prelude</span><span class="fu">&gt;</span> <span class="dv">10</span> <span class="ot">`rem`</span> <span class="dv">3</span> <span class="fu">==</span> <span class="dv">0</span></a>
<a class="sourceLine" id="cb6-11" data-line-number="11"><span class="dt">False</span></a>
<a class="sourceLine" id="cb6-12" data-line-number="12"><span class="dt">Prelude</span><span class="fu">&gt;</span> <span class="dv">12</span> <span class="ot">`rem`</span> <span class="dv">3</span> <span class="fu">==</span> <span class="dv">0</span></a>
<a class="sourceLine" id="cb6-13" data-line-number="13"><span class="dt">True</span></a></code></pre></div>
<p>You can define constants, just as you might expect.</p>
<div class="sourceCode" id="cb7"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb7-1" data-line-number="1"><span class="dt">Prelude</span><span class="fu">&gt;</span> i <span class="fu">=</span> <span class="dv">3</span></a>
<a class="sourceLine" id="cb7-2" data-line-number="2"><span class="dt">Prelude</span><span class="fu">&gt;</span> <span class="dv">4</span> <span class="fu">*</span> i</a>
<a class="sourceLine" id="cb7-3" data-line-number="3"><span class="dv">12</span></a></code></pre></div>
<p>There’s few restrictions that to what you can name a constant, other than that it cannot begin with an uppercase letter.</p>
<p>These operators we keep using, like <code>+</code> and <code>*</code>, are all examples of things called functions - let’s try writing some of our own! In GHCi, type</p>
<div class="sourceCode" id="cb8"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb8-1" data-line-number="1"><span class="dt">Prelude</span><span class="fu">&gt;</span> addOne x <span class="fu">=</span> x <span class="fu">+</span> <span class="dv">1</span></a>
<a class="sourceLine" id="cb8-2" data-line-number="2"><span class="dt">Prelude</span><span class="fu">&gt;</span> addOne <span class="dv">3</span></a>
<a class="sourceLine" id="cb8-3" data-line-number="3"><span class="dv">4</span></a></code></pre></div>
<p>Can you see what’s going on here? We’ve written a function called <code>addOne</code><label for="marginnote-11" class="margin-toggle">⊕</label> <input type="checkbox" id="marginnote-11" class="margin-toggle"/> <span class="marginnote">It’s convention in Haskell that if a function name is composed of multiple words, the first letter of each word after the first one is capitalized. That’s why we have <code>addOne</code>, not <code>addone</code>. In fact, Haskell won’t let you start a function name with an uppercase letter.</span>, which does exactly what it says on the tin (If you’re coming from other languages, notice that Haskell doesn’t use parentheses or commas in function calls). When we write <code>addOne 3</code> it’s the same as writing <code>3 + 1</code>. You can think of <code>addOne</code> as a kind of machine - you put a number in, and it spits a different number out. In our case, the number it spits out is always one higher than the one you put in. We say <code>addOne</code> <em>takes</em> a number as a parameter<label for="marginnote-12" class="margin-toggle">⊕</label> <input type="checkbox" id="marginnote-12" class="margin-toggle"/> <span class="marginnote">While they’re not technically equivalent, I will use the words “parameter” and “argument” interchangeably.</span>, and <em>returns</em> a different number.</p>
<figure>
<label for="figure-1" class="margin-toggle">⊕</label> <input type="checkbox" id="figure-1" class="margin-toggle"/> <span class="marginnote">Demonstration of how <code>addOne</code> works.</span> <img src="assets/exp_addOneDemo.svg" alt="Demonstration of how `addOne` works." />
</figure>
<hr />
<p><strong><strong><em>Exercises</em></strong></strong>:</p>
<ol type="1">
<li>Write a function that adds two to a number, called <code>addTwo</code>.</li>
</ol>
<hr />
<p><span class="newthought">You can</span> have a function with more than one variable, too<label for="marginnote-13" class="margin-toggle">⊕</label> <input type="checkbox" id="marginnote-13" class="margin-toggle"/> <span class="marginnote">As we’ll discuss later, functions with more than one variable are somewhat of an illusion in Haskell.</span>. Let’s see how that works.</p>
<div class="sourceCode" id="cb9"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb9-1" data-line-number="1"><span class="dt">Prelude</span><span class="fu">&gt;</span> addThenDouble x y <span class="fu">=</span> (x <span class="fu">+</span> y) <span class="fu">*</span> <span class="dv">2</span></a>
<a class="sourceLine" id="cb9-2" data-line-number="2"><span class="dt">Prelude</span><span class="fu">&gt;</span> addThenDouble <span class="dv">2</span> <span class="dv">4</span></a>
<a class="sourceLine" id="cb9-3" data-line-number="3"><span class="dv">12</span></a></code></pre></div>
<p>Let’s break down what’s going on here.</p>
<div class="sourceCode" id="cb10"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb10-1" data-line-number="1">  addThenDouble   x y    <span class="fu">=</span>   (x <span class="fu">+</span> y) <span class="fu">*</span> <span class="dv">2</span></a>
<a class="sourceLine" id="cb10-2" data-line-number="2"><span class="co">--    [1]         [2]   [3]     [4]</span></a></code></pre></div>
<ol type="1">
<li><p><code>addThenDouble</code> - The name of the function we’re defining.</p></li>
<li><p><code>x y</code> - The names of the <em>parameters</em> of our function. By having two, <em>x</em> and <em>y</em>, we’re saying this function takes two parameters. Your parameters can be named whatever you want, as long as it doesn’t begin with an uppercase letter and isn’t already taken by the name of a function.</p></li>
<li><p><code>=</code> - “equals”. You can read this as a separator between the left half and the right half. The <code>addThenDouble x y</code> is the function’s name and parameters - the right <code>(x + y) * 2</code> is what the function does.</p></li>
<li><p><code>(x + y) * 2</code> - What the function does to the two numbers that you gave it. In our case, it adds them and then multiplies the result by two.</p></li>
</ol>
<p>This is a function that takes two numbers, adds them together, then doubles the result. Writing <code>addThenDouble 2 4</code> is the same as writing <code>(2 + 4) * 2</code> or just <code>12</code>.</p>
<p>You’re able to use your custom functions when writing new ones, and it’s where the real power of functions appears:</p>
<div class="sourceCode" id="cb11"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb11-1" data-line-number="1"><span class="dt">Prelude</span><span class="fu">&gt;</span> addOneTwice x <span class="fu">=</span> addOne (addOne x)</a>
<a class="sourceLine" id="cb11-2" data-line-number="2"><span class="dt">Prelude</span><span class="fu">&gt;</span> addOneTwice <span class="dv">4</span></a>
<a class="sourceLine" id="cb11-3" data-line-number="3"><span class="dv">6</span></a></code></pre></div>
<p>The parentheses are used to tell Haskell we want to do <code>addOne x</code> first, then run <code>addOne</code> on the result of that. Omitting these parentheses will result in an error. So we’ve seen that we can have functions with one or two variables, but how about… zero variables?</p>
<div class="sourceCode" id="cb12"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb12-1" data-line-number="1"><span class="dt">Prelude</span><span class="fu">&gt;</span> always3 <span class="fu">=</span> <span class="dv">3</span></a>
<a class="sourceLine" id="cb12-2" data-line-number="2"><span class="dt">Prelude</span><span class="fu">&gt;</span> always3</a>
<a class="sourceLine" id="cb12-3" data-line-number="3"><span class="dv">3</span></a></code></pre></div>
<p>You’ve seen this before, only then you didn’t know it was a function, because I called it a constant<label for="sidenote-3" class="margin-toggle sidenote-number"></label> <input type="checkbox" id="sidenote-3" class="margin-toggle"/> <span class="sidenote">The proper name would be a <em>nullary function</em>.</span>! But in reality, it’s a function that doesn’t have any parameters and just returns 3. GHCi will allow you to define <code>i = 1</code> and then later define <code>i = 2</code>, but this is not allowed in “real” Haskell (which we’ll go over in a moment).</p>
<p><span class="newthought">Now, this</span> is all well and good, but not very conducive to writing actual programs. For that, you need to be able to write your code into a text file and run it. To do that, make a new file somewhere on your computer called <code>myProgram.hs</code><label for="marginnote-14" class="margin-toggle">⊕</label> <input type="checkbox" id="marginnote-14" class="margin-toggle"/> <span class="marginnote"><code>.hs</code> is the extension used for most Haskell programs.</span>. Inside it, write:</p>
<div class="sourceCode" id="cb13"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb13-1" data-line-number="1"><span class="co">-- myProgram.hs</span></a>
<a class="sourceLine" id="cb13-2" data-line-number="2"><span class="ot">addone ::</span> <span class="dt">Int</span> <span class="ot">-&gt;</span> <span class="dt">Int</span></a>
<a class="sourceLine" id="cb13-3" data-line-number="3">addone x <span class="fu">=</span> x <span class="fu">+</span> <span class="dv">1</span></a>
<a class="sourceLine" id="cb13-4" data-line-number="4"></a>
<a class="sourceLine" id="cb13-5" data-line-number="5"><span class="ot">addtwo ::</span> <span class="dt">Int</span> <span class="ot">-&gt;</span> <span class="dt">Int</span></a>
<a class="sourceLine" id="cb13-6" data-line-number="6">addtwo x <span class="fu">=</span> addone (addone x)</a></code></pre></div>
<p>I like to put a comment<label for="sidenote-4" class="margin-toggle sidenote-number"></label> <input type="checkbox" id="sidenote-4" class="margin-toggle"/> <span class="sidenote">starting with <code>--</code>, remember</span> at the top of these examples with the name of the file, but it isn’t necessary. Now, in your terminal, navigate to the directory where the file is located<label for="marginnote-15" class="margin-toggle">⊕</label> <input type="checkbox" id="marginnote-15" class="margin-toggle"/> <span class="marginnote">remember, you can get out of GHCi by typing <code>:quit</code></span>. Then open up GHCi again and type:</p>
<div class="sourceCode" id="cb14"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb14-1" data-line-number="1"><span class="dt">Prelude</span><span class="fu">&gt;</span> <span class="fu">:</span>load myProgram<span class="fu">.</span>hs</a>
<a class="sourceLine" id="cb14-2" data-line-number="2"><span class="fu">*</span><span class="dt">Main</span><span class="fu">&gt;</span> addOne <span class="dv">100</span></a></code></pre></div>
<p><code>:load</code> is a special GHCi command<label for="marginnote-16" class="margin-toggle">⊕</label> <input type="checkbox" id="marginnote-16" class="margin-toggle"/> <span class="marginnote">Anything that starts with a <code>:</code> is a GHCi command, not real Haskell.</span> - it tells GHCi to interpret the file you give it and load it into your interpreter so you can play with it. You defined <code>addOne</code> in <code>myProgram.hs</code>, so by typing <code>:load myProgram.hs</code> you load all the functions in that file.</p>
<p>You might have also noticed <code>Prelude&gt;</code> changed to <code>*Main&gt;</code>, and I’ll explain why that happens in the future. But for now, you can have fun playing with it - try running <code>:set prompt &quot;Haskell is fun&gt; &quot;</code>.</p>
<hr />
<p><strong><strong><em>Exercises</em></strong></strong>:</p>
<ol type="1">
<li><p>What do you think that the following function will do?</p>
<div class="sourceCode" id="cb15"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb15-1" data-line-number="1">foo x <span class="fu">=</span> x <span class="fu">*</span> <span class="dv">3</span></a></code></pre></div>
<p>If you’re unsure, you can try entering it into GHCi.</p></li>
<li><p>In GHCi, write a function called <code>circumference</code>, which takes a number and multiplies it by <code>3.14</code>.</p></li>
<li><p>In GHCi, write a function called <code>doubleDifference</code> that takes two values, subtracts the second from the first, then doubles the result. Stuck? Try looking at some of the functions we made earlier in this chapter.</p></li>
</ol>
<hr />
<h1 id="types-and-type-signatures">Types and type signatures</h1>
<h2 id="more-types">More types!</h2>
<p><span class="newthought">You’ve already</span> seen you can set a constant to a number:</p>
<div class="sourceCode" id="cb16"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb16-1" data-line-number="1"><span class="dt">Prelude</span><span class="fu">&gt;</span> i <span class="fu">=</span> <span class="dv">1</span></a>
<a class="sourceLine" id="cb16-2" data-line-number="2"><span class="dt">Prelude</span><span class="fu">&gt;</span> i</a>
<a class="sourceLine" id="cb16-3" data-line-number="3"><span class="dv">1</span></a></code></pre></div>
<p>But there’s lots of other <em>types</em> of things you can set constants on, too! Go back to GHCi and try this:</p>
<div class="sourceCode" id="cb17"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb17-1" data-line-number="1"><span class="dt">Prelude</span><span class="fu">&gt;</span> c1 <span class="fu">=</span> <span class="ch">&#39;a&#39;</span></a>
<a class="sourceLine" id="cb17-2" data-line-number="2"><span class="dt">Prelude</span><span class="fu">&gt;</span> c2 <span class="fu">=</span> <span class="ch">&#39;b&#39;</span></a>
<a class="sourceLine" id="cb17-3" data-line-number="3"><span class="dt">Prelude</span><span class="fu">&gt;</span> c1</a>
<a class="sourceLine" id="cb17-4" data-line-number="4"><span class="ch">&#39;a&#39;</span></a>
<a class="sourceLine" id="cb17-5" data-line-number="5"><span class="dt">Prelude</span><span class="fu">&gt;</span> c2</a>
<a class="sourceLine" id="cb17-6" data-line-number="6"><span class="ch">&#39;b&#39;</span></a></code></pre></div>
<p>What you’re seeing here is we can set a constant to a <code>Char</code> (a single character), instead of a number. Do <code>String</code>s work?</p>
<pre><code>Prelude&gt; s1 = &quot;abc&quot;
Prelude&gt; s1
&quot;abc&quot;</code></pre>
<p>They do! In Haskell, you use single quotes for <code>Char</code>s and double quotes for <code>String</code>s.</p>
<p>Booleans are also available in Haskell, like so:</p>
<div class="sourceCode" id="cb19"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb19-1" data-line-number="1"><span class="dt">Prelude</span><span class="fu">&gt;</span> a <span class="fu">=</span> <span class="dt">True</span></a>
<a class="sourceLine" id="cb19-2" data-line-number="2"><span class="dt">Prelude</span><span class="fu">&gt;</span> a</a>
<a class="sourceLine" id="cb19-3" data-line-number="3"><span class="dt">True</span></a>
<a class="sourceLine" id="cb19-4" data-line-number="4"><span class="dt">Prelude</span><span class="fu">&gt;</span> b <span class="fu">=</span> <span class="dt">False</span></a>
<a class="sourceLine" id="cb19-5" data-line-number="5"><span class="dt">Prelude</span><span class="fu">&gt;</span> b</a>
<a class="sourceLine" id="cb19-6" data-line-number="6"><span class="dt">False</span></a></code></pre></div>
<p>There are (almost) infinite different numbers you can choose from, but Booleans only have two allowed values: <code>True</code> and <code>False</code><label for="sidenote-5" class="margin-toggle sidenote-number"></label> <input type="checkbox" id="sidenote-5" class="margin-toggle"/> <span class="sidenote">There’s also <code>undefined</code>, which is a bit of an exception to every rule and not something you should worry about.</span>. Booleans are called <code>Bool</code>s in Haskell.</p>
<p><span class="newthought">You can</span> test the equality of two values using <code>==</code>. To see if they’re not equal, you use <code>/=</code><label for="marginnote-17" class="margin-toggle">⊕</label> <input type="checkbox" id="marginnote-17" class="margin-toggle"/> <span class="marginnote">The <code>==</code> and <code>/=</code> functions take two values of the same type and return a <code>Bool</code>.</span>.</p>
<div class="sourceCode" id="cb20"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb20-1" data-line-number="1"><span class="dt">Prelude</span><span class="fu">&gt;</span> a <span class="fu">=</span> <span class="dv">1</span></a>
<a class="sourceLine" id="cb20-2" data-line-number="2"><span class="dt">Prelude</span><span class="fu">&gt;</span> b <span class="fu">=</span> <span class="dv">1</span></a>
<a class="sourceLine" id="cb20-3" data-line-number="3"><span class="dt">Prelude</span><span class="fu">&gt;</span> c <span class="fu">=</span> <span class="dv">3</span></a>
<a class="sourceLine" id="cb20-4" data-line-number="4"><span class="dt">Prelude</span><span class="fu">&gt;</span> a <span class="fu">==</span> b</a>
<a class="sourceLine" id="cb20-5" data-line-number="5"><span class="dt">True</span></a>
<a class="sourceLine" id="cb20-6" data-line-number="6"><span class="dt">Prelude</span><span class="fu">&gt;</span> a <span class="fu">==</span> c</a>
<a class="sourceLine" id="cb20-7" data-line-number="7"><span class="dt">False</span></a>
<a class="sourceLine" id="cb20-8" data-line-number="8"><span class="dt">Prelude</span><span class="fu">&gt;</span> a <span class="fu">/=</span> c</a>
<a class="sourceLine" id="cb20-9" data-line-number="9"><span class="dt">True</span></a></code></pre></div>
<p>That works on numbers, <code>String</code>s and <code>Char</code>s, too:</p>
<div class="sourceCode" id="cb21"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb21-1" data-line-number="1"><span class="dt">Prelude</span><span class="fu">&gt;</span> a <span class="fu">=</span> <span class="ch">&#39;a&#39;</span></a>
<a class="sourceLine" id="cb21-2" data-line-number="2"><span class="dt">Prelude</span><span class="fu">&gt;</span> b <span class="fu">=</span> <span class="ch">&#39;b&#39;</span></a>
<a class="sourceLine" id="cb21-3" data-line-number="3"><span class="dt">Prelude</span><span class="fu">&gt;</span> a <span class="fu">==</span> b</a>
<a class="sourceLine" id="cb21-4" data-line-number="4"><span class="dt">False</span></a>
<a class="sourceLine" id="cb21-5" data-line-number="5"><span class="dt">Prelude</span><span class="fu">&gt;</span> a <span class="fu">/=</span> b</a>
<a class="sourceLine" id="cb21-6" data-line-number="6"><span class="dt">True</span></a></code></pre></div>
<p>There are some functions that take <code>Bool</code>s, of course. There’s <code>&amp;&amp;</code>, which means “and”, and <code>||</code>, which means “or”. These functions each take two <code>Bool</code>s and return a new <code>Bool</code>.</p>
<div class="sourceCode" id="cb22"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb22-1" data-line-number="1"><span class="co">-- You can use &amp;&amp; to mean &quot;and&quot; and || to mean &quot;or&quot;, too.</span></a>
<a class="sourceLine" id="cb22-2" data-line-number="2"><span class="dt">Prelude</span><span class="fu">&gt;</span> <span class="dv">1</span> <span class="fu">==</span> <span class="dv">1</span> <span class="fu">&amp;&amp;</span> <span class="dv">2</span> <span class="fu">==</span> <span class="dv">2</span> </a>
<a class="sourceLine" id="cb22-3" data-line-number="3"><span class="dt">True</span></a>
<a class="sourceLine" id="cb22-4" data-line-number="4"><span class="dt">Prelude</span><span class="fu">&gt;</span> <span class="dv">1</span> <span class="fu">==</span> <span class="dv">1</span> <span class="fu">&amp;&amp;</span> <span class="dv">2</span> <span class="fu">==</span> <span class="dv">3</span></a>
<a class="sourceLine" id="cb22-5" data-line-number="5"><span class="dt">False</span></a>
<a class="sourceLine" id="cb22-6" data-line-number="6"><span class="dt">Prelude</span><span class="fu">&gt;</span> <span class="dv">1</span> <span class="fu">==</span> <span class="dv">1</span> <span class="fu">||</span> <span class="dv">2</span> <span class="fu">==</span> <span class="dv">2</span></a>
<a class="sourceLine" id="cb22-7" data-line-number="7"><span class="dt">True</span></a>
<a class="sourceLine" id="cb22-8" data-line-number="8"><span class="dt">Prelude</span><span class="fu">&gt;</span> <span class="dv">1</span> <span class="fu">==</span> <span class="dv">1</span> <span class="fu">||</span> <span class="dv">2</span> <span class="fu">==</span> <span class="dv">3</span></a>
<a class="sourceLine" id="cb22-9" data-line-number="9"><span class="dt">True</span></a>
<a class="sourceLine" id="cb22-10" data-line-number="10"><span class="dt">Prelude</span><span class="fu">&gt;</span> <span class="dv">1</span> <span class="fu">==</span> <span class="dv">3</span> <span class="fu">||</span> <span class="dv">2</span> <span class="fu">==</span> <span class="dv">3</span></a>
<a class="sourceLine" id="cb22-11" data-line-number="11"><span class="dt">False</span></a></code></pre></div>
<p><span class="newthought">Haskell keeps</span> track of what <em>type</em> everything is<label for="marginnote-18" class="margin-toggle">⊕</label> <input type="checkbox" id="marginnote-18" class="margin-toggle"/> <span class="marginnote">You can think of Haskell types as little labels that are attached to everything in your program.</span>. If <code>i</code> is a number and <code>c</code> is a <code>Char</code>, it doesn’t make sense to ask if one is equal to another - they’re two different types of things, of course they aren’t! If you try to run <code>i == c</code>, Haskell will make an error, because <code>==</code> requires that both of its arguments be the same type. Similarly, multiplication only works on numbers, so Haskell won’t let you write <code>5 * 'a'</code>. Haskell keeping track of the types of everything is very helpful, and is part of Haskell’s secret to prevent you from writing buggy software. This is called a <em>type system</em>, and lots of languages have one, but Haskell’s is better than most other languages’.</p>
<p><span class="newthought">Lists are</span> also possible in Haskell, let’s check those out.</p>
<div class="sourceCode" id="cb23"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb23-1" data-line-number="1"><span class="dt">Prelude</span><span class="fu">&gt;</span> myNumberList <span class="fu">=</span> [<span class="dv">1</span>, <span class="dv">2</span>, <span class="dv">3</span>]</a>
<a class="sourceLine" id="cb23-2" data-line-number="2"><span class="dt">Prelude</span><span class="fu">&gt;</span> myNumberList</a>
<a class="sourceLine" id="cb23-3" data-line-number="3">[<span class="dv">1</span>,<span class="dv">2</span>,<span class="dv">3</span>]</a>
<a class="sourceLine" id="cb23-4" data-line-number="4"><span class="dt">Prelude</span><span class="fu">&gt;</span> myCharList <span class="fu">=</span> [<span class="ch">&#39;a&#39;</span>, <span class="ch">&#39;b&#39;</span>, <span class="ch">&#39;c&#39;</span>]</a></code></pre></div>
<p>You might have noticed that if you type <code>myCharList</code> to tell GCHi to show it to you, then you see:</p>
<div class="sourceCode" id="cb24"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb24-1" data-line-number="1"><span class="dt">Prelude</span><span class="fu">&gt;</span> myCharList</a>
<a class="sourceLine" id="cb24-2" data-line-number="2"><span class="st">&quot;abc&quot;</span></a></code></pre></div>
<p>What gives? It’s saying <code>&quot;abc&quot;</code>, but we typed <code>['a', 'b', 'c']</code>! Well that’s because in Haskell, a <code>String</code> is just a List of <code>Char</code>s. So when you type <code>&quot;abc&quot;</code>, Haskell treats it as of you typed <code>['a', 'b', 'c']</code>. And when you ask GHCi to display a List of <code>Char</code>s, it shows it as <code>&quot;abc&quot;</code> instead of <code>['a', 'b', 'c']</code> because <code>&quot;abc&quot;</code> is easier to read and write.</p>
<p><span class="newthought">Now, I’m</span> going to show you a very important GHCi command. It’s called <code>:type</code>, or <code>:t</code> for short. You see, almost everything in Haskell has a type. Let’s try on some of our constants:</p>
<div class="sourceCode" id="cb25"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb25-1" data-line-number="1"><span class="dt">Prelude</span><span class="fu">&gt;</span> a <span class="fu">=</span> <span class="ch">&#39;a&#39;</span></a>
<a class="sourceLine" id="cb25-2" data-line-number="2"><span class="dt">Prelude</span><span class="fu">&gt;</span> <span class="fu">:</span><span class="kw">type</span> a</a>
<a class="sourceLine" id="cb25-3" data-line-number="3"><span class="ot">a ::</span> <span class="dt">Char</span></a></code></pre></div>
<p>This is GHCi telling us our ‘a’ is of type <code>Char</code>. The <code>::</code> is just a bit of syntax GHCi uses to tell you what it’s talking about, it doesn’t affect the type.</p>
<div class="sourceCode" id="cb26"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb26-1" data-line-number="1"><span class="dt">Prelude</span><span class="fu">&gt;</span> s1 <span class="fu">=</span> [<span class="ch">&#39;a&#39;</span>, <span class="ch">&#39;b&#39;</span>, <span class="ch">&#39;c&#39;</span>]</a>
<a class="sourceLine" id="cb26-2" data-line-number="2"><span class="dt">Prelude</span><span class="fu">&gt;</span> s2 <span class="fu">=</span> <span class="st">&quot;abc&quot;</span></a>
<a class="sourceLine" id="cb26-3" data-line-number="3"><span class="dt">Prelude</span><span class="fu">&gt;</span> s1 <span class="fu">==</span> s2</a>
<a class="sourceLine" id="cb26-4" data-line-number="4"><span class="dt">True</span></a></code></pre></div>
<p>You can have lists of other things too, by the way.</p>
<div class="sourceCode" id="cb27"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb27-1" data-line-number="1"><span class="dt">Prelude</span><span class="fu">&gt;</span> i1 <span class="fu">=</span> [<span class="dv">1</span>,<span class="dv">2</span>,<span class="dv">3</span>]</a>
<a class="sourceLine" id="cb27-2" data-line-number="2"><span class="dt">Prelude</span><span class="fu">&gt;</span> i1</a>
<a class="sourceLine" id="cb27-3" data-line-number="3">[<span class="dv">1</span>,<span class="dv">2</span>,<span class="dv">3</span>]</a>
<a class="sourceLine" id="cb27-4" data-line-number="4"><span class="dt">Prelude</span><span class="fu">&gt;</span> i2 <span class="fu">=</span> [<span class="st">&quot;hello&quot;</span>, <span class="st">&quot;world&quot;</span>]</a>
<a class="sourceLine" id="cb27-5" data-line-number="5"><span class="dt">Prelude</span><span class="fu">&gt;</span> i2</a>
<a class="sourceLine" id="cb27-6" data-line-number="6">[<span class="st">&quot;hello&quot;</span>,<span class="st">&quot;world&quot;</span>]</a></code></pre></div>
<p><code>i1</code> is a List of numbers. <code>i2</code> is a List of <code>String</code>s. And since a <code>String</code> is really just a List of <code>Char</code>s, <code>i2</code> is a List of Lists of <code>Char</code>s<label for="marginnote-19" class="margin-toggle">⊕</label> <input type="checkbox" id="marginnote-19" class="margin-toggle"/> <span class="marginnote">Note one rule about Haskell Lists: everything in them has to be of the same type. If you try <code>i = [1, 2, &quot;a&quot;]</code>, GHCi will give you an error.</span>!</p>
<p>Lists have some useful features. You can use <code>++</code> to concatenate two lists.</p>
<div class="sourceCode" id="cb28"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb28-1" data-line-number="1"><span class="dt">Prelude</span><span class="fu">&gt;</span> s1 <span class="fu">=</span> <span class="st">&quot;Hello&quot;</span></a>
<a class="sourceLine" id="cb28-2" data-line-number="2"><span class="dt">Prelude</span><span class="fu">&gt;</span> s2 <span class="fu">=</span> <span class="st">&quot;World&quot;</span></a>
<a class="sourceLine" id="cb28-3" data-line-number="3"><span class="dt">Prelude</span><span class="fu">&gt;</span> s1 <span class="fu">++</span> s2</a>
<a class="sourceLine" id="cb28-4" data-line-number="4"><span class="st">&quot;HelloWorld&quot;</span></a></code></pre></div>
<p>Whoops! We forgot to put a space in there.</p>
<div class="sourceCode" id="cb29"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb29-1" data-line-number="1"><span class="dt">Prelude</span><span class="fu">&gt;</span> s1 <span class="fu">=</span> <span class="st">&quot;Hello&quot;</span></a>
<a class="sourceLine" id="cb29-2" data-line-number="2"><span class="dt">Prelude</span><span class="fu">&gt;</span> s2 <span class="fu">=</span> <span class="st">&quot;World&quot;</span></a>
<a class="sourceLine" id="cb29-3" data-line-number="3"><span class="dt">Prelude</span><span class="fu">&gt;</span> s1 <span class="fu">++</span> <span class="st">&quot; &quot;</span> <span class="fu">++</span> s2</a>
<a class="sourceLine" id="cb29-4" data-line-number="4"><span class="st">&quot;Hello World&quot;</span></a></code></pre></div>
<p>Let’s write a function to do this for us, so we don’t have to it every time.</p>
<div class="sourceCode" id="cb30"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb30-1" data-line-number="1"><span class="dt">Prelude</span><span class="fu">&gt;</span> concatWithSpace l1 l2 <span class="fu">=</span> l1 <span class="fu">++</span> <span class="st">&quot; &quot;</span> <span class="fu">++</span> l2</a>
<a class="sourceLine" id="cb30-2" data-line-number="2"><span class="dt">Prelude</span><span class="fu">&gt;</span> concatWithSpace <span class="st">&quot;Hello&quot;</span> <span class="st">&quot;World&quot;</span></a>
<a class="sourceLine" id="cb30-3" data-line-number="3"><span class="st">&quot;Hello World&quot;</span></a></code></pre></div>
<p>See, it’s pretty easy, huh? If you’d like to be able to put <code>concatWithSpace</code> between the two <code>String</code>s, like you can with <code>++</code>, simply surround it with <code>`</code> backticks.</p>
<div class="sourceCode" id="cb31"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb31-1" data-line-number="1"><span class="dt">Prelude</span><span class="fu">&gt;</span> <span class="st">&quot;Hello&quot;</span> <span class="ot">`concatWithSpace`</span> <span class="st">&quot;World&quot;</span></a>
<a class="sourceLine" id="cb31-2" data-line-number="2"><span class="st">&quot;Hello World&quot;</span></a></code></pre></div>
<p>If all you need to do is put a value at the beginning of a List, you can do so with the <code>:</code> operator<label for="marginnote-20" class="margin-toggle">⊕</label> <input type="checkbox" id="marginnote-20" class="margin-toggle"/> <span class="marginnote">You might want to remember this, because it turns out to be a very fundamental operation for Lists!</span>.</p>
<div class="sourceCode" id="cb32"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb32-1" data-line-number="1"><span class="dt">Prelude</span><span class="fu">&gt;</span> <span class="dv">1</span><span class="fu">:</span>[<span class="dv">2</span>,<span class="dv">3</span>]</a>
<a class="sourceLine" id="cb32-2" data-line-number="2">[<span class="dv">1</span>,<span class="dv">2</span>,<span class="dv">3</span>]</a></code></pre></div>
<h2 id="type-signatures">Type signatures</h2>
<p><span class="newthought">As you</span> just learned, when you have a constant, it can be a number (like <code>i = 2</code>), a <code>Char</code> (like <code>c = 'x'</code>), or a <code>String</code> (like <code>s = &quot;hello&quot;</code>), a List of Strings, a List of Numbers, or one of many other types.</p>
<p><label for="marginfigure-1" class="margin-toggle">⊕</label> <input type="checkbox" id="marginfigure-1" class="margin-toggle"/> <span class="marginnote"><img src="assets/exp_typesAndSignatures.svg" alt="Some examples of types and type signatures."/>Some examples of types and type signatures.</span></p>
<p>In Haskell, every value has a type. We can figure out a value’s type with the <code>:type</code> command in GHCi, which shows us it’s <em>type signature</em>. A type signature is just a way of writing down a value’s type. You can also use <code>:t</code> instead of <code>:type</code>. Let’s try it out.</p>
<pre><code>Prelude&gt; i = &#39;a&#39;
Prelude&gt; :type i
i :: Char</code></pre>
<p>GHCi is trying to tell you that <code>i</code> has the type <code>Char</code>. To do that, it says <code>i :: Char</code>. You can read <code>::</code> as “has the type”. Let’s try another.</p>
<div class="sourceCode" id="cb34"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb34-1" data-line-number="1"><span class="dt">Prelude</span><span class="fu">&gt;</span> s <span class="fu">=</span> <span class="st">&quot;hello!&quot;</span></a>
<a class="sourceLine" id="cb34-2" data-line-number="2"><span class="dt">Prelude</span><span class="fu">&gt;</span> <span class="fu">:</span><span class="kw">type</span> s</a>
<a class="sourceLine" id="cb34-3" data-line-number="3"><span class="ot">s ::</span> [<span class="dt">Char</span>]</a></code></pre></div>
<p>This is GHCi telling you <code>s</code> has the type <code>[Char]</code>, which means it’s a List of <code>Chars</code> (A <code>String</code> is the same as <code>[Char]</code>). The square <code>[]</code> brackets are telling us it’s a List of Chars, not just a regular <code>Char</code>.). Do you remember what type <code>True</code> is?</p>
<div class="sourceCode" id="cb35"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb35-1" data-line-number="1"><span class="dt">Prelude</span><span class="fu">&gt;</span> <span class="fu">:</span><span class="kw">type</span> <span class="dt">True</span></a>
<a class="sourceLine" id="cb35-2" data-line-number="2"><span class="dt">True</span><span class="ot"> ::</span> <span class="dt">Bool</span></a></code></pre></div>
<p>Ah yes, a <code>Bool</code>. Remember though, I said everything has a type, not just constants. Let’s write a function to test this, <code>addABang</code>, which takes a <code>String</code> and puts an exclamation mark at the end.</p>
<div class="sourceCode" id="cb36"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb36-1" data-line-number="1"><span class="dt">Prelude</span><span class="fu">&gt;</span> addABang s <span class="fu">=</span> s <span class="fu">++</span> <span class="st">&quot;!&quot;</span></a>
<a class="sourceLine" id="cb36-2" data-line-number="2"><span class="dt">Prelude</span><span class="fu">&gt;</span> addABang <span class="st">&quot;hello&quot;</span></a>
<a class="sourceLine" id="cb36-3" data-line-number="3"><span class="st">&quot;hello!&quot;</span></a></code></pre></div>
<p>Works like a charm. Now let’s see what type it has.</p>
<div class="sourceCode" id="cb37"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb37-1" data-line-number="1"><span class="dt">Prelude</span><span class="fu">&gt;</span> <span class="fu">:</span><span class="kw">type</span> addABang</a>
<a class="sourceLine" id="cb37-2" data-line-number="2"><span class="ot">addABang ::</span> [<span class="dt">Char</span>] <span class="ot">-&gt;</span> [<span class="dt">Char</span>]</a></code></pre></div>
<p>The <code>-&gt;</code> arrow means we’re dealing with a function. In our case, a function that takes a <code>[Char]</code> and returns a <code>[Char]</code>.</p>
<p>Remember the <code>concatWithSpace</code> function? We can use <code>:type</code> to see what type it has too.</p>
<div class="sourceCode" id="cb38"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb38-1" data-line-number="1"><span class="dt">Prelude</span><span class="fu">&gt;</span> concatWithSpace l1 l2 <span class="fu">=</span> l1 <span class="fu">++</span> <span class="st">&quot; &quot;</span> <span class="fu">++</span> l2</a>
<a class="sourceLine" id="cb38-2" data-line-number="2"><span class="dt">Prelude</span><span class="fu">&gt;</span> <span class="fu">:</span><span class="kw">type</span> concatWithSpace</a>
<a class="sourceLine" id="cb38-3" data-line-number="3"><span class="ot">concatWithSpace ::</span> [<span class="dt">Char</span>] <span class="ot">-&gt;</span> [<span class="dt">Char</span>] <span class="ot">-&gt;</span> [<span class="dt">Char</span>]</a></code></pre></div>
<p>You might be wondering what multiple <code>-&gt;</code> arrows mean. That’s how functions with multiple parameters are typed in Haskell. The thing after the last arrow is the output, all the rest are the parameters. So <code>concatWithSpace</code> takes two <code>[Char]</code>s and returns a <code>[Char]</code><label for="sidenote-6" class="margin-toggle sidenote-number"></label> <input type="checkbox" id="sidenote-6" class="margin-toggle"/> <span class="sidenote">You might be wondering why it’s done like this. Isn’t it confusing that the return type looks just like a parameter? Well, it has to be this way, because of a Haskell feature called <em>currying</em> (which I will explain in a later chapter).</span>.</p>
<div class="sourceCode" id="cb39"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb39-1" data-line-number="1"><span class="ot">  concatWithSpace ::</span> [<span class="dt">Char</span>] <span class="ot">-&gt;</span> [<span class="dt">Char</span>] <span class="ot">-&gt;</span> [<span class="dt">Char</span>]</a>
<a class="sourceLine" id="cb39-2" data-line-number="2"><span class="co">--                   ================    ======</span></a>
<a class="sourceLine" id="cb39-3" data-line-number="3"><span class="co">--                        input          output</span></a></code></pre></div>
<p>When writing Haskell functions, it’s usually a good idea to write the type signatures explicitly, even though you usually don’t need to. Let’s make a new file, <code>testingTypes.hs</code>. Inside it, put:</p>
<div class="sourceCode" id="cb40"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb40-1" data-line-number="1"><span class="co">-- testingTypes.hs</span></a>
<a class="sourceLine" id="cb40-2" data-line-number="2"><span class="co">-- testingtypes.hs</span></a>
<a class="sourceLine" id="cb40-3" data-line-number="3"><span class="ot">concatWithSpace ::</span> [<span class="dt">Char</span>] <span class="ot">-&gt;</span> [<span class="dt">Char</span>] <span class="ot">-&gt;</span> [<span class="dt">Char</span>] <span class="co">-- This is the type signature.</span></a>
<a class="sourceLine" id="cb40-4" data-line-number="4">concatWithSpace l1 l2 <span class="fu">=</span> l1 <span class="fu">++</span> <span class="st">&quot; &quot;</span> <span class="fu">++</span> l2       <span class="co">-- This is the actual function.</span></a></code></pre></div>
<p>What we did here is write a type signature for our function. This just means we’re telling Haskell, and also anyone who reads this code, that <code>concatWithSpace</code> should have the type <code>[Char] -&gt; [Char] -&gt; [Char]</code> (meaning it takes a <code>[Char]</code>, then another <code>[Char]</code>, then returns a <code>[Char]</code>). This is important so let’s go over that once again. Here is our type signature:</p>
<div class="sourceCode" id="cb41"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb41-1" data-line-number="1"><span class="ot">    concatWithSpace   ::</span>    [<span class="dt">Char</span>]  <span class="ot">-&gt;</span>  [<span class="dt">Char</span>]  <span class="ot">-&gt;</span>  [<span class="dt">Char</span>]</a>
<a class="sourceLine" id="cb41-2" data-line-number="2"><span class="co">--  ===============   ==    ==============================</span></a>
<a class="sourceLine" id="cb41-3" data-line-number="3"><span class="co">---        [1]        [2]                [5]     </span></a></code></pre></div>
<ol type="1">
<li><p><code>concatWithSpace</code>: This tells Haskell that this type signature is for the <code>concatWithSpace</code> function.</p></li>
<li><p><code>::</code>: This separates the name of the function with the type we’re saying it has. You can read this as “is a”.</p></li>
<li><p><code>[Char]  -&gt;  [Char]  -&gt;  [Char]</code>: This is the type of the function. This function takes a <code>[Char]</code>, then another <code>[Char]</code>, then returns a <code>[Char]</code>.</p></li>
</ol>
<p><code>++</code>, <code>==</code>, <code>+</code>, <code>-</code>, <code>/</code>, <code>*</code>, and <code>^</code> are all functions. Because they’re written only with special characters, they’re also called <em>operators</em>. Operators are by default <em>in</em>fix functions, which mean they go <em>in</em> between their parameters, e.g. <code>1 + 2</code>.</p>
<p>You can turn an infix function into something that works more like a regular function by surrounding it in parentheses. So instead of writing <code>1 + 2</code>, you can also write <code>(+) 1 2</code>. Do you remember the <code>++</code> operator? It works on lists of any type, which you might think is strange. What could its type possibly be?</p>
<div class="sourceCode" id="cb42"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb42-1" data-line-number="1"><span class="dt">Prelude</span><span class="fu">&gt;</span> <span class="st">&quot;abc&quot;</span> <span class="fu">++</span> <span class="st">&quot;123&quot;</span></a>
<a class="sourceLine" id="cb42-2" data-line-number="2"><span class="st">&quot;abc123&quot;</span></a>
<a class="sourceLine" id="cb42-3" data-line-number="3"><span class="dt">Prelude</span><span class="fu">&gt;</span> [<span class="dt">True</span>, <span class="dt">True</span>] <span class="fu">++</span> [<span class="dt">False</span>, <span class="dt">False</span>]</a>
<a class="sourceLine" id="cb42-4" data-line-number="4">[<span class="dt">True</span>,<span class="dt">True</span>,<span class="dt">False</span>,<span class="dt">False</span>]</a></code></pre></div>
<p>See? It works on <code>[Char]</code> just as well as it works on <code>[Bool]</code>. Luckily, it’s easy for us to find out its type, just use <code>:type</code>! But <code>:type</code> wants a regular function, not an infix function, so you have to surround <code>++</code> in parentheses.</p>
<div class="sourceCode" id="cb43"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb43-1" data-line-number="1"><span class="dt">Prelude</span><span class="fu">&gt;</span> <span class="fu">:</span><span class="kw">type</span> (<span class="fu">++</span>)</a>
<a class="sourceLine" id="cb43-2" data-line-number="2"><span class="ot">(++) ::</span> [a] <span class="ot">-&gt;</span> [a] <span class="ot">-&gt;</span> [a]</a></code></pre></div>
<p>Strange! Instead of writing <code>[Char]</code> or any other real type, they’ve written <code>[a]</code>. Notice the lowercase letter - all real types start with uppercase letters. This means <code>a</code> is just a placeholder, or a <em>type variable</em>, for any type you want to give the function. When you pass <code>++</code> a <code>[Char]</code>, Haskell sees that <code>[Char]</code> can fit into <code>[a]</code> (since <code>a</code> can be any List). But it also requires consistency! Once Haskell knows that <code>a</code> is <code>Char</code> for this function call, then you can’t pass it an <code>[Int]</code> or <code>[String]</code> or anything besides <code>[Char]</code>. This means that if the first parameter is <code>[Char]</code>, the rest have to be, as well.</p>
<p>So this is ok:</p>
<div class="sourceCode" id="cb44"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb44-1" data-line-number="1"><span class="dt">Prelude</span><span class="fu">&gt;</span> <span class="st">&quot;Hello, &quot;</span> <span class="fu">++</span> <span class="st">&quot;world!&quot;</span></a></code></pre></div>
<p>Because the two parameters are both <code>[Char]</code>s, <code>a</code> can equal <code>Char</code> just fine. But this will give you an error:</p>
<div class="sourceCode" id="cb45"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb45-1" data-line-number="1"><span class="dt">Prelude</span><span class="fu">&gt;</span> [<span class="dv">1</span>, <span class="dv">2</span>, <span class="dv">3</span>] <span class="fu">++</span> [<span class="dt">True</span>, <span class="dt">True</span>, <span class="dt">False</span>]</a></code></pre></div>
<p>That’s because once you’ve given <code>++</code> a <code>[1, 2, 3]</code>, that means <code>a</code> has to be a number. Then when you give it <code>[True, True, False]</code>, Haskell knows <code>a</code> has to be a number, not a <code>Bool</code>, so it doesn’t work.</p>
<p>Here’s another example. The <code>head</code> function takes a List and gives you the first element of it.</p>
<div class="sourceCode" id="cb46"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb46-1" data-line-number="1"><span class="dt">Prelude</span><span class="fu">&gt;</span> head [<span class="dv">1</span>, <span class="dv">2</span>, <span class="dv">3</span>]</a>
<a class="sourceLine" id="cb46-2" data-line-number="2"><span class="dv">1</span></a></code></pre></div>
<p>What do you think its type will be?</p>
<div class="sourceCode" id="cb47"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb47-1" data-line-number="1"><span class="dt">Prelude</span><span class="fu">&gt;</span> <span class="fu">:</span><span class="kw">type</span> head</a>
<a class="sourceLine" id="cb47-2" data-line-number="2">head<span class="ot"> ::</span> [a] <span class="ot">-&gt;</span> a</a></code></pre></div>
<p>So this is telling us <code>head</code> takes a List of some type, and returns an element of that type. This is what we would expect! It’d be very strange if we gave it a List of <code>Bool</code>s and it said the first element was a <code>Char</code>.</p>
<hr />
<p><strong><strong><em>Exercises</em></strong></strong>:</p>
<ol type="1">
<li><p>What type will <code>head</code> give us if we give it a <code>[Char]</code>?</p></li>
<li><p>There’s a function called <code>tail</code> which is similar to <code>head</code>. It takes a List and returns a List of everything except the first element. So <code>tail &quot;abc&quot; == &quot;bc&quot;</code> and <code>tail [1,2,3] == [2,3]</code>. Can you guess what type signature tail has? To check your answer, run <code>:type tail</code> in GHCi.</p></li>
</ol>
<hr />
<h2 id="typeclasses">Typeclasses</h2>
<p><span class="newthought">In most</span> programming languages, but especially Haskell, there are some types that aren’t exactly the same but have some things in common. For instance, take the following Haskell types:</p>
<ol type="1">
<li><p><code>Integer</code> - Exactly what it sounds like. Integers are numbers like <code>-1</code>, <code>0</code>, <code>1</code>, or <code>1000</code>, but not <code>2.5</code>. It has no maximum or minimum value, but if you try to express too large of a number, eventually your computer will run out of memory.</p></li>
<li><p><code>Int</code> - This is the same “int” you might be familiar with from other languages. It has a maximum and minimum value, which can vary depending on what machine you’re on, but it is usually very large (generally the maximum is 2^31-1 and the minimum is -2^31). The tradeoff is that it’s more efficient than <code>Integer</code>.</p></li>
<li><p><code>Float</code> - Short for floating point. This holds numbers that can have decimal points, like <code>1.4</code> or <code>-2.5</code>, but can still hold whole numbers, like <code>2</code>. The drawback is that sometimes the numbers it holds aren’t exactly the number you think it is. This causes the scary <a href="https://stackoverflow.com/questions/2100490/floating-point-inaccuracy-examples"><em>floating point precision error</em></a>, where answers end up being just a little bit away from what they should be. Enter <code>0.1 + 0.2</code> into GHCi to see what I’m talking about.</p></li>
<li><p><code>Double</code> - This is the same as a <code>Float</code>, but it’s twice as precise. You can still run into floating point precision errors though.</p></li>
</ol>
<p>All four of these seem kind of similar. If you write a function that multiplies a number by two, it’d be nice you didn’t have to say specifically what type it takes, and could instead just say you want it to take in a number. Well luckily, that is very easy<label for="sidenote-7" class="margin-toggle sidenote-number"></label> <input type="checkbox" id="sidenote-7" class="margin-toggle"/> <span class="sidenote">Uniquely easy, in fact. In languages like C++ you’d have to do all kinds of fiddling with templates to get a result that still isn’t as nice as Haskell’s.</span>! Let’s write a function that doubles <code>Int</code>s.</p>
<div class="sourceCode" id="cb48"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb48-1" data-line-number="1"><span class="ot">intDoubler ::</span> <span class="dt">Int</span> <span class="ot">-&gt;</span> <span class="dt">Int</span></a>
<a class="sourceLine" id="cb48-2" data-line-number="2">intDoubler x <span class="fu">=</span> x <span class="fu">*</span> <span class="dv">2</span>  </a></code></pre></div>
<p><span class="newthought">All of</span> the types I mentioned above are inside a <em>typeclass</em><label for="marginnote-21" class="margin-toggle">⊕</label> <input type="checkbox" id="marginnote-21" class="margin-toggle"/> <span class="marginnote">Typeclasses have nothing to do with classes from most other languages! Don’t get confused.</span> called <code>Num</code>. That means you can use <code>+</code>, <code>-</code>, <code>*</code>, and <code>abs</code> on them (<code>abs</code> returns the absolute value of a number). Now, I’ll show you how to modify <code>intDoubler :: Int -&gt; Int</code> with some new syntax to allow it to work on anything in the <code>Num</code> typeclass, not just <code>Int</code>:</p>
<div class="sourceCode" id="cb49"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb49-1" data-line-number="1"><span class="ot">numberDoubler ::</span> (<span class="dt">Num</span> a) <span class="ot">=&gt;</span> a <span class="ot">-&gt;</span> a</a>
<a class="sourceLine" id="cb49-2" data-line-number="2">numberDoubler x <span class="fu">=</span> x <span class="fu">*</span> <span class="dv">2</span>  </a></code></pre></div>
<p>Let’s take a closer look at that type signature</p>
<div class="sourceCode" id="cb50"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb50-1" data-line-number="1"><span class="ot">     numberDoubler  ::</span>   <span class="dt">Num</span> a <span class="ot">=&gt;</span>    a  <span class="ot">-&gt;</span>  a</a>
<a class="sourceLine" id="cb50-2" data-line-number="2"><span class="co">--   ============   ==   ========    ========   </span></a>
<a class="sourceLine" id="cb50-3" data-line-number="3"><span class="co">--        [1]       [2]     [3]         [4]</span></a></code></pre></div>
<ol type="1">
<li><p><code>numberDoubler</code> - The name of our function.</p></li>
<li><p><code>::</code> - Remember, you can read this as “is a”.</p></li>
<li><p><code>Num a =&gt;</code> - Puts a restriction on the type variable <code>a</code>. Just <code>a</code> on its own can be anything, but when you put <code>Num a =&gt;</code> at the beginning of a type signature, whatever type <code>a</code> takes the place of is constrained to be part of the <code>Num</code> typeclass. This is called a <em>type constraint</em>, because it constrains what types are allowed (<code>a</code> would normally allow any type, but because of the type constraint <code>a</code> now has to be a number). You can think of <code>=&gt;</code> as using whatever is on the left side to constrain the right side.</p></li>
<li><p><code>a  -&gt;  a</code> - The part of the type signature that should be familiar to you. It means we’re dealing with a function that takes an <code>a</code> and returns an <code>a</code>. Thanks to <code>Num a =&gt;</code>, we have the constraint that <code>a</code> be inside the typeclass <code>Num</code>, but otherwise, we aren’t picky.</p></li>
</ol>
<p>The result is a function that can double anything in the <code>Num</code> typeclass, which is all our number types<label for="sidenote-8" class="margin-toggle sidenote-number"></label> <input type="checkbox" id="sidenote-8" class="margin-toggle"/> <span class="sidenote">If this seems intimidating, read on, more examples will make it clear.</span>!</p>
<h2 id="handy-typeclasses-and-more-examples">Handy typeclasses and more examples</h2>
<p><span class="newthought">You’ll see</span> here that a type can be a part of more than one typeclass. These are some typeclasses you’ll be seeing a lot of:</p>
<ol type="1">
<li><p><code>Eq</code> - This is the typeclass for anything that can be tested for equality, using the <code>==</code> and <code>/=</code> functions. Most types, including <code>Char</code>s, <code>String</code>s, and everything in the <code>Num</code> typeclass, fall under <code>Eq</code><label for="sidenote-9" class="margin-toggle sidenote-number"></label> <input type="checkbox" id="sidenote-9" class="margin-toggle"/> <span class="sidenote">In fact, almost all types except functions are inside the <code>Eq</code> typeclass.</span>.</p>
<div class="sourceCode" id="cb51"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb51-1" data-line-number="1"><span class="dt">Prelude</span><span class="fu">&gt;</span> <span class="dv">2</span> <span class="fu">==</span> <span class="dv">2</span></a>
<a class="sourceLine" id="cb51-2" data-line-number="2"><span class="dt">True</span></a>
<a class="sourceLine" id="cb51-3" data-line-number="3"><span class="dt">Prelude</span><span class="fu">&gt;</span> <span class="fu">:</span><span class="kw">type</span> (<span class="fu">==</span>)</a>
<a class="sourceLine" id="cb51-4" data-line-number="4"><span class="ot">(==) ::</span> <span class="dt">Eq</span> a <span class="ot">=&gt;</span> a <span class="ot">-&gt;</span> a <span class="ot">-&gt;</span> <span class="dt">Bool</span></a></code></pre></div>
<p>You can see <code>==</code> is a function that takes two values of type <code>a</code>, where <code>a</code> is inside the <code>Eq</code> typeclass, then returns a <code>Bool</code>.</p></li>
<li><p><code>Ord</code> - This is the typeclass for things that can be put in an order. They have functions like <code>&gt;</code>, <code>&gt;=</code>, etc. Anything that is part of the <code>Ord</code> typeclass is automatically part of the <code>Eq</code> typeclass<label for="sidenote-10" class="margin-toggle sidenote-number"></label> <input type="checkbox" id="sidenote-10" class="margin-toggle"/> <span class="sidenote"><code>Ord</code> is separate from <code>Num</code> because, for example, letters can be put in alphabetical order. Also, some numbers can’t be ordered, like <a href="http://hackage.haskell.org/package/base-4.11.1.0/docs/Data-Complex.html">complex numbers</a>.</span>.</p>
<div class="sourceCode" id="cb52"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb52-1" data-line-number="1"><span class="dt">Prelude</span><span class="fu">&gt;</span> <span class="dv">3</span> <span class="fu">&gt;</span> <span class="dv">5</span></a>
<a class="sourceLine" id="cb52-2" data-line-number="2"><span class="dt">False</span></a>
<a class="sourceLine" id="cb52-3" data-line-number="3"><span class="dt">Prelude</span><span class="fu">&gt;</span> <span class="fu">:</span><span class="kw">type</span> (<span class="fu">&gt;</span>)</a>
<a class="sourceLine" id="cb52-4" data-line-number="4"><span class="ot">(&gt;) ::</span> <span class="dt">Ord</span> a <span class="ot">=&gt;</span> a <span class="ot">-&gt;</span> a <span class="ot">-&gt;</span> <span class="dt">Bool</span></a></code></pre></div>
<p><code>&gt;</code> takes two values of type <code>a</code>, where <code>a</code> is of the typeclass <code>Ord</code>, and returns a <code>Bool</code>.</p></li>
<li><p><code>Show</code> - This is the typeclass for things that can be converted to strings with the function <code>show</code>. That’s actually what GHCi does whenever you enter an expression - if it’s of typeclass <code>Show</code>, then it calls <code>show</code> and prints the result<label for="sidenote-11" class="margin-toggle sidenote-number"></label> <input type="checkbox" id="sidenote-11" class="margin-toggle"/> <span class="sidenote">If it isn’t in the typeclass <code>Show</code>, you’ll see an error in GHCi.</span>.</p>
<div class="sourceCode" id="cb53"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb53-1" data-line-number="1"><span class="dt">Prelude</span><span class="fu">&gt;</span> show <span class="dv">2</span></a>
<a class="sourceLine" id="cb53-2" data-line-number="2"><span class="st">&quot;2&quot;</span></a>
<a class="sourceLine" id="cb53-3" data-line-number="3"><span class="dt">Prelude</span><span class="fu">&gt;</span> <span class="fu">:</span><span class="kw">type</span> show</a>
<a class="sourceLine" id="cb53-4" data-line-number="4">show<span class="ot"> ::</span> <span class="dt">Show</span> a <span class="ot">=&gt;</span> a <span class="ot">-&gt;</span> <span class="dt">String</span></a></code></pre></div>
<p><code>show</code> takes a value of type <code>a</code>, where <code>a</code> is of the typeclass <code>Show</code>, and returns a String.</p></li>
<li><p><code>Read</code> - This is the typeclass for things that can be converted from strings with the function <code>read</code>. It’s like the inverse of the Show typeclass. It’s a bit tricky because if it doesn’t know what type to return it’ll give you an error. Luckily we can tell it with <code>::</code><label for="sidenote-12" class="margin-toggle sidenote-number"></label> <input type="checkbox" id="sidenote-12" class="margin-toggle"/> <span class="sidenote">Which should be familiar to you, as it’s the same <code>::</code> you see in type signatures!</span>:</p>
<div class="sourceCode" id="cb54"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb54-1" data-line-number="1"><span class="dt">Prelude</span><span class="fu">&gt;</span> read <span class="st">&quot;5&quot;</span></a>
<a class="sourceLine" id="cb54-2" data-line-number="2"><span class="co">-- error! read doesn&#39;t know if we want an Int, an Integer, etc.</span></a>
<a class="sourceLine" id="cb54-3" data-line-number="3"><span class="dt">Prelude</span><span class="fu">&gt;</span> read <span class="st">&quot;5&quot;</span><span class="ot"> ::</span> <span class="dt">Int</span></a>
<a class="sourceLine" id="cb54-4" data-line-number="4"><span class="dv">5</span></a></code></pre></div>
<p>Let’s look at the type of <code>read</code>, as well:</p>
<div class="sourceCode" id="cb55"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb55-1" data-line-number="1"><span class="dt">Prelude</span><span class="fu">&gt;</span> <span class="fu">:</span><span class="kw">type</span> read</a>
<a class="sourceLine" id="cb55-2" data-line-number="2">read<span class="ot"> ::</span> <span class="dt">Read</span> a <span class="ot">=&gt;</span> <span class="dt">String</span> <span class="ot">-&gt;</span> a</a></code></pre></div>
<p>So <code>read</code> takes a string and returns a value of type <code>a</code>, where <code>a</code> is part of the <code>Read</code> typeclass.</p></li>
<li><p><code>Integral</code> and <code>Floating</code>. - <code>Integral</code> contains the types <code>Int</code> and <code>Integer</code>, and <code>Floating</code> contains the types <code>Float</code> and <code>Double</code>. You’ll see them often in one useful function, <code>fromIntegral</code>, which can convert an <code>Integral</code> into whatever <code>Num</code> is necessary:</p>
<div class="sourceCode" id="cb56"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb56-1" data-line-number="1"><span class="co">-- Remember, we can force a number to be an Int with, for example, `4 :: Int`.</span></a>
<a class="sourceLine" id="cb56-2" data-line-number="2"><span class="dt">Prelude</span><span class="fu">&gt;</span> i <span class="fu">=</span> (<span class="dv">4</span><span class="ot"> ::</span> <span class="dt">Int</span>)</a>
<a class="sourceLine" id="cb56-3" data-line-number="3"><span class="dt">Prelude</span><span class="fu">&gt;</span> i</a>
<a class="sourceLine" id="cb56-4" data-line-number="4"><span class="dv">4</span></a>
<a class="sourceLine" id="cb56-5" data-line-number="5"><span class="dt">Prelude</span><span class="fu">&gt;</span> f <span class="fu">=</span> (<span class="fl">3.5</span><span class="ot"> ::</span> <span class="dt">Float</span>)</a>
<a class="sourceLine" id="cb56-6" data-line-number="6"><span class="dt">Prelude</span><span class="fu">&gt;</span> f</a>
<a class="sourceLine" id="cb56-7" data-line-number="7"><span class="fl">3.5</span></a>
<a class="sourceLine" id="cb56-8" data-line-number="8"></a>
<a class="sourceLine" id="cb56-9" data-line-number="9"><span class="co">-- You can&#39;t add values of two different types! </span></a>
<a class="sourceLine" id="cb56-10" data-line-number="10"><span class="dt">Prelude</span><span class="fu">&gt;</span> i <span class="fu">+</span> f</a>
<a class="sourceLine" id="cb56-11" data-line-number="11"><span class="co">-- error!</span></a>
<a class="sourceLine" id="cb56-12" data-line-number="12"><span class="co">-- But we can convert i, which is an Int, to any other number using fromIntegral:</span></a>
<a class="sourceLine" id="cb56-13" data-line-number="13"><span class="dt">Prelude</span><span class="fu">&gt;</span> (fromIntegral i) <span class="fu">+</span> f</a>
<a class="sourceLine" id="cb56-14" data-line-number="14"><span class="fl">7.5</span></a></code></pre></div>
<p>The <code>fromIntegral</code> function is useful when a function returns an <code>Int</code> or <code>Integer</code> and you need it to be some other number type. Lets see what type it has:</p>
<div class="sourceCode" id="cb57"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb57-1" data-line-number="1"><span class="dt">Prelude</span><span class="fu">&gt;</span> <span class="fu">:</span><span class="kw">type</span> fromIntegral</a>
<a class="sourceLine" id="cb57-2" data-line-number="2">fromIntegral<span class="ot"> ::</span> (<span class="dt">Integral</span> a, <span class="dt">Num</span> b) <span class="ot">=&gt;</span> a <span class="ot">-&gt;</span> b</a></code></pre></div>
<p>That’s right, this one involves two different typeclasses. If you have more than one typeclass in your function’s type signature, they should have <code>()</code> parentheses around them and be separated by commas. You can describe this function as taking an Integral and returning a Num.</p></li>
</ol>
<hr />
<p><strong><strong><em>Exercises</em></strong></strong>:</p>
<ol type="1">
<li>What do you think the type signature of <code>+</code> is? Type <code>:type (+)</code> to check your answer.</li>
</ol>
<hr />
<h1 id="lists-and-tuples">Lists and Tuples</h1>
<h2 id="useful-functions-on-lists">Useful Functions on Lists</h2>
<p><span class="newthought">Lists</span><label for="marginnote-22" class="margin-toggle">⊕</label> <input type="checkbox" id="marginnote-22" class="margin-toggle"/> <span class="marginnote">If you’re familiar C++, it may interest you to know that Haskell Lists are actually represented internally as singly-linked lists, which has all the performance implications you’d expect. Haskell also has <a href="https://www.haskell.org/onlinereport/array.html">Arrays</a> which you can use where appropriate</span> are very useful in Haskell, and there are a lot of functions that work on lists that you should know about.</p>
<ol type="1">
<li><p><code>x:xs</code> inserts a value <code>x</code> at the beginning of a List <code>xs</code>.</p>
<div class="sourceCode" id="cb58"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb58-1" data-line-number="1"><span class="dt">Prelude</span><span class="fu">&gt;</span> <span class="dv">3</span><span class="fu">:</span>[<span class="dv">4</span>,<span class="dv">5</span>]</a>
<a class="sourceLine" id="cb58-2" data-line-number="2">[<span class="dv">3</span>,<span class="dv">4</span>,<span class="dv">5</span>]</a>
<a class="sourceLine" id="cb58-3" data-line-number="3"><span class="dt">Prelude</span><span class="fu">&gt;</span> <span class="dv">1</span><span class="fu">:</span>[]</a>
<a class="sourceLine" id="cb58-4" data-line-number="4">[<span class="dv">1</span>]</a>
<a class="sourceLine" id="cb58-5" data-line-number="5"><span class="dt">Prelude</span><span class="fu">&gt;</span> <span class="dv">1</span><span class="fu">:</span><span class="dv">2</span><span class="fu">:</span>[<span class="dv">4</span>,<span class="dv">5</span>]</a>
<a class="sourceLine" id="cb58-6" data-line-number="6">[<span class="dv">1</span>,<span class="dv">2</span>,<span class="dv">4</span>,<span class="dv">5</span>]</a></code></pre></div>
<p>This is very important because it’s actually how lists are implemented internally. When you type <code>[10, 20, 30]</code>, Haskell actually sees that as <code>10:20:30:[]</code>.</p></li>
<li><p><code>take x xs</code> gives you the first <code>x</code> values from the List <code>xs</code>.</p>
<div class="sourceCode" id="cb59"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb59-1" data-line-number="1"><span class="dt">Prelude</span><span class="fu">&gt;</span> take <span class="dv">5</span> [<span class="dv">1</span>,<span class="dv">2</span>,<span class="dv">3</span>,<span class="dv">4</span>,<span class="dv">5</span>,<span class="dv">6</span>]</a>
<a class="sourceLine" id="cb59-2" data-line-number="2">[<span class="dv">1</span>,<span class="dv">2</span>,<span class="dv">3</span>,<span class="dv">4</span>,<span class="dv">5</span>]</a></code></pre></div></li>
<li><p><code>drop x xs</code> drops the first <code>x</code> values from the List <code>xs</code>.</p>
<div class="sourceCode" id="cb60"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb60-1" data-line-number="1"><span class="dt">Prelude</span><span class="fu">&gt;</span> drop <span class="dv">3</span> [<span class="dv">1</span>,<span class="dv">2</span>,<span class="dv">3</span>,<span class="dv">4</span>,<span class="dv">5</span>,<span class="dv">6</span>]</a>
<a class="sourceLine" id="cb60-2" data-line-number="2">[<span class="dv">4</span>,<span class="dv">5</span>,<span class="dv">6</span>]</a></code></pre></div></li>
<li><p><code>head xs</code> gives you the first value of the List <code>xs</code>.</p>
<div class="sourceCode" id="cb61"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb61-1" data-line-number="1"><span class="dt">Prelude</span><span class="fu">&gt;</span> head [<span class="dv">1</span>,<span class="dv">2</span>,<span class="dv">3</span>,<span class="dv">4</span>,<span class="dv">5</span>,<span class="dv">6</span>]</a>
<a class="sourceLine" id="cb61-2" data-line-number="2"><span class="dv">1</span></a></code></pre></div></li>
<li><p><code>last xs</code> gives you the last value of the List <code>xs</code></p>
<div class="sourceCode" id="cb62"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb62-1" data-line-number="1"><span class="dt">Prelude</span><span class="fu">&gt;</span> last [<span class="dv">1</span>,<span class="dv">2</span>,<span class="dv">3</span>,<span class="dv">4</span>,<span class="dv">5</span>,<span class="dv">6</span>]</a>
<a class="sourceLine" id="cb62-2" data-line-number="2"><span class="dv">6</span></a></code></pre></div></li>
<li><p><code>init xs</code> gives you all but the last value of the List <code>xs</code>.</p>
<div class="sourceCode" id="cb63"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb63-1" data-line-number="1"><span class="dt">Prelude</span><span class="fu">&gt;</span> tail [<span class="dv">1</span>,<span class="dv">2</span>,<span class="dv">3</span>,<span class="dv">4</span>,<span class="dv">5</span>,<span class="dv">6</span>]</a>
<a class="sourceLine" id="cb63-2" data-line-number="2">[<span class="dv">1</span>,<span class="dv">2</span>,<span class="dv">3</span>,<span class="dv">4</span>,<span class="dv">5</span>]</a></code></pre></div></li>
<li><p><code>tail xs</code> gives you all but the first value of the List <code>xs</code>.</p>
<div class="sourceCode" id="cb64"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb64-1" data-line-number="1"><span class="dt">Prelude</span><span class="fu">&gt;</span> tail [<span class="dv">1</span>,<span class="dv">2</span>,<span class="dv">3</span>,<span class="dv">4</span>,<span class="dv">5</span>,<span class="dv">6</span>]</a>
<a class="sourceLine" id="cb64-2" data-line-number="2">[<span class="dv">2</span>,<span class="dv">3</span>,<span class="dv">4</span>,<span class="dv">5</span>,<span class="dv">6</span>]</a></code></pre></div></li>
<li><p><code>xs !! x</code> returns the <code>x</code>th item of the List <code>xs</code>. You may also see <code>`elem`</code> which is equivalent.</p>
<div class="sourceCode" id="cb65"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb65-1" data-line-number="1"><span class="dt">Prelude</span><span class="fu">&gt;</span> xs <span class="fu">=</span> <span class="st">&quot;Ice, ice, baby&quot;</span></a>
<a class="sourceLine" id="cb65-2" data-line-number="2"><span class="dt">Prelude</span><span class="fu">&gt;</span> xs <span class="fu">!!</span> <span class="dv">0</span></a>
<a class="sourceLine" id="cb65-3" data-line-number="3"><span class="ch">&#39;I&#39;</span></a>
<a class="sourceLine" id="cb65-4" data-line-number="4"><span class="dt">Prelude</span><span class="fu">&gt;</span> xs <span class="fu">!!</span> <span class="dv">11</span></a>
<a class="sourceLine" id="cb65-5" data-line-number="5"><span class="ch">&#39;a&#39;</span></a></code></pre></div></li>
<li><p><code>length xs</code> returns the length of the List <code>xs</code>.</p>
<div class="sourceCode" id="cb66"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb66-1" data-line-number="1"><span class="dt">Prelude</span><span class="fu">&gt;</span> length <span class="st">&quot;Ice, ice, baby&quot;</span></a>
<a class="sourceLine" id="cb66-2" data-line-number="2"><span class="dv">14</span></a></code></pre></div></li>
<li><p><code>null xs</code> returns whether the List is empty. It is better to use this than <code>xs == []</code>, but it does the same thing.</p>
<div class="sourceCode" id="cb67"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb67-1" data-line-number="1"><span class="dt">Prelude</span><span class="fu">&gt;</span> null <span class="st">&quot;Ice, ice, baby&quot;</span></a>
<a class="sourceLine" id="cb67-2" data-line-number="2"><span class="dt">False</span></a>
<a class="sourceLine" id="cb67-3" data-line-number="3"><span class="dt">Prelude</span><span class="fu">&gt;</span> null []  </a>
<a class="sourceLine" id="cb67-4" data-line-number="4"><span class="dt">True</span>  </a></code></pre></div></li>
<li><p><code>sum xs</code> takes a List of numbers <code>xs</code> and returns their sum.</p>
<div class="sourceCode" id="cb68"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb68-1" data-line-number="1"><span class="dt">Prelude</span><span class="fu">&gt;</span> sum [<span class="dv">1</span>,<span class="dv">2</span>,<span class="dv">5</span>]</a>
<a class="sourceLine" id="cb68-2" data-line-number="2"><span class="dv">8</span></a></code></pre></div></li>
<li><p><code>product xs</code> takes a List of numbers <code>xs</code> and returns their product.</p>
<div class="sourceCode" id="cb69"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb69-1" data-line-number="1"><span class="dt">Prelude</span><span class="fu">&gt;</span> product [<span class="dv">1</span>,<span class="dv">2</span>,<span class="dv">5</span>]</a>
<a class="sourceLine" id="cb69-2" data-line-number="2"><span class="dv">10</span></a></code></pre></div></li>
<li><p><code>maximum xs</code> and <code>minimum xs</code> do what you would expect, they take a List of values in the typeclass <code>Ord</code> and find the maximum or minimum one, respectively.</p></li>
</ol>
<h2 id="enumerations-and-infinite-lists">Enumerations and Infinite Lists</h2>
<p><span class="newthought">Haskell provides</span> some easy ways to get a range of numbers, or other things that can be enumerated, using the <code>..</code> syntax.</p>
<div class="sourceCode" id="cb70"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb70-1" data-line-number="1"><span class="co">-- Get the numbers between 1 and 10 inclusive.</span></a>
<a class="sourceLine" id="cb70-2" data-line-number="2"><span class="dt">Prelude</span><span class="fu">&gt;</span> [<span class="dv">1</span><span class="fu">..</span><span class="dv">10</span>]</a>
<a class="sourceLine" id="cb70-3" data-line-number="3">[<span class="dv">1</span>,<span class="dv">2</span>,<span class="dv">3</span>,<span class="dv">4</span>,<span class="dv">5</span>,<span class="dv">6</span>,<span class="dv">7</span>,<span class="dv">8</span>,<span class="dv">9</span>,<span class="dv">10</span>]</a>
<a class="sourceLine" id="cb70-4" data-line-number="4"></a>
<a class="sourceLine" id="cb70-5" data-line-number="5"><span class="co">-- Get the letters between &#39;a&#39; and &#39;r&#39; inclusive.</span></a>
<a class="sourceLine" id="cb70-6" data-line-number="6"><span class="dt">Prelude</span><span class="fu">&gt;</span> [<span class="ch">&#39;a&#39;</span><span class="fu">..</span><span class="ch">&#39;r&#39;</span>]</a>
<a class="sourceLine" id="cb70-7" data-line-number="7"><span class="st">&quot;abcdefghijklmnopqr&quot;</span></a>
<a class="sourceLine" id="cb70-8" data-line-number="8"></a>
<a class="sourceLine" id="cb70-9" data-line-number="9"><span class="co">-- Get the numbers between 1 and 10, with a step of 2.</span></a>
<a class="sourceLine" id="cb70-10" data-line-number="10"><span class="dt">Prelude</span><span class="fu">&gt;</span> [<span class="dv">1</span>,<span class="dv">3</span><span class="fu">..</span><span class="dv">10</span>]</a>
<a class="sourceLine" id="cb70-11" data-line-number="11">[<span class="dv">1</span>,<span class="dv">3</span>,<span class="dv">5</span>,<span class="dv">7</span>,<span class="dv">9</span>]</a>
<a class="sourceLine" id="cb70-12" data-line-number="12"></a>
<a class="sourceLine" id="cb70-13" data-line-number="13"><span class="co">-- The step is mandatory if you want to go downwards.</span></a>
<a class="sourceLine" id="cb70-14" data-line-number="14"><span class="dt">Prelude</span><span class="fu">&gt;</span> [<span class="dv">10</span>,<span class="dv">9</span><span class="fu">..</span><span class="dv">1</span>]</a>
<a class="sourceLine" id="cb70-15" data-line-number="15">[<span class="dv">10</span>,<span class="dv">9</span>,<span class="dv">8</span>,<span class="dv">7</span>,<span class="dv">6</span>,<span class="dv">5</span>,<span class="dv">4</span>,<span class="dv">3</span>,<span class="dv">2</span>,<span class="dv">1</span>]</a></code></pre></div>
<p>You don’t have to provide an upper limit to your List, either!</p>
<div class="sourceCode" id="cb71"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb71-1" data-line-number="1"><span class="co">-- This makes a List containing [1,2,3,4,5,...] all the way up to infinity.</span></a>
<a class="sourceLine" id="cb71-2" data-line-number="2"><span class="dt">Prelude</span><span class="fu">&gt;</span> [<span class="dv">1</span><span class="fu">..</span>]</a>
<a class="sourceLine" id="cb71-3" data-line-number="3"><span class="co">-- If you type this in GHCi, it will keep showing numbers until you hit ctrl+c, which is how you tell a Haskell command to stop running.</span></a>
<a class="sourceLine" id="cb71-4" data-line-number="4"></a>
<a class="sourceLine" id="cb71-5" data-line-number="5"><span class="co">-- This makes a List containing [0,10,20,30,...] all the way up to infinity.</span></a>
<a class="sourceLine" id="cb71-6" data-line-number="6"><span class="dt">Prelude</span><span class="fu">&gt;</span> [<span class="dv">0</span>,<span class="dv">10</span><span class="fu">..</span>]</a>
<a class="sourceLine" id="cb71-7" data-line-number="7"><span class="co">-- Again, have your control-c key ready.</span></a>
<a class="sourceLine" id="cb71-8" data-line-number="8"></a>
<a class="sourceLine" id="cb71-9" data-line-number="9"><span class="co">-- To do anything useful with infinite lists, you usually need to limit which ones you get.</span></a>
<a class="sourceLine" id="cb71-10" data-line-number="10"><span class="dt">Prelude</span><span class="fu">&gt;</span> take <span class="dv">10</span> [<span class="dv">10</span>,<span class="dv">20</span><span class="fu">..</span>]</a>
<a class="sourceLine" id="cb71-11" data-line-number="11">[<span class="dv">10</span>,<span class="dv">20</span>,<span class="dv">30</span>,<span class="dv">40</span>,<span class="dv">50</span>,<span class="dv">60</span>,<span class="dv">70</span>,<span class="dv">80</span>,<span class="dv">90</span>,<span class="dv">100</span>]</a></code></pre></div>
<p><span class="newthought">Infinite lists</span> work because Haskell is <em>lazy</em> - it won’t compute anything until it absolutely has to<label for="sidenote-13" class="margin-toggle sidenote-number"></label> <input type="checkbox" id="sidenote-13" class="margin-toggle"/> <span class="sidenote">which is typically when it needs to be displayed on the screen, written to a file, or something similar.</span>. If you do something that forces Haskell to evaluate the whole list, it will never finish, as the list is infinite. Be sure to do something like <code>take 10</code> on the list before you try and print it, so you don’t get stuck doing stuff forever.</p>
<h2 id="list-comprehensions">List Comprehensions</h2>
<p><span class="newthought">If you’ve</span> used List comprehensions in Python, these should be pretty familiar. They’re ways to turn one List into a new List - by filtering it and transforming the values.</p>
<div class="sourceCode" id="cb72"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb72-1" data-line-number="1"><span class="dt">Prelude</span><span class="fu">&gt;</span> xs <span class="fu">=</span> [<span class="dv">1</span><span class="fu">..</span><span class="dv">5</span>]</a>
<a class="sourceLine" id="cb72-2" data-line-number="2"><span class="dt">Prelude</span><span class="fu">&gt;</span> xs</a>
<a class="sourceLine" id="cb72-3" data-line-number="3">[<span class="dv">1</span>,<span class="dv">2</span>,<span class="dv">3</span>,<span class="dv">4</span>,<span class="dv">5</span>]</a>
<a class="sourceLine" id="cb72-4" data-line-number="4"></a>
<a class="sourceLine" id="cb72-5" data-line-number="5"><span class="co">-- Here is a List comprehension that takes all the values in xs and does nothing with them.</span></a>
<a class="sourceLine" id="cb72-6" data-line-number="6"><span class="dt">Prelude</span><span class="fu">&gt;</span> [x <span class="fu">|</span> x <span class="ot">&lt;-</span> xs]</a>
<a class="sourceLine" id="cb72-7" data-line-number="7">[<span class="dv">1</span>,<span class="dv">2</span>,<span class="dv">3</span>,<span class="dv">4</span>,<span class="dv">5</span>]</a>
<a class="sourceLine" id="cb72-8" data-line-number="8"></a>
<a class="sourceLine" id="cb72-9" data-line-number="9"><span class="co">-- Here is a List comprehension that doubles all the values in xs.</span></a>
<a class="sourceLine" id="cb72-10" data-line-number="10"><span class="dt">Prelude</span><span class="fu">&gt;</span> [x <span class="fu">*</span> <span class="dv">2</span> <span class="fu">|</span> x <span class="ot">&lt;-</span> xs]</a>
<a class="sourceLine" id="cb72-11" data-line-number="11">[<span class="dv">2</span>,<span class="dv">4</span>,<span class="dv">6</span>,<span class="dv">8</span>,<span class="dv">10</span>]</a>
<a class="sourceLine" id="cb72-12" data-line-number="12"></a>
<a class="sourceLine" id="cb72-13" data-line-number="13"><span class="co">-- Here is a List comprehension that squares all values in xs, and keeps the result if the value is higher than 10.</span></a>
<a class="sourceLine" id="cb72-14" data-line-number="14"><span class="dt">Prelude</span><span class="fu">&gt;</span> [x <span class="fu">^</span> <span class="dv">2</span> <span class="fu">|</span> x <span class="ot">&lt;-</span> xs, (x <span class="fu">^</span> <span class="dv">2</span>) <span class="fu">&gt;</span> <span class="dv">10</span>]</a>
<a class="sourceLine" id="cb72-15" data-line-number="15">[<span class="dv">16</span>,<span class="dv">25</span>]</a></code></pre></div>
<p>Let me break down the structure of a List comprehension:</p>
<div class="sourceCode" id="cb73"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb73-1" data-line-number="1">    [x <span class="fu">^</span> <span class="dv">2</span> <span class="fu">|</span> x <span class="ot">&lt;-</span> xs, (x <span class="fu">^</span> <span class="dv">2</span>) <span class="fu">&gt;</span> <span class="dv">10</span>]</a>
<a class="sourceLine" id="cb73-2" data-line-number="2"><span class="co">--   =====   =======  ===========</span></a>
<a class="sourceLine" id="cb73-3" data-line-number="3"><span class="co">--    [1]      [2]        [3]</span></a></code></pre></div>
<ol type="1">
<li><p><code>x ^ 2</code>: This is the value that will appear in the final List. <code>x</code> is a variable that comes from [2]. This part is used to transform the contents of the List.</p></li>
<li><p><code>x &lt;- xs</code>: This can be translated as “iterate over the values in the List <code>xs</code> and assign them to <code>x</code>”. It’s used to decide which List you want to draw from.</p></li>
<li><p><code>x * x &gt; 10</code>: This is a condition<label for="marginnote-23" class="margin-toggle">⊕</label> <input type="checkbox" id="marginnote-23" class="margin-toggle"/> <span class="marginnote">You can also have multiple conditions here, separated by commas.</span> that determines whether the result of [1] will be included in the List. This is used to filter the contents of a List.</p></li>
</ol>
<p>In Python, this would be written as <code>[x*x for x in xs if (x * x) &gt; 10]</code><label for="marginnote-24" class="margin-toggle">⊕</label> <input type="checkbox" id="marginnote-24" class="margin-toggle"/> <span class="marginnote">When reading list comprehensions out, I tend to mentally convert it to the Python style, which was actually inspired by Haskell!</span>.</p>
<h2 id="tuples">Tuples</h2>
<p><span class="newthought">let’s say</span> you wanted to have a List of points, where a point is an <code>x</code> and a <code>y</code> coordinate. You could have a List of Lists, like this:</p>
<div class="sourceCode" id="cb74"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb74-1" data-line-number="1"><span class="dt">Prelude</span><span class="fu">&gt;</span> points <span class="fu">=</span> [[(<span class="dv">0</span><span class="ot"> ::</span> <span class="dt">Double</span>), <span class="dv">1</span>], [<span class="fu">-</span><span class="dv">2</span>, <span class="dv">4</span>], [<span class="dv">5</span>, <span class="dv">2</span>]]</a>
<a class="sourceLine" id="cb74-2" data-line-number="2"><span class="dt">Prelude</span><span class="fu">&gt;</span> <span class="fu">:</span><span class="kw">type</span> points</a>
<a class="sourceLine" id="cb74-3" data-line-number="3"><span class="ot">points ::</span> [[<span class="dt">Double</span>]]</a></code></pre></div>
<p>But there’s an issue here. If you accidentally forgot a coordinate in your point, that’s certainly an error, and Haskell wouldn’t warn you<label for="marginnote-25" class="margin-toggle">⊕</label> <input type="checkbox" id="marginnote-25" class="margin-toggle"/> <span class="marginnote">An important philosophy in Haskell is that it should be as hard as possible for you to make an error that the compiler doesn’t warn you about. We do that by structuring our program so incorrect states (such as points with only one coordinate) are forbidden by the type system. The more you do this, the more bug-free your code will be.</span>!</p>
<p>So a better solution is to use tuples. You make a tuple the same way you make a List, but you use <code>()</code> parentheses instead of <code>[]</code> square brackets.</p>
<div class="sourceCode" id="cb75"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb75-1" data-line-number="1"><span class="dt">Prelude</span><span class="fu">&gt;</span> points <span class="fu">=</span> [((<span class="dv">0</span><span class="ot"> ::</span> <span class="dt">Double</span>), (<span class="dv">1</span><span class="ot"> ::</span> <span class="dt">Double</span>)), (<span class="fu">-</span><span class="dv">2</span>, <span class="dv">4</span>), (<span class="dv">5</span>, <span class="dv">2</span>)]</a>
<a class="sourceLine" id="cb75-2" data-line-number="2"><span class="dt">Prelude</span><span class="fu">&gt;</span> <span class="fu">:</span><span class="kw">type</span> points</a>
<a class="sourceLine" id="cb75-3" data-line-number="3"><span class="ot">points ::</span> [(<span class="dt">Double</span>, <span class="dt">Double</span>)]</a></code></pre></div>
<p>You’ll notice the type signature changed! Tuples are different from lists. They don’t have to be homogenous (you can have multiple different types in the same tuple), so their type is the type of each of their elements. A tuple containing two doubles will have the type <code>(Double, Double)</code>.<label for="marginnote-26" class="margin-toggle">⊕</label> <input type="checkbox" id="marginnote-26" class="margin-toggle"/> <span class="marginnote">The order is important. If the tuple’s type is <code>(String, Bool)</code> you can’t assign <code>(True, &quot;Hello&quot;)</code> to it.</span></p>
<p><span class="newthought">A tuple</span> with 2 items is called a 2-tuple, a tuple with 3 items is called a 3-tuple, etc. 2-tuples and 3-tuples are also called doubles and triples, respectively.<label for="marginnote-27" class="margin-toggle">⊕</label> <input type="checkbox" id="marginnote-27" class="margin-toggle"/> <span class="marginnote">You can have a tuple with 1 or 0 items, but there wouldn’t be much point.</span></p>
<p><span class="newthought">If you</span> have a 2-tuple, you can extract values from it using the <code>fst</code> and <code>snd</code> functions<label for="marginnote-28" class="margin-toggle">⊕</label> <input type="checkbox" id="marginnote-28" class="margin-toggle"/> <span class="marginnote">Their type signatures are <code>fst :: (a, b) -&gt; a</code> and <code>snd :: (a, b) -&gt; b</code> respectively.</span>. For example, <code>fst (1, 2) == 1</code> and <code>snd (1, 2) == 2</code>. Tuples are useful when you want to have a function that returns multiple values. For example, you could imagine a person’s name being represented as a 2-tuple, where the first element is their given name and the second item is their family name. Here’s a function that will tell you the full name of a child, given their first name and their parent’s full name<label for="sidenote-14" class="margin-toggle sidenote-number"></label> <input type="checkbox" id="sidenote-14" class="margin-toggle"/> <span class="sidenote">Of course, don’t use this in production, as not everyone has a name that fits this schema.</span>.</p>
<div class="sourceCode" id="cb76"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb76-1" data-line-number="1"><span class="dt">Prelude</span><span class="fu">&gt;</span> myName <span class="fu">=</span> (<span class="st">&quot;Jane&quot;</span>, <span class="st">&quot;Doe&quot;</span>)</a>
<a class="sourceLine" id="cb76-2" data-line-number="2"><span class="dt">Prelude</span><span class="fu">&gt;</span> child&#39;sName parentsName child&#39;sFirstName <span class="fu">=</span> (child&#39;sFirstName, snd parentsName)</a>
<a class="sourceLine" id="cb76-3" data-line-number="3"><span class="dt">Prelude</span><span class="fu">&gt;</span> child&#39;sName myName <span class="st">&quot;Claire&quot;</span></a>
<a class="sourceLine" id="cb76-4" data-line-number="4">(<span class="st">&quot;Claire&quot;</span>,<span class="st">&quot;Doe&quot;</span>)</a></code></pre></div>
<hr />
<p><strong><strong><em>Exercises</em></strong></strong>:</p>
<ol type="1">
<li><p>Sometimes you can guess what a function does just by looking at its type signature. Here’s the type signature for the <code>zip</code> function:</p>
<div class="sourceCode" id="cb77"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb77-1" data-line-number="1">zip<span class="ot"> ::</span> [a] <span class="ot">-&gt;</span> [b] <span class="ot">-&gt;</span> [(a, b)]</a></code></pre></div>
<p>Can you guess what it does? For a hint, try running <code>zip [1,2,3] &quot;abc&quot;</code>.</p></li>
<li><p>I wrote:</p>
<div class="sourceCode" id="cb78"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb78-1" data-line-number="1">points <span class="fu">=</span> [((<span class="dv">0</span><span class="ot"> ::</span> <span class="dt">Double</span>), (<span class="dv">1</span><span class="ot"> ::</span> <span class="dt">Double</span>)), (<span class="fu">-</span><span class="dv">2</span>, <span class="dv">4</span>), (<span class="dv">5</span>, <span class="dv">2</span>)]</a></code></pre></div>
<p>And the type signature of <code>points</code> was <code>points :: [(Double, Double)]</code>. What would it have been if I typed simply typed <code>points = [(0, 1), (-2, 4), (5, 2)]</code> instead? Check your answer with <code>:type points</code>.</p></li>
</ol>
<hr />
<h1 id="more-about-functions---useful-syntax">More About Functions - Useful Syntax</h1>
<h2 id="pattern-matching">Pattern matching</h2>
<p><span class="newthought">You’ll notice</span> I haven’t told you how to do if/then/else in Haskell. There is a way, but when possible, it’s preferred that you use <em>pattern matching</em><label for="marginnote-29" class="margin-toggle">⊕</label> <input type="checkbox" id="marginnote-29" class="margin-toggle"/> <span class="marginnote">Pattern matching (and <code>case</code>, discussed below), were created to make it easier to write programs that work well with the type system. If/then/else is useful occasionally, but really struggles with certain Haskell features such as <code>Maybe</code>, which we’ll discuss later. Also, pattern matching looks nicer.</span>. I’ll steal an example from the excellent <a href="http://learnyouahaskell.com/syntax-in-functions">Learn You A Haskell</a>:</p>
<div class="sourceCode" id="cb79"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb79-1" data-line-number="1"><span class="co">-- luckyNumber7.hs</span></a>
<a class="sourceLine" id="cb79-2" data-line-number="2"><span class="ot">lucky ::</span> (<span class="dt">Integral</span> a) <span class="ot">=&gt;</span> a <span class="ot">-&gt;</span> <span class="dt">String</span>  </a>
<a class="sourceLine" id="cb79-3" data-line-number="3">lucky <span class="dv">7</span> <span class="fu">=</span> <span class="st">&quot;LUCKY NUMBER SEVEN!&quot;</span>  </a>
<a class="sourceLine" id="cb79-4" data-line-number="4">lucky x <span class="fu">=</span> <span class="st">&quot;Sorry, you&#39;re out of luck, pal!&quot;</span>   </a></code></pre></div>
<p>You’ll notice that, if you type a number other than 7, we don’t really care what it is. We just tell you that you’re unlucky. If you don’t care about a certain value, it’s a Haskell tradition to assign it to the variable <code>_</code><label for="sidenote-15" class="margin-toggle sidenote-number"></label> <input type="checkbox" id="sidenote-15" class="margin-toggle"/> <span class="sidenote">Specifically, GHC won’t warn you about unused variables if the unused variable begins with a <code>_</code></span>.</p>
<div class="sourceCode" id="cb80"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb80-1" data-line-number="1"><span class="co">-- luckyNumber7u.hs</span></a>
<a class="sourceLine" id="cb80-2" data-line-number="2"><span class="ot">lucky ::</span> (<span class="dt">Integral</span> a) <span class="ot">=&gt;</span> a <span class="ot">-&gt;</span> <span class="dt">String</span>  </a>
<a class="sourceLine" id="cb80-3" data-line-number="3">lucky <span class="dv">7</span> <span class="fu">=</span> <span class="st">&quot;LUCKY NUMBER SEVEN!&quot;</span>  </a>
<a class="sourceLine" id="cb80-4" data-line-number="4">lucky _ <span class="fu">=</span> <span class="st">&quot;Sorry, you&#39;re out of luck, pal!&quot;</span>   </a></code></pre></div>
<p>This makes implementing recursive functions (functions which call themselves) very easy. Factorial is the usual example:</p>
<div class="sourceCode" id="cb81"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb81-1" data-line-number="1"><span class="co">-- factorial.hs</span></a>
<a class="sourceLine" id="cb81-2" data-line-number="2"><span class="ot">factorial ::</span> (<span class="dt">Integral</span> a) <span class="ot">=&gt;</span> a <span class="ot">-&gt;</span> a  </a>
<a class="sourceLine" id="cb81-3" data-line-number="3">factorial <span class="dv">0</span> <span class="fu">=</span> <span class="dv">1</span>  </a>
<a class="sourceLine" id="cb81-4" data-line-number="4">factorial n <span class="fu">=</span> n <span class="fu">*</span> factorial (n <span class="fu">-</span> <span class="dv">1</span>)  </a></code></pre></div>
<p>Can you see what’s going on here? I’ll explain it.</p>
<ol start="0" type="1">
<li><p>If you call <code>factorial 0</code>, it just returns <code>1</code>.</p></li>
<li><p>If you call <code>factorial 1</code>, it returns <code>1 * factorial (1 - 1)</code> which evaluates to <code>1 * factorial 0</code> which evaluates to <code>1 * 1</code> which evaluates to 1.</p></li>
<li><p>If you call <code>factorial 2</code>, it returns <code>2 * factorial (2 - 1)</code> which evaluates to <code>2 * factorial 1</code>. I just showed <code>factorial 1</code> evaluates to <code>1</code>, so <code>12 * factorial 1</code> evaluates to <code>2 * 1</code> which evaluates to <code>3</code>.</p></li>
</ol>
<p>If you have a pattern that would match any possible value, it is said your pattern is <em>exhaustive</em>. Otherwise, it’s <em>non-exhaustive</em>. Here is an exhaustive pattern:</p>
<div class="sourceCode" id="cb82"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb82-1" data-line-number="1"><span class="co">-- isTrue.hs</span></a>
<a class="sourceLine" id="cb82-2" data-line-number="2"><span class="ot">isTrue ::</span> <span class="dt">Bool</span> <span class="ot">-&gt;</span> <span class="dt">String</span></a>
<a class="sourceLine" id="cb82-3" data-line-number="3">isTrue <span class="dt">True</span> <span class="fu">=</span> <span class="st">&quot;Yep, it&#39;s true&quot;</span></a>
<a class="sourceLine" id="cb82-4" data-line-number="4">isTrue <span class="dt">False</span> <span class="fu">=</span> <span class="st">&quot;Say it ain&#39;t so&quot;</span></a></code></pre></div>
<p><code>Bool</code> can only be <code>True</code> or <code>False</code>, so all the bases are covered. However, this would be <em>non-exhaustive</em>:</p>
<div class="sourceCode" id="cb83"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb83-1" data-line-number="1"><span class="co">-- writtenNum.hs</span></a>
<a class="sourceLine" id="cb83-2" data-line-number="2"><span class="ot">writtenNum ::</span> <span class="dt">Integral</span> a <span class="ot">=&gt;</span> a <span class="ot">-&gt;</span> <span class="dt">String</span></a>
<a class="sourceLine" id="cb83-3" data-line-number="3">writtenNum <span class="dv">1</span> <span class="fu">=</span> <span class="st">&quot;One&quot;</span></a>
<a class="sourceLine" id="cb83-4" data-line-number="4">writtenNum <span class="dv">2</span> <span class="fu">=</span> <span class="st">&quot;Two&quot;</span></a>
<a class="sourceLine" id="cb83-5" data-line-number="5">writtenNum <span class="dv">3</span> <span class="fu">=</span> <span class="st">&quot;Three&quot;</span></a></code></pre></div>
<p>If you pass <code>4</code> to this function, your program will crash<label for="marginnote-30" class="margin-toggle">⊕</label> <input type="checkbox" id="marginnote-30" class="margin-toggle"/> <span class="marginnote">Later in this book I will discuss a setting in GHC you can turn on that will force all your patterns to be exhaustive, which I highly recommend turning on.</span>. A common trick to make patterns exhaustive is to put a catch-all at the bottom:</p>
<div class="sourceCode" id="cb84"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb84-1" data-line-number="1"><span class="ot">writtenNum ::</span> <span class="dt">Integral</span> a <span class="ot">=&gt;</span> a <span class="ot">-&gt;</span> <span class="dt">String</span></a>
<a class="sourceLine" id="cb84-2" data-line-number="2">writtenNum <span class="dv">1</span> <span class="fu">=</span> <span class="st">&quot;One&quot;</span></a>
<a class="sourceLine" id="cb84-3" data-line-number="3">writtenNum <span class="dv">2</span> <span class="fu">=</span> <span class="st">&quot;Two&quot;</span></a>
<a class="sourceLine" id="cb84-4" data-line-number="4">writtenNum <span class="dv">3</span> <span class="fu">=</span> <span class="st">&quot;Three&quot;</span></a>
<a class="sourceLine" id="cb84-5" data-line-number="5">writtenNum _ <span class="fu">=</span> <span class="st">&quot;unknown :(&quot;</span></a></code></pre></div>
<p>But beware that you don’t accidentally put the catch-all at the top! Patterns are checked top-to-bottom, so if you had a catch-all at the top, none of the other patterns could ever be hit.</p>
<p>You can use pattern matching in more interesting ways as well, because you can actually match the <em>inside</em> of certain values, such as tuples. Remember the <code>fst</code> and <code>snd</code> functions from the last chapter? They only apply to 2-tuples. Let’s try making some that work with 3-tuples.</p>
<div class="sourceCode" id="cb85"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb85-1" data-line-number="1"><span class="co">-- tuplePatterns.hs</span></a>
<a class="sourceLine" id="cb85-2" data-line-number="2"><span class="ot">unost ::</span> (a, b, c) <span class="ot">-&gt;</span> a</a>
<a class="sourceLine" id="cb85-3" data-line-number="3">unost (a, _, _) <span class="fu">=</span> a</a>
<a class="sourceLine" id="cb85-4" data-line-number="4"></a>
<a class="sourceLine" id="cb85-5" data-line-number="5"><span class="ot">dost ::</span> (a, b, c) <span class="ot">-&gt;</span> b</a>
<a class="sourceLine" id="cb85-6" data-line-number="6">dost (_, b, _) <span class="fu">=</span> b</a>
<a class="sourceLine" id="cb85-7" data-line-number="7"></a>
<a class="sourceLine" id="cb85-8" data-line-number="8"><span class="ot">trest ::</span> (a, b, c) <span class="ot">-&gt;</span> c</a>
<a class="sourceLine" id="cb85-9" data-line-number="9">trest (_, _, c) <span class="fu">=</span> c</a></code></pre></div>
<p>It’s kind of a pain having to write these by hand. A later chapter will describe how to write them for all tuples, automatically.</p>
<p>The same idea works with lists. Let’s make a function that’s like <code>head</code>, but gives you the second value instead of the first.</p>
<div class="sourceCode" id="cb86"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb86-1" data-line-number="1"><span class="co">-- neck.hs</span></a>
<a class="sourceLine" id="cb86-2" data-line-number="2"><span class="ot">neck ::</span> [a] <span class="ot">-&gt;</span> a</a>
<a class="sourceLine" id="cb86-3" data-line-number="3">neck (_<span class="fu">:</span>x<span class="fu">:</span>_) <span class="fu">=</span> x     <span class="co">-- parentheses are necessary</span></a></code></pre></div>
<p>If you’re wondering what these weird <code>:</code> colons are doing, remember from the chapter on lists. The List you type as <code>[3]</code>, Haskell sees as <code>3:[]</code><label for="marginnote-31" class="margin-toggle">⊕</label> <input type="checkbox" id="marginnote-31" class="margin-toggle"/> <span class="marginnote"><code>[3]</code> gets converted to <code>3:[]</code> before any real work is done.</span>. The <code>String</code> (really, <code>[Char]</code>) you type as <code>&quot;abc&quot;</code>, Haskell sees as <code>'a':'b':'c':[]</code>. Try entering <code>'a':'b':'c':[]</code> into GHCi to prove it to yourself.</p>
<p>So <code>a:b:c</code> can match <code>1:2:[]</code> with <code>a = 1</code>, <code>b = 2</code>, <code>c = []</code>. It can also match <code>1:2:3:4:5:[]</code> with <code>a = 1</code>, <code>b = 2</code>, <code>c = [3,4,5]</code><label for="marginnote-32" class="margin-toggle">⊕</label> <input type="checkbox" id="marginnote-32" class="margin-toggle"/> <span class="marginnote">Note that, when pattern matching lists with <code>:</code>, the first items are single elements and the last item is a (sometimes empty) List.</span>. It will actually match any List with at least two items! This means this pattern is non-exhaustive, since it won’t work for any lists with less than two elements, but that’s okay for our purposes.</p>
<p>Lets use this newfound knowledge to write a <code>length'</code><label for="sidenote-16" class="margin-toggle sidenote-number"></label> <input type="checkbox" id="sidenote-16" class="margin-toggle"/> <span class="sidenote">The <code>'</code> apostrophe is an allowed character in Haskell variable and function names, typically pronounced “prime”.When making a copy of a function, it’s common to put a <code>'</code> at the end of it to differentiate it.</span> function that uses recursion and pattern matching:</p>
<pre><code>length&#39; :: (Num b) =&gt; [a] -&gt; b  
length&#39; [] = 0  
length&#39; (_:xs) = 1 + length&#39; xs  </code></pre>
<p>If these remind you of <code>case</code> statements in other languages, they should. Pattern matching in Haskell is really just syntax sugar<label for="sidenote-17" class="margin-toggle sidenote-number"></label> <input type="checkbox" id="sidenote-17" class="margin-toggle"/> <span class="sidenote">Syntax sugar is an addition to a language that is designed to make things easier to read or to express.</span> for <code>case</code> statements.</p>
<p>They tend to look like this:</p>
<div class="sourceCode" id="cb88"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb88-1" data-line-number="1"><span class="kw">case</span> expression <span class="kw">of</span> pattern <span class="ot">-&gt;</span> result  </a>
<a class="sourceLine" id="cb88-2" data-line-number="2">                   pattern <span class="ot">-&gt;</span> result  </a>
<a class="sourceLine" id="cb88-3" data-line-number="3">                   pattern <span class="ot">-&gt;</span> result  </a></code></pre></div>
<p>The <code>length'</code> function from earlier could be written with a case statement, like this:</p>
<div class="sourceCode" id="cb89"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb89-1" data-line-number="1"><span class="ot">length&#39;&#39; ::</span> (<span class="dt">Num</span> b) <span class="ot">=&gt;</span> [a] <span class="ot">-&gt;</span> b  </a>
<a class="sourceLine" id="cb89-2" data-line-number="2">length&#39;&#39; xs <span class="fu">=</span> <span class="kw">case</span> xs <span class="kw">of</span> []     <span class="ot">-&gt;</span> []   </a>
<a class="sourceLine" id="cb89-3" data-line-number="3">                        (_<span class="fu">:</span>xs) <span class="ot">-&gt;</span> <span class="dv">1</span><span class="fu">+</span> length&#39; xs  </a></code></pre></div>
<hr />
<p><strong><strong><em>Exercises</em></strong></strong>:</p>
<ol type="1">
<li><p>What do you think will happen if we called <code>factorial</code> with a negative number? Hint: try running it, but don’t hold your breath for an answer</p></li>
<li><p>What do you think will happen if you call our <code>neck [1]</code>? What do you think will happen if you call <code>head []</code>?</p></li>
<li><p>Write a function that gets the first value from a 4-tuple.</p></li>
</ol>
<hr />
<h2 id="ifthenelse">If/Then/Else</h2>
<p><span class="newthought">In Haskell</span>, if and else are expressions. They’re analogous to the ternary operator from other languages. If you have an <code>if</code>, you <em>have</em> to have an <code>else</code>. Here’s an example taken from the <a href="https://en.wikibooks.org/wiki/Haskell/Control_structures">Haskell Wikibook</a>:</p>
<div class="sourceCode" id="cb90"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb90-1" data-line-number="1"><span class="co">-- describeLetterIfElse.hs</span></a>
<a class="sourceLine" id="cb90-2" data-line-number="2"><span class="ot">describeLetter ::</span> <span class="dt">Char</span> <span class="ot">-&gt;</span> <span class="dt">String</span></a>
<a class="sourceLine" id="cb90-3" data-line-number="3">describeLetter c <span class="fu">=</span></a>
<a class="sourceLine" id="cb90-4" data-line-number="4">    <span class="kw">if</span> c <span class="fu">&gt;=</span> <span class="ch">&#39;a&#39;</span> <span class="fu">&amp;&amp;</span> c <span class="fu">&lt;=</span> <span class="ch">&#39;z&#39;</span></a>
<a class="sourceLine" id="cb90-5" data-line-number="5">        <span class="kw">then</span> <span class="st">&quot;Lower case&quot;</span></a>
<a class="sourceLine" id="cb90-6" data-line-number="6">        <span class="kw">else</span> <span class="kw">if</span> c <span class="fu">&gt;=</span> <span class="ch">&#39;A&#39;</span> <span class="fu">&amp;&amp;</span> c <span class="fu">&lt;=</span> <span class="ch">&#39;Z&#39;</span></a>
<a class="sourceLine" id="cb90-7" data-line-number="7">            <span class="kw">then</span> <span class="st">&quot;Upper case&quot;</span></a>
<a class="sourceLine" id="cb90-8" data-line-number="8">            <span class="kw">else</span> <span class="st">&quot;Not an ASCII letter&quot;</span></a></code></pre></div>
<p>The general structure of an if/then/else expression is:</p>
<div class="sourceCode" id="cb91"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb91-1" data-line-number="1"><span class="kw">if</span> [condition] <span class="kw">then</span> [value <span class="kw">if</span> condition is <span class="dt">True</span>] <span class="kw">else</span> [value <span class="kw">if</span> condition is <span class="dt">False</span>]</a></code></pre></div>
<p>I think these are pretty simple so I won’t spend too much time on them. Just be careful to have nice looking indentation as I do - it can lead to compile errors if you don’t<label for="sidenote-18" class="margin-toggle sidenote-number"></label> <input type="checkbox" id="sidenote-18" class="margin-toggle"/> <span class="sidenote">The general rule is, if you make a newline when writing an expression, the following code should be indented further than the beginning of that expression. See the <a href="https://en.wikibooks.org/wiki/Haskell/Indentation">Haskell Wikibook</a> for more details.</span>.</p>
<h2 id="guards">Guards</h2>
<p><span class="newthought">Guards are</span> like if/then/else, only more readable if you have a lot of branches. Here’s the above <code>describeLetter</code> function implemented with guards (notice that you <strong>don’t</strong> use a <code>=</code> sign to define a function if you’re using guards).</p>
<div class="sourceCode" id="cb92"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb92-1" data-line-number="1"><span class="ot">describeLetter ::</span> <span class="dt">Char</span> <span class="ot">-&gt;</span> <span class="dt">String</span></a>
<a class="sourceLine" id="cb92-2" data-line-number="2">describeLetter c</a>
<a class="sourceLine" id="cb92-3" data-line-number="3">   <span class="fu">|</span> c <span class="fu">&gt;=</span> <span class="ch">&#39;a&#39;</span> <span class="fu">&amp;&amp;</span> c <span class="fu">&lt;=</span> <span class="ch">&#39;z&#39;</span> <span class="fu">=</span> <span class="st">&quot;Lower case&quot;</span></a>
<a class="sourceLine" id="cb92-4" data-line-number="4">   <span class="fu">|</span> c <span class="fu">&gt;=</span> <span class="ch">&#39;A&#39;</span> <span class="fu">&amp;&amp;</span> c <span class="fu">&lt;=</span> <span class="ch">&#39;Z&#39;</span> <span class="fu">=</span> <span class="st">&quot;Upper case&quot;</span></a>
<a class="sourceLine" id="cb92-5" data-line-number="5">   <span class="fu">|</span> otherwise            <span class="fu">=</span> <span class="st">&quot;Not an ASCII letter&quot;</span></a></code></pre></div>
<p><code>otherwise</code> is a value that is equal to <code>True</code>, being used as a catch-all here. <code>True</code> could be used instead, but <code>otherwise</code> is more readable. Just like with patterns, guards are evaluated top to bottom, so don’t put the catch-all at the top. And be careful to line up your guards correctly, because it looks better but also because your code won’t compile if you don’t.</p>
<h2 id="let-expressions-and-where-statements">Let Expressions and Where Statements</h2>
<p><span class="newthought">When writing</span> a function, sometimes it’s nice to be able to assign names to intermediate values. There are two ways to do that in Haskell: <code>let</code> Expressions and <code>where</code> statements.</p>
<ol type="1">
<li><p><code>let</code> expressions<label for="sidenote-19" class="margin-toggle sidenote-number"></label> <input type="checkbox" id="sidenote-19" class="margin-toggle"/> <span class="sidenote">These are true expressions - you can use them anywhere Haskell expects an expression.</span> - these take the form of <code>let [variable bindings] in [expression]</code>. Here’s an example:</p>
<div class="sourceCode" id="cb93"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb93-1" data-line-number="1"><span class="co">-- computeEnergy.hs</span></a>
<a class="sourceLine" id="cb93-2" data-line-number="2"><span class="ot">energy ::</span> (<span class="dt">Num</span> a) <span class="ot">=&gt;</span> a <span class="ot">-&gt;</span> a</a>
<a class="sourceLine" id="cb93-3" data-line-number="3">energy mass <span class="fu">=</span> </a>
<a class="sourceLine" id="cb93-4" data-line-number="4">    <span class="kw">let</span> cSquared <span class="fu">=</span> <span class="dv">299792458</span><span class="fu">^</span><span class="dv">2</span></a>
<a class="sourceLine" id="cb93-5" data-line-number="5">    <span class="kw">in</span> mass <span class="fu">*</span> cSquared</a></code></pre></div>
<p>You can have multiple bindings in one <code>let</code> expression, and use bindings in the definition of other bindings.</p>
<div class="sourceCode" id="cb94"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb94-1" data-line-number="1"><span class="co">-- makeURL.hs</span></a>
<a class="sourceLine" id="cb94-2" data-line-number="2"><span class="ot">makeURL ::</span> <span class="dt">String</span> <span class="ot">-&gt;</span> <span class="dt">String</span> <span class="ot">-&gt;</span> <span class="dt">String</span></a>
<a class="sourceLine" id="cb94-3" data-line-number="3">makeURL domain path <span class="fu">=</span> </a>
<a class="sourceLine" id="cb94-4" data-line-number="4">    <span class="kw">let</span> full <span class="fu">=</span> protocol <span class="fu">++</span> <span class="st">&quot;://&quot;</span> <span class="fu">++</span> address</a>
<a class="sourceLine" id="cb94-5" data-line-number="5">        protocol <span class="fu">=</span> <span class="st">&quot;http&quot;</span></a>
<a class="sourceLine" id="cb94-6" data-line-number="6">        address <span class="fu">=</span> domain <span class="fu">++</span> <span class="st">&quot;/&quot;</span> <span class="fu">++</span> path</a>
<a class="sourceLine" id="cb94-7" data-line-number="7">    <span class="kw">in</span> full</a></code></pre></div>
<p>As you may have noticed, the order of the bindings doesn’t matter. Since these are expressions, you can use them anywhere, not just in functions.</p></li>
<li><p><code>where</code> statements - these aren’t expressions, they’re statements, and can only be used in functions<label for="sidenote-20" class="margin-toggle sidenote-number"></label> <input type="checkbox" id="sidenote-20" class="margin-toggle"/> <span class="sidenote">And a few other places, but functions are where you’ll see them most often</span>. They’re useful because they work perfectly with guards, where let expressions don’t really.</p>
<div class="sourceCode" id="cb95"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb95-1" data-line-number="1"><span class="co">-- benchPressJudger.hs</span></a>
<a class="sourceLine" id="cb95-2" data-line-number="2"><span class="ot">benchPressJudger ::</span> (<span class="dt">Ord</span> a, <span class="dt">Fractional</span> a) <span class="ot">=&gt;</span> a <span class="ot">-&gt;</span> <span class="dt">String</span>  </a>
<a class="sourceLine" id="cb95-3" data-line-number="3">benchPressJudger benchPressLbs </a>
<a class="sourceLine" id="cb95-4" data-line-number="4">    <span class="fu">|</span> benchPressKgs <span class="fu">&lt;=</span> weak <span class="fu">=</span> <span class="st">&quot;Stop programming and hit the gym!&quot;</span>  </a>
<a class="sourceLine" id="cb95-5" data-line-number="5">    <span class="fu">|</span> benchPressKgs <span class="fu">&lt;=</span> decent <span class="fu">=</span> <span class="st">&quot;This is decent, you&#39;re doing ok.&quot;</span>  </a>
<a class="sourceLine" id="cb95-6" data-line-number="6">    <span class="fu">|</span> benchPressLbs <span class="fu">&lt;=</span> strong    <span class="fu">=</span> <span class="st">&quot;Nice, you&#39;re getting pretty strong.&quot;</span>  </a>
<a class="sourceLine" id="cb95-7" data-line-number="7">    <span class="fu">|</span> otherwise     <span class="fu">=</span> <span class="st">&quot;Ok, get off the roids.&quot;</span>  </a>
<a class="sourceLine" id="cb95-8" data-line-number="8">    <span class="kw">where</span> benchPressKgs <span class="fu">=</span> benchPressLbs <span class="fu">*</span> <span class="fl">0.4535</span></a>
<a class="sourceLine" id="cb95-9" data-line-number="9">          weak <span class="fu">=</span> <span class="dv">67</span></a>
<a class="sourceLine" id="cb95-10" data-line-number="10">          decent <span class="fu">=</span> <span class="dv">125</span> </a>
<a class="sourceLine" id="cb95-11" data-line-number="11">          strong <span class="fu">=</span> <span class="dv">250</span></a></code></pre></div>
<p>You might notice something looks strange about our type signature - what’s that <code>(Ord a, Fractional a)</code>? It means whatever type <code>a</code> is has to be a member of <code>Ord</code> (so that we can see if it’s larger or smaller than stuff), <code>Num</code> so we can multiply it by stuff, and <code>Fractional</code> (so we can use it with fractional numbers when converting pounds into kilograms). Not all fractional numbers have to be orderable, that’s why we needed to have the <code>Ord</code> constraint as well<label for="sidenote-21" class="margin-toggle sidenote-number"></label> <input type="checkbox" id="sidenote-21" class="margin-toggle"/> <span class="sidenote">To avoid this in your own code, there are some specialized typeclasses such as <code>RealFloat</code>, but I don’t really recommend these because I think <code>(Ord a, Fractional a)</code> is perfectly readable.</span>.</p>
<p>Also, pattern matching works almost anywhere you see a <code>=</code> sign. So this would have worked, too, if we were very interested in terseness:</p>
<div class="sourceCode" id="cb96"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb96-1" data-line-number="1"><span class="kw">where</span> benchPressKgs <span class="fu">=</span> benchPressLbs <span class="fu">*</span> <span class="fl">0.4535</span></a>
<a class="sourceLine" id="cb96-2" data-line-number="2">      (weak, decent, strong) <span class="fu">=</span> (<span class="dv">67</span>, <span class="dv">125</span>, <span class="dv">250</span>)</a></code></pre></div></li>
</ol>
<h1 id="fixing-errors">Fixing Errors</h1>
<p><span class="newthought">You need</span> some practice reading compile errors because you’ll be doing it a lot. Luckily, the time you lose in fixing a battery of compile errors, you gain by removing many opportunities for runtime errors! Not all of these examples are fair because some are issues I haven’t told you about<label for="sidenote-22" class="margin-toggle sidenote-number"></label> <input type="checkbox" id="sidenote-22" class="margin-toggle"/> <span class="sidenote">Of course, since I won’t have taught you about all the issues you’re going to run into when writing real Haskell!</span>. That’s why you have to actually run them, to get good practice! The answers are at the bottom of the section</p>
<ol type="1">
<li><p>Run this in GHCi:</p>
<div class="sourceCode" id="cb97"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb97-1" data-line-number="1"><span class="dt">Prelude</span><span class="fu">&gt;</span> area x <span class="fu">=</span> <span class="fu">.</span><span class="dv">5</span> <span class="fu">*</span> <span class="fl">3.14</span> <span class="fu">*</span> x<span class="fu">^</span><span class="dv">2</span></a></code></pre></div>
<p>You should see something like:</p>
<div class="sourceCode" id="cb98"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb98-1" data-line-number="1"><span class="fu">&lt;</span>interactive<span class="fu">&gt;:</span><span class="dv">78</span><span class="fu">:</span><span class="dv">10</span><span class="fu">:</span> error<span class="fu">:</span> parse error on input <span class="ot">`.&#39;</span></a></code></pre></div>
<p>Where I have <code>78</code>, you’ll have a different number. That tells you the line number the error was on, but in GHCi, it tells you the number of lines you’ve entered before now. We can ignore that since it isn’t super useful. The number after the colon (in our case, <code>10</code>) is the column the error was on. This is useful because that should be fairly close to the source of the mistake. 10 letters into our command is the start of <code>.5</code>. Can you figure out the error?</p></li>
<li><p>Make a new file named <code>errorTest1.hs</code>. Inside it, write:</p>
<div class="sourceCode" id="cb99"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb99-1" data-line-number="1"><span class="co">-- errorTest1.hs</span></a>
<a class="sourceLine" id="cb99-2" data-line-number="2"><span class="ot">foo ::</span> (<span class="dt">Num</span> a) <span class="ot">=&gt;</span> a <span class="ot">-&gt;</span> a</a>
<a class="sourceLine" id="cb99-3" data-line-number="3">foo a <span class="fu">=</span> a <span class="fu">+</span> a</a>
<a class="sourceLine" id="cb99-4" data-line-number="4"></a>
<a class="sourceLine" id="cb99-5" data-line-number="5"><span class="ot"> bar ::</span> (<span class="dt">Num</span> a) <span class="ot">=&gt;</span> a <span class="ot">-&gt;</span> a</a>
<a class="sourceLine" id="cb99-6" data-line-number="6"> bar a <span class="fu">=</span> a <span class="fu">-</span> a</a></code></pre></div>
<p>Then try to load it into GHCi with <code>:load errorTest1.hs</code>. It should give you an error like the following:</p>
<div class="sourceCode" id="cb100"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb100-1" data-line-number="1">errorTest1<span class="fu">.</span>hs<span class="fu">:</span><span class="dv">5</span><span class="fu">:</span><span class="dv">6</span><span class="fu">:</span> error<span class="fu">:</span></a>
<a class="sourceLine" id="cb100-2" data-line-number="2">    parse error on input <span class="ot">`=&#39;</span></a>
<a class="sourceLine" id="cb100-3" data-line-number="3"><span class="ot">    Perhaps you need a &#39;let&#39; in a &#39;do&#39; block?</span></a>
<a class="sourceLine" id="cb100-4" data-line-number="4"><span class="ot">    e.g. &#39;let x = 5&#39; instead of &#39;x = 5&#39;</span></a>
<a class="sourceLine" id="cb100-5" data-line-number="5"><span class="ot">  |</span></a>
<a class="sourceLine" id="cb100-6" data-line-number="6"><span class="ot">5 |  bar = a - a</span></a>
<a class="sourceLine" id="cb100-7" data-line-number="7"><span class="ot">  |</span></a></code></pre></div>
<p>Can you spot the error? The error message isn’t very helpful here.</p></li>
<li><p>Now that you got that figured out, lets do one last one. Make a file called <code>errorTest2.hs</code>. Inside it, put:</p>
<div class="sourceCode" id="cb101"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb101-1" data-line-number="1"><span class="co">-- errorTest2.hs</span></a>
<a class="sourceLine" id="cb101-2" data-line-number="2"><span class="ot">foo ::</span> (<span class="dt">Num</span> a) <span class="ot">=&gt;</span> a <span class="ot">-&gt;</span> a</a>
<a class="sourceLine" id="cb101-3" data-line-number="3">foo <span class="fu">=</span> a <span class="fu">+</span> a</a>
<a class="sourceLine" id="cb101-4" data-line-number="4"></a>
<a class="sourceLine" id="cb101-5" data-line-number="5">bar <span class="fu">=</span> a <span class="fu">-</span> a</a></code></pre></div>
<p>Then go to GHCi and run <code>:load errorTest2.hs</code>. You should see a bunch of errors that say</p>
<div class="sourceCode" id="cb102"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb102-1" data-line-number="1">errorTest2<span class="fu">.</span>hs<span class="fu">:</span><span class="dv">2</span><span class="fu">:</span><span class="dv">7</span><span class="fu">:</span> error<span class="fu">:</span> <span class="dt">Variable</span> not <span class="kw">in</span> scope<span class="fu">:</span><span class="ot"> a ::</span> a <span class="ot">-&gt;</span> a</a></code></pre></div>
<p>Can you find the issue?</p></li>
<li><p>Just one more, this is probably one of the most common errors you’ll get. Try writing this:</p>
<div class="sourceCode" id="cb103"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb103-1" data-line-number="1"><span class="co">-- errorTest3.hs</span></a>
<a class="sourceLine" id="cb103-2" data-line-number="2"><span class="ot">isGreaterThan ::</span> (<span class="dt">Num</span> a) <span class="ot">=&gt;</span> a <span class="ot">-&gt;</span> a <span class="ot">-&gt;</span> <span class="dt">Bool</span></a>
<a class="sourceLine" id="cb103-3" data-line-number="3">isGreaterThan x y <span class="fu">=</span> x <span class="fu">&gt;</span> y</a></code></pre></div>
<p>You should see an error like:</p>
<div class="sourceCode" id="cb104"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb104-1" data-line-number="1">    <span class="fu">..</span>\error_examples\errorTest3<span class="fu">.</span>hs<span class="fu">:</span><span class="dv">2</span><span class="fu">:</span><span class="dv">21</span><span class="fu">:</span> error<span class="fu">:</span></a>
<a class="sourceLine" id="cb104-2" data-line-number="2">    <span class="fu">*</span> <span class="dt">Could</span> not deduce (<span class="dt">Ord</span> a) arising from a use <span class="kw">of</span> <span class="ot">`&gt;&#39;</span></a>
<a class="sourceLine" id="cb104-3" data-line-number="3"><span class="ot">    from the context: Num a</span></a>
<a class="sourceLine" id="cb104-4" data-line-number="4"><span class="ot">        bound by the type signature for:</span></a>
<a class="sourceLine" id="cb104-5" data-line-number="5"><span class="ot">                isGreaterThan :: forall a. Num a =&gt; a -&gt; a -&gt; Bool</span></a>
<a class="sourceLine" id="cb104-6" data-line-number="6"><span class="ot">        at ..\error_examples\errorTest3.hs:1:1-42</span></a>
<a class="sourceLine" id="cb104-7" data-line-number="7"><span class="ot">    Possible fix:</span></a>
<a class="sourceLine" id="cb104-8" data-line-number="8"><span class="ot">        add (Ord a) to the context of</span></a>
<a class="sourceLine" id="cb104-9" data-line-number="9"><span class="ot">        the type signature for:</span></a>
<a class="sourceLine" id="cb104-10" data-line-number="10"><span class="ot">            isGreaterThan :: forall a. Num a =&gt; a -&gt; a -&gt; Bool</span></a>
<a class="sourceLine" id="cb104-11" data-line-number="11"><span class="ot">    * In the expression: x &gt; y</span></a>
<a class="sourceLine" id="cb104-12" data-line-number="12"><span class="ot">    In an equation for `</span>isGreaterThan&#39;<span class="fu">:</span> isGreaterThan x y <span class="fu">=</span> x <span class="fu">&gt;</span> y</a>
<a class="sourceLine" id="cb104-13" data-line-number="13">  <span class="fu">|</span></a>
<a class="sourceLine" id="cb104-14" data-line-number="14"><span class="dv">2</span> <span class="fu">|</span> isGreaterThan x y <span class="fu">=</span> x <span class="fu">&gt;</span> y</a>
<a class="sourceLine" id="cb104-15" data-line-number="15">  <span class="fu">|</span>                     <span class="fu">^^^^^</span></a></code></pre></div>
<p>Hint: Make sure to read the error message carefully<label for="marginnote-33" class="margin-toggle">⊕</label> <input type="checkbox" id="marginnote-33" class="margin-toggle"/> <span class="marginnote">Which is good advice generally, but especially here.</span>.</p></li>
</ol>
<p>And remember, a good first step is always to just Google the error!</p>
<p>Answer 1: You can’t write a floating point number like <code>.5</code>, it needs to be <code>0.5</code>.</p>
<p>Answer 2: All declarations must start in the same column in Haskell. Having some of them being offset will make Haskell think you’re trying to do something strange. Remove the space in front of the two <code>bar</code>s.</p>
<p>Answer 3: We have <code>foo = a + a</code>, but we need to have <code>foo a = a + a</code>. Otherwise, Haskell has no idea where <code>a</code> is coming from. Same issue for <code>bar</code>.</p>
<p>Answer 4: Our only type constraint on our function is <code>Num a</code>, but we use <code>&gt;</code>, which is given to us by <code>Ord</code>, not <code>Num</code><label for="marginnote-34" class="margin-toggle">⊕</label> <input type="checkbox" id="marginnote-34" class="margin-toggle"/> <span class="marginnote">This commons source of confusion stems from the fact that not all numbers can be ordered, like complex numbers.</span>.</p>
<h1 id="problem-solving-practice">Problem Solving Practice</h1>
<p><span class="newthought">None of</span> these problems are particularly difficult, but they are very mathsy, which may not be your cup of tea. But this chapter will hone your Haskell skills - I recommend trying to solve the problems yourself! They’re all simple and well within your abilities, so I have decided to not provide the answers.</p>
<ol type="1">
<li><p>Add up all the natural numbers between 1 and 1000<label for="marginnote-35" class="margin-toggle">⊕</label> <input type="checkbox" id="marginnote-35" class="margin-toggle"/> <span class="marginnote">Natural numbers are just numbers used for counting, such as 1, 2, 3, etc.</span>, inclusive.</p>
<ol type="1">
<li><p>Hint! Reread the chapter on lists if you’re stuck, especially the chapter on enumerations.</p></li>
<li><p>The answer found by your program should be 500500</p></li>
</ol></li>
<li><p>Add up all the natural numbers that are divisible by 3 or 5, between 1 and 1000</p>
<ol type="1">
<li><p>List comprehensions will come in useful here.</p></li>
<li><p>The answer found by your program should be <code>234168</code></p></li>
</ol></li>
<li><p>Write a function that takes a List of <code>Num</code>s, and tells you the difference between the sum of the squares and the square of the sums<label for="sidenote-23" class="margin-toggle sidenote-number"></label> <input type="checkbox" id="sidenote-23" class="margin-toggle"/> <span class="sidenote">If you’re wondering how to find the sum, Haskell includes a <code>sum</code> function for that exact purpose. Use List comprehensions to square all the numbers before you sum them, too.</span>.</p>
<ol type="1">
<li>For <code>[1,2,3,4,5]</code>, my program got <code>-170</code>. If yours gets <code>170</code> then you just put the terms in the opposite order I did, which is fine.</li>
</ol></li>
</ol>
<h1 id="functions-first-class">Functions First Class</h1>
<h2 id="currying">Currying</h2>
<p><span class="newthought">Functions in</span> Haskell are values like any other<label for="marginnote-36" class="margin-toggle">⊕</label> <input type="checkbox" id="marginnote-36" class="margin-toggle"/> <span class="marginnote">This is an important part of being a <em>function</em>al programming language.</span>, and can be passed around and all sorts of other things. Observe:</p>
<div class="sourceCode" id="cb105"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb105-1" data-line-number="1"><span class="dt">Prelude</span><span class="fu">&gt;</span> adder a <span class="fu">=</span> a <span class="fu">+</span> <span class="dv">1</span></a>
<a class="sourceLine" id="cb105-2" data-line-number="2"><span class="dt">Prelude</span><span class="fu">&gt;</span> adder <span class="dv">3</span></a>
<a class="sourceLine" id="cb105-3" data-line-number="3"><span class="dv">4</span></a>
<a class="sourceLine" id="cb105-4" data-line-number="4"><span class="dt">Prelude</span><span class="fu">&gt;</span> otherAdder <span class="fu">=</span> adder</a>
<a class="sourceLine" id="cb105-5" data-line-number="5"><span class="dt">Prelude</span><span class="fu">&gt;</span> otherAdder <span class="dv">3</span></a>
<a class="sourceLine" id="cb105-6" data-line-number="6"><span class="dv">4</span></a></code></pre></div>
<p>See? We’ve assigned the value of <code>adder</code> to <code>otherAdder</code>. We should take a look at the types here.</p>
<div class="sourceCode" id="cb106"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb106-1" data-line-number="1"><span class="dt">Prelude</span><span class="fu">&gt;</span> <span class="fu">:</span><span class="kw">type</span> adder</a>
<a class="sourceLine" id="cb106-2" data-line-number="2"><span class="ot">adder ::</span> <span class="dt">Num</span> a <span class="ot">=&gt;</span> a <span class="ot">-&gt;</span> a</a>
<a class="sourceLine" id="cb106-3" data-line-number="3"><span class="dt">Prelude</span><span class="fu">&gt;</span> <span class="fu">:</span><span class="kw">type</span> otherAdder</a>
<a class="sourceLine" id="cb106-4" data-line-number="4"><span class="ot">otherAdder ::</span> <span class="dt">Num</span> a <span class="ot">=&gt;</span> a <span class="ot">-&gt;</span> a</a></code></pre></div>
<p>Yep, exactly the same. <code>otherAdder</code> is now a function that’s exactly the same as <code>adder</code>.</p>
<p>That brings us to of one of the most famously complicated things in Haskell: Currying<label for="marginnote-37" class="margin-toggle">⊕</label> <input type="checkbox" id="marginnote-37" class="margin-toggle"/> <span class="marginnote">Haskell was actually named after the mathematician Haskell Curry.</span>. The general idea is that functions in Haskell always take either 1 or 0 arguments. When you write a function that seems to take multiple arguments, Haskell converts it to a function that takes one argument, then returns a new function which takes the next argument, etc. That probably seems horribly complicated, So let’s see an example. Do you recall the <code>take</code> function?</p>
<div class="sourceCode" id="cb107"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb107-1" data-line-number="1"><span class="dt">Prelude</span><span class="fu">&gt;</span> <span class="fu">:</span><span class="kw">type</span> take    </a>
<a class="sourceLine" id="cb107-2" data-line-number="2">take<span class="ot"> ::</span> <span class="dt">Int</span> <span class="ot">-&gt;</span> [a] <span class="ot">-&gt;</span> [a]</a>
<a class="sourceLine" id="cb107-3" data-line-number="3"><span class="dt">Prelude</span><span class="fu">&gt;</span> take <span class="dv">3</span> <span class="st">&quot;abcdefg&quot;</span></a>
<a class="sourceLine" id="cb107-4" data-line-number="4"><span class="st">&quot;abc&quot;</span></a></code></pre></div>
<p><code>take</code> is a function that takes two arguments. But if you only supply it with one argument, what you get is a <em>partially applied function</em><label for="sidenote-24" class="margin-toggle sidenote-number"></label> <input type="checkbox" id="sidenote-24" class="margin-toggle"/> <span class="sidenote">That’s what they’re called in other languages, but I think it’s an good name.</span>, which needs one more argument to complete.</p>
<div class="sourceCode" id="cb108"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb108-1" data-line-number="1"><span class="dt">Prelude</span><span class="fu">&gt;</span> <span class="fu">:</span>t take <span class="dv">3</span></a>
<a class="sourceLine" id="cb108-2" data-line-number="2">take <span class="dv">3</span><span class="ot"> ::</span> [a] <span class="ot">-&gt;</span> [a]</a></code></pre></div>
<p>Essentially, <code>take 3</code> returns a function that takes a list and returns the first 3 values of that list. We can use this function wherever we would write <code>take 3</code>. Here’s an example:</p>
<div class="sourceCode" id="cb109"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb109-1" data-line-number="1"><span class="dt">Prelude</span><span class="fu">&gt;</span> myTake3Function <span class="fu">=</span> take <span class="dv">3</span></a>
<a class="sourceLine" id="cb109-2" data-line-number="2"><span class="dt">Prelude</span><span class="fu">&gt;</span> myTake3Function <span class="st">&quot;abcdefg&quot;</span></a>
<a class="sourceLine" id="cb109-3" data-line-number="3"><span class="st">&quot;abc&quot;</span></a>
<a class="sourceLine" id="cb109-4" data-line-number="4"><span class="dt">Prelude</span><span class="fu">&gt;</span> <span class="fu">:</span><span class="kw">type</span> myTake3Function</a>
<a class="sourceLine" id="cb109-5" data-line-number="5"><span class="ot">myTake3Function ::</span> [a] <span class="ot">-&gt;</span> [a]</a>
<a class="sourceLine" id="cb109-6" data-line-number="6"><span class="dt">Prelude</span><span class="fu">&gt;</span> <span class="fu">:</span><span class="kw">type</span> (take <span class="dv">3</span>)</a>
<a class="sourceLine" id="cb109-7" data-line-number="7">take <span class="dv">3</span><span class="ot">          ::</span> [a] <span class="ot">-&gt;</span> [a]     <span class="co">-- I added some spaces for clarity.</span></a></code></pre></div>
<p>This also explains why function type signatures look odd. Remember the type signature for <code>take</code>.</p>
<div class="sourceCode" id="cb110"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb110-1" data-line-number="1">take<span class="ot"> ::</span> <span class="dt">Int</span> <span class="ot">-&gt;</span> [a] <span class="ot">-&gt;</span> [a] </a></code></pre></div>
<p>Well, that would be more clearly expressed like this:</p>
<div class="sourceCode" id="cb111"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb111-1" data-line-number="1">take<span class="ot"> ::</span> <span class="dt">Int</span> <span class="ot">-&gt;</span> ([a] <span class="ot">-&gt;</span> [a])</a></code></pre></div>
<p><code>take</code> is a function that takes an <code>Int</code>, and returns a function that takes a <code>[a]</code> and then extracts the first few values from it. When you write <code>take 3</code>, <em>you’re getting a new function that performs <code>take 3</code></em>. It’s really that simple!</p>
<div class="sourceCode" id="cb112"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb112-1" data-line-number="1"><span class="dt">Prelude</span><span class="fu">&gt;</span> <span class="fu">:</span><span class="kw">type</span> (take <span class="dv">3</span>)</a>
<a class="sourceLine" id="cb112-2" data-line-number="2">take <span class="dv">3</span><span class="ot"> ::</span> [a] <span class="ot">-&gt;</span> [a]</a></code></pre></div>
<p>You don’t have to think about this at all when writing functions, this is something Haskell gives you for free. This may seem confusing now, but will become more clear when you see more examples. Remember <code>concatWithSpace</code> from a few chapters ago?</p>
<div class="sourceCode" id="cb113"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb113-1" data-line-number="1"><span class="dt">Prelude</span><span class="fu">&gt;</span> concatWithSpace x1 x2 <span class="fu">=</span> x1 <span class="fu">++</span> <span class="st">&quot; &quot;</span> <span class="fu">++</span> x2</a>
<a class="sourceLine" id="cb113-2" data-line-number="2"><span class="dt">Prelude</span><span class="fu">&gt;</span> concatWithSpace <span class="st">&quot;Hello,&quot;</span> <span class="st">&quot;World!&quot;</span></a>
<a class="sourceLine" id="cb113-3" data-line-number="3"><span class="st">&quot;Hello, World!&quot;</span></a></code></pre></div>
<p>Let’s use currying to make a function that says “Hello” to anything.</p>
<div class="sourceCode" id="cb114"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb114-1" data-line-number="1"><span class="co">-- Use currying to make a function that takes a string and puts &quot;Hello &quot; in front of it.</span></a>
<a class="sourceLine" id="cb114-2" data-line-number="2"><span class="dt">Prelude</span><span class="fu">&gt;</span> sayHello <span class="fu">=</span> concatWithSpace <span class="st">&quot;Hello&quot;</span></a>
<a class="sourceLine" id="cb114-3" data-line-number="3"><span class="dt">Prelude</span><span class="fu">&gt;</span> sayHello <span class="st">&quot;puppy!&quot;</span></a>
<a class="sourceLine" id="cb114-4" data-line-number="4"><span class="st">&quot;Hello puppy!&quot;</span></a>
<a class="sourceLine" id="cb114-5" data-line-number="5"><span class="dt">Prelude</span><span class="fu">&gt;</span> sayHello <span class="st">&quot;house!&quot;</span></a>
<a class="sourceLine" id="cb114-6" data-line-number="6"><span class="st">&quot;Hello house!&quot;</span></a>
<a class="sourceLine" id="cb114-7" data-line-number="7"></a>
<a class="sourceLine" id="cb114-8" data-line-number="8"><span class="co">-- Now, let&#39;s check out our types.</span></a>
<a class="sourceLine" id="cb114-9" data-line-number="9"><span class="dt">Prelude</span><span class="fu">&gt;</span> <span class="fu">:</span><span class="kw">type</span> concatWithSpace</a>
<a class="sourceLine" id="cb114-10" data-line-number="10"><span class="ot">concatWithSpace ::</span> [<span class="dt">Char</span>] <span class="ot">-&gt;</span> ([<span class="dt">Char</span>] <span class="ot">-&gt;</span> [<span class="dt">Char</span>])    <span class="co">-- I&#39;ve added the parentheses for clarity</span></a>
<a class="sourceLine" id="cb114-11" data-line-number="11"><span class="dt">Prelude</span><span class="fu">&gt;</span> <span class="fu">:</span><span class="kw">type</span> sayHello</a>
<a class="sourceLine" id="cb114-12" data-line-number="12"><span class="ot">sayHello        ::</span>            [<span class="dt">Char</span>] <span class="ot">-&gt;</span> [<span class="dt">Char</span>]     <span class="co">-- Spaces also added for clarity.</span></a></code></pre></div>
<p><span class="newthought">Currying also</span> works with operators, but often requires surrounding them in parentheses<label for="sidenote-25" class="margin-toggle sidenote-number"></label> <input type="checkbox" id="sidenote-25" class="margin-toggle"/> <span class="sidenote">Which also turns them from infix functions to regular functions.</span>.</p>
<div class="sourceCode" id="cb115"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb115-1" data-line-number="1"><span class="dt">Prelude</span><span class="fu">&gt;</span> addOne <span class="fu">=</span> (<span class="dv">1</span><span class="fu">+</span>)</a>
<a class="sourceLine" id="cb115-2" data-line-number="2"><span class="dt">Prelude</span><span class="fu">&gt;</span> addOne <span class="dv">5</span></a>
<a class="sourceLine" id="cb115-3" data-line-number="3"><span class="dv">6</span></a>
<a class="sourceLine" id="cb115-4" data-line-number="4"></a>
<a class="sourceLine" id="cb115-5" data-line-number="5"><span class="co">-- You can curry either side of an infix function.</span></a>
<a class="sourceLine" id="cb115-6" data-line-number="6"><span class="dt">Prelude</span><span class="fu">&gt;</span> addOne&#39; <span class="fu">=</span> (<span class="fu">+</span><span class="dv">1</span>)</a>
<a class="sourceLine" id="cb115-7" data-line-number="7"><span class="dt">Prelude</span><span class="fu">&gt;</span> addOne&#39; <span class="dv">5</span></a>
<a class="sourceLine" id="cb115-8" data-line-number="8"><span class="dv">6</span></a></code></pre></div>
<p>Let’s rewrite <code>concatWithSpace</code> to use currying.</p>
<div class="sourceCode" id="cb116"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb116-1" data-line-number="1"><span class="dt">Prelude</span><span class="fu">&gt;</span> concatWithSpace&#39; x1 <span class="fu">=</span> ((x1 <span class="fu">++</span> <span class="st">&quot; &quot;</span>) <span class="fu">++</span>)</a>
<a class="sourceLine" id="cb116-2" data-line-number="2"><span class="dt">Prelude</span><span class="fu">&gt;</span> concatWithSpace&#39; <span class="st">&quot;hello&quot;</span> <span class="st">&quot;curry&quot;</span></a>
<a class="sourceLine" id="cb116-3" data-line-number="3"><span class="st">&quot;hello curry&quot;</span></a></code></pre></div>
<h2 id="map">Map</h2>
<p><span class="newthought">There’s an</span> incredibly useful function in Haskell named <code>map</code>. It does something that is quite common in Haskell, but it could be surprising. It has two parameters. The second is a List, but the first one is… another function<label for="sidenote-26" class="margin-toggle sidenote-number"></label> <input type="checkbox" id="sidenote-26" class="margin-toggle"/> <span class="sidenote">If you’re familiar with functions as parameters from C++, you’ll find in Haskell they’re much more convenient and type-safe.</span>! Let’s take a look at the <code>map</code>’s type.</p>
<pre><code>Prelude&gt; :t map
map :: (a -&gt; b) -&gt; [a] -&gt; [b]</code></pre>
<p>Two things here. First, I used <code>:t</code> instead of <code>:type</code>. <code>:t</code> is just a bit shorter, it’s the same otherwise. So let’s break this down.</p>
<div class="sourceCode" id="cb118"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb118-1" data-line-number="1"><span class="ot">   map ::</span> (a <span class="ot">-&gt;</span> b) <span class="ot">-&gt;</span> [a] <span class="ot">-&gt;</span> [b]</a>
<a class="sourceLine" id="cb118-2" data-line-number="2"><span class="co">--        ========    ===    ===</span></a>
<a class="sourceLine" id="cb118-3" data-line-number="3"><span class="co">--           [1]      [2]    [3]</span></a></code></pre></div>
<ol type="1">
<li><p>A function that takes an <code>a</code> and returns a <code>b</code><label for="sidenote-27" class="margin-toggle sidenote-number"></label> <input type="checkbox" id="sidenote-27" class="margin-toggle"/> <span class="sidenote">In the future, I might call this “a function from <code>a</code> to <code>b</code>”.</span>.</p></li>
<li><p>A List of <code>a</code>s.</p></li>
<li><p>A List of <code>b</code>s.</p></li>
</ol>
<p>Let’s put it into practice! What it does will become clear.</p>
<div class="sourceCode" id="cb119"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb119-1" data-line-number="1"><span class="co">-- Take a look at the type of the function (+1).</span></a>
<a class="sourceLine" id="cb119-2" data-line-number="2"><span class="dt">Prelude</span><span class="fu">&gt;</span> <span class="fu">:</span>t (<span class="fu">+</span><span class="dv">1</span>)</a>
<a class="sourceLine" id="cb119-3" data-line-number="3">(<span class="fu">+</span><span class="dv">1</span>)<span class="ot"> ::</span> <span class="dt">Num</span> a <span class="ot">=&gt;</span> a <span class="ot">-&gt;</span> a</a>
<a class="sourceLine" id="cb119-4" data-line-number="4"><span class="co">-- So it&#39;s a function that takes a value of type a and returns a value of type a, where a is a Num.</span></a>
<a class="sourceLine" id="cb119-5" data-line-number="5"></a>
<a class="sourceLine" id="cb119-6" data-line-number="6"><span class="dt">Prelude</span><span class="fu">&gt;</span> map (<span class="fu">+</span><span class="dv">1</span>) [<span class="dv">1</span>,<span class="dv">8</span>,<span class="dv">4</span>,<span class="dv">1</span>,<span class="fu">-</span><span class="dv">4</span>]</a>
<a class="sourceLine" id="cb119-7" data-line-number="7">[<span class="dv">2</span>,<span class="dv">9</span>,<span class="dv">5</span>,<span class="dv">2</span>,<span class="fu">-</span><span class="dv">3</span>]</a>
<a class="sourceLine" id="cb119-8" data-line-number="8"></a>
<a class="sourceLine" id="cb119-9" data-line-number="9"><span class="co">-- By the way when something is expecting an (a -&gt; b) function,</span></a>
<a class="sourceLine" id="cb119-10" data-line-number="10"><span class="co">-- an (a -&gt; a) function works fine.</span></a>
<a class="sourceLine" id="cb119-11" data-line-number="11"><span class="co">-- a and b can be different, but they don&#39;t have to be.</span></a></code></pre></div>
<p>What’s happened here is <code>map</code> has iterated over every element of <code>[1,8,4,1,-4]</code>, and applied the function <code>(+1)</code> to it. If you’ll look,<code>1</code> became <code>2</code>, <code>8</code> became <code>9</code>, etc.</p>
<div class="sourceCode" id="cb120"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb120-1" data-line-number="1"><span class="dt">Prelude</span><span class="fu">&gt;</span> map (<span class="fu">+</span><span class="dv">1</span>) [<span class="dv">1</span>,<span class="dv">8</span>,<span class="dv">4</span>,<span class="dv">1</span>,<span class="fu">-</span><span class="dv">4</span>]</a>
<a class="sourceLine" id="cb120-2" data-line-number="2"><span class="co">--                [1,     8,     4,     1,     -4]</span></a>
<a class="sourceLine" id="cb120-3" data-line-number="3"><span class="co">--                (+1)   (+1)   (+1)   (+1)   (+1)</span></a>
<a class="sourceLine" id="cb120-4" data-line-number="4"><span class="co">--                [2,     9,     5,     2,     -3]</span></a></code></pre></div>
<p>However, there’s another function called <code>fmap</code>, and it’s preferred that you use <code>fmap</code> over <code>map</code>. <code>fmap</code> works in situations <code>map</code> doesn’t, so it’s a bit nicer<label for="sidenote-28" class="margin-toggle sidenote-number"></label> <input type="checkbox" id="sidenote-28" class="margin-toggle"/> <span class="sidenote">Specifically <code>map</code> works only on Lists, but <code>fmap</code> works on anything in the typeclass <code>Functor</code> (which includes Lists). Unfortunately <code>Functor</code>s were developed after <code>map</code> so we’re stuck with the <code>f</code> in front.</span>.</p>
<h2 id="filter">Filter</h2>
<p><span class="newthought">Lets look</span> at another function, <code>filter</code>.</p>
<div class="sourceCode" id="cb121"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb121-1" data-line-number="1"><span class="dt">Prelude</span><span class="fu">&gt;</span> <span class="fu">:</span>t filter</a>
<a class="sourceLine" id="cb121-2" data-line-number="2">filter<span class="ot"> ::</span> (a <span class="ot">-&gt;</span> <span class="dt">Bool</span>) <span class="ot">-&gt;</span> [a] <span class="ot">-&gt;</span> [a]</a>
<a class="sourceLine" id="cb121-3" data-line-number="3"><span class="co">--           [1]         [2]    [3]</span></a>
<a class="sourceLine" id="cb121-4" data-line-number="4"><span class="co">-- 1) function from a to bool</span></a>
<a class="sourceLine" id="cb121-5" data-line-number="5"><span class="co">-- 2) List of a</span></a>
<a class="sourceLine" id="cb121-6" data-line-number="6"><span class="co">-- 3) List of b</span></a>
<a class="sourceLine" id="cb121-7" data-line-number="7"></a>
<a class="sourceLine" id="cb121-8" data-line-number="8"><span class="dt">Prelude</span><span class="fu">&gt;</span> isEven x <span class="fu">=</span> x <span class="ot">`rem`</span> <span class="dv">2</span> <span class="fu">==</span> <span class="dv">0</span></a>
<a class="sourceLine" id="cb121-9" data-line-number="9"><span class="dt">Prelude</span><span class="fu">&gt;</span> isEven <span class="dv">1</span></a>
<a class="sourceLine" id="cb121-10" data-line-number="10"><span class="dt">False</span></a>
<a class="sourceLine" id="cb121-11" data-line-number="11"><span class="dt">Prelude</span><span class="fu">&gt;</span> isEven <span class="dv">2</span></a>
<a class="sourceLine" id="cb121-12" data-line-number="12"><span class="dt">True</span></a>
<a class="sourceLine" id="cb121-13" data-line-number="13"></a>
<a class="sourceLine" id="cb121-14" data-line-number="14"><span class="dt">Prelude</span><span class="fu">&gt;</span> <span class="fu">:</span>t isEven</a>
<a class="sourceLine" id="cb121-15" data-line-number="15"><span class="ot">isEven ::</span> <span class="dt">Integral</span> a <span class="ot">=&gt;</span> a <span class="ot">-&gt;</span> <span class="dt">Bool</span></a>
<a class="sourceLine" id="cb121-16" data-line-number="16"><span class="co">-- Looks like isEven is a function from a to bool...</span></a>
<a class="sourceLine" id="cb121-17" data-line-number="17"></a>
<a class="sourceLine" id="cb121-18" data-line-number="18"><span class="dt">Prelude</span><span class="fu">&gt;</span> filter isEven [<span class="dv">1</span><span class="fu">..</span><span class="dv">10</span>]</a>
<a class="sourceLine" id="cb121-19" data-line-number="19">[<span class="dv">2</span>,<span class="dv">4</span>,<span class="dv">6</span>,<span class="dv">8</span>,<span class="dv">10</span>]</a></code></pre></div>
<p>See what happened? <code>filter</code> “filtered” out the values for which <code>isEven</code> returned <code>False</code>!</p>
<p>Often with <code>filter</code> you need a function fast, but don’t feel like giving it a name. For that, it’s a good time to use lambdas<label for="sidenote-29" class="margin-toggle sidenote-number"></label> <input type="checkbox" id="sidenote-29" class="margin-toggle"/> <span class="sidenote">Also known as anonymous functions.</span>, which look like this:</p>
<div class="sourceCode" id="cb122"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb122-1" data-line-number="1">   \i     <span class="ot">-&gt;</span>   i <span class="fu">&lt;</span> <span class="dv">4</span></a>
<a class="sourceLine" id="cb122-2" data-line-number="2"><span class="co">-- [1]   [2]    [3]</span></a></code></pre></div>
<ol type="1">
<li><p><code>\i</code> - A backslash<label for="marginnote-38" class="margin-toggle">⊕</label> <input type="checkbox" id="marginnote-38" class="margin-toggle"/> <span class="marginnote">Backslash was chosen because looks kind of like the Greek letter <code>λ</code> lambda, which you may recognize from Haskell’s logo.</span>, followed by all the parameters used by your function. In our case we only have one, <code>i</code>.</p></li>
<li><p><code>-&gt;</code> - An arrow used to separate the two halves of the lambda</p></li>
<li><p><code>i &lt; 4</code> - The body for your lambda - in our case, it returns a <code>True</code> if the number given is less than <code>4</code>, and <code>False</code> otherwise.<label for="marginnote-39" class="margin-toggle">⊕</label> <input type="checkbox" id="marginnote-39" class="margin-toggle"/> <span class="marginnote">If you want, you can give Haskell some type information about your lambdas, too.</p>
<div class="sourceCode" id="cb123"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb123-1" data-line-number="1"><span class="dt">Prelude</span><span class="fu">&gt;</span> bangBetween <span class="fu">=</span> (\x y <span class="ot">-&gt;</span> x <span class="fu">++</span> <span class="st">&quot;!&quot;</span> <span class="fu">++</span> y)<span class="ot"> ::</span> <span class="dt">String</span> <span class="ot">-&gt;</span> <span class="dt">String</span> <span class="ot">-&gt;</span> <span class="dt">String</span></a>
<a class="sourceLine" id="cb123-2" data-line-number="2"><span class="dt">Prelude</span><span class="fu">&gt;</span> bangBetween <span class="st">&quot;Bang&quot;</span> <span class="st">&quot;Bong&quot;</span></a>
<a class="sourceLine" id="cb123-3" data-line-number="3"><span class="st">&quot;Bang!Bong&quot;</span></a></code></pre></div></li>
</ol>
<p>Here’s how we’d use it with <code>filter</code>:</p>
<div class="sourceCode" id="cb124"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb124-1" data-line-number="1"><span class="dt">Prelude</span><span class="fu">&gt;</span> filter (\i <span class="ot">-&gt;</span> i <span class="fu">&lt;</span> <span class="dv">4</span>) [<span class="dv">1</span><span class="fu">..</span><span class="dv">10</span>]</a>
<a class="sourceLine" id="cb124-2" data-line-number="2">[<span class="dv">1</span>,<span class="dv">2</span>,<span class="dv">3</span>]</a></code></pre></div>
<p>Note that, because of the magic of currying, we could have written that as simply:</p>
<div class="sourceCode" id="cb125"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb125-1" data-line-number="1"><span class="dt">Prelude</span><span class="fu">&gt;</span> filter (<span class="fu">&lt;</span><span class="dv">4</span>) [<span class="dv">1</span><span class="fu">..</span><span class="dv">10</span>]</a>
<a class="sourceLine" id="cb125-2" data-line-number="2">[<span class="dv">1</span>,<span class="dv">2</span>,<span class="dv">3</span>]</a></code></pre></div>
<p>But I didn’t, because I wanted to show off lambdas.</p>
<p><code>filter</code> is useful for reducing the contents of a list to only contain what you want, and it’s used quite a bit<label for="sidenote-30" class="margin-toggle sidenote-number"></label> <input type="checkbox" id="sidenote-30" class="margin-toggle"/> <span class="sidenote">As you may have noticed, everything you can do with <code>map</code> and <code>filter</code> you can also do with list comprehensions. In fact, list comprehensions are converted to <code>map</code> and <code>filter</code> during compilation!</span>.</p>
<h2 id="function-composition">Function composition</h2>
<p><span class="newthought">Function composition</span> is mainly used to make code more readable, instead of being a huge mess of parentheses. It very common, so it’s symbol is just the <code>.</code> period.<label for="sidenote-31" class="margin-toggle sidenote-number"></label> <input type="checkbox" id="sidenote-31" class="margin-toggle"/> <span class="sidenote">A period also looks a bit like the function composition operator in mathematics, which is the real reason it was chosen.</span></p>
<p>The <code>.</code> operator is mainly useful for chaining together functions. This is its type:</p>
<div class="sourceCode" id="cb126"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb126-1" data-line-number="1"><span class="dt">Prelude</span><span class="fu">&gt;</span> <span class="fu">:</span>t (<span class="fu">.</span>)</a>
<a class="sourceLine" id="cb126-2" data-line-number="2"><span class="ot">(.) ::</span> (b <span class="ot">-&gt;</span> c) <span class="ot">-&gt;</span> (a <span class="ot">-&gt;</span> b) <span class="ot">-&gt;</span> a <span class="ot">-&gt;</span> c</a>
<a class="sourceLine" id="cb126-3" data-line-number="3"><span class="co">--        [1]         [2]      [3]  [4]</span></a></code></pre></div>
<p>1</span> First, it takes a function from <code>b</code> to <code>c</code>.</p>
<ol start="2" type="1">
<li><p>Then, it takes a function from <code>a</code> to <code>b</code>.</p></li>
<li><p>Then, it takes a value of type <code>a</code>.</p></li>
<li><p>Lastly, it returns a value of type <code>c</code>.</p></li>
</ol>
<p>Let’s write <code>.</code> ourselves. It’s actually extremely simple.</p>
<div class="sourceCode" id="cb127"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb127-1" data-line-number="1"><span class="dt">Prelude</span><span class="fu">&gt;</span> (<span class="fu">.</span>) f g x <span class="fu">=</span> f (g x)</a></code></pre></div>
<p>Here <code>f</code> and <code>g</code> are functions. You can use them just like any other function like we do with<code>(g x)</code>.</p>
<p>So let’s see it in action. Here’s an example of how we used to do things. We’ll make a function<label for="marginnote-40" class="margin-toggle">⊕</label> <input type="checkbox" id="marginnote-40" class="margin-toggle"/> <span class="marginnote">In real Haskell, we wouldn’t give these functions names, I’m just doing it for the example.</span> that multiplies numbers by 2 and a function that adds 1.</p>
<div class="sourceCode" id="cb128"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb128-1" data-line-number="1"><span class="dt">Prelude</span><span class="fu">&gt;</span> times2 <span class="fu">=</span> (<span class="fu">*</span><span class="dv">2</span>)</a>
<a class="sourceLine" id="cb128-2" data-line-number="2"><span class="dt">Prelude</span><span class="fu">&gt;</span> plus1 <span class="fu">=</span> (<span class="fu">+</span><span class="dv">1</span>)</a>
<a class="sourceLine" id="cb128-3" data-line-number="3"><span class="dt">Prelude</span><span class="fu">&gt;</span> times2plus1 x <span class="fu">=</span> plus1 (times2 x)</a>
<a class="sourceLine" id="cb128-4" data-line-number="4"><span class="dt">Prelude</span><span class="fu">&gt;</span> times2plus1 <span class="dv">4</span></a>
<a class="sourceLine" id="cb128-5" data-line-number="5"><span class="dv">9</span></a></code></pre></div>
<p>Now, let’s rewrite <code>times2plus1</code> to use <code>.</code> instead<label for="sidenote-32" class="margin-toggle sidenote-number"></label> <input type="checkbox" id="sidenote-32" class="margin-toggle"/> <span class="sidenote">The <code>.</code> operator might not seem very useful now, but it’s extremely common so it’ll pay to learn how it works.</span>.</p>
<div class="sourceCode" id="cb129"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb129-1" data-line-number="1"><span class="dt">Prelude</span><span class="fu">&gt;</span> times2plus1&#39; <span class="fu">=</span> plus1 <span class="fu">.</span> times2  <span class="co">-- Use currying for conciseness.</span></a>
<a class="sourceLine" id="cb129-2" data-line-number="2"><span class="dt">Prelude</span><span class="fu">&gt;</span> times2plus1&#39; <span class="dv">4</span></a>
<a class="sourceLine" id="cb129-3" data-line-number="3"><span class="dv">9</span></a></code></pre></div>
<p><em>Function composition</em> takes two functions as arguments. Then it returns a new function, which just applies the right function<label for="marginnote-41" class="margin-toggle">⊕</label> <input type="checkbox" id="marginnote-41" class="margin-toggle"/> <span class="marginnote">The interesting thing about this is that about half of people think it’s backward - the function on the right is applied first, then the function on the left, but some people’s intuition says it should be the other way around. Remember, it goes ⬅️this way⬅️</span> to whatever input it gets, then applies the left function.</p>
<p>You can chain it up as much as you want:</p>
<div class="sourceCode" id="cb130"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb130-1" data-line-number="1"><span class="dt">Prelude</span><span class="fu">&gt;</span> plusABunchThenTimes2 <span class="fu">=</span> times2 <span class="fu">.</span> plus1 <span class="fu">.</span> plus1 <span class="fu">.</span> plus1 <span class="fu">.</span> plus1 <span class="fu">.</span> plus1 <span class="fu">.</span> plus1 <span class="fu">.</span> plus1</a>
<a class="sourceLine" id="cb130-2" data-line-number="2"><span class="dt">Prelude</span><span class="fu">&gt;</span> plusABunchThenTimes2 <span class="dv">5</span></a>
<a class="sourceLine" id="cb130-3" data-line-number="3"><span class="dv">24</span></a></code></pre></div>
<p>Note that this will not work:</p>
<div class="sourceCode" id="cb131"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb131-1" data-line-number="1"><span class="dt">Prelude</span><span class="fu">&gt;</span> times2 <span class="fu">.</span> plus1 <span class="dv">3</span></a>
<a class="sourceLine" id="cb131-2" data-line-number="2"><span class="co">-- error!</span></a></code></pre></div>
<p>The issue is that <code>plus1 3</code> is getting evaluated first, and turning into <code>4</code>. Then it sees <code>times2 . 4</code>, and that doesn’t make any sense, since 4 isn’t a function. This is what you have to do instead:</p>
<div class="sourceCode" id="cb132"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb132-1" data-line-number="1"><span class="dt">Prelude</span><span class="fu">&gt;</span> (times2 <span class="fu">.</span> plus1) <span class="dv">3</span></a>
<a class="sourceLine" id="cb132-2" data-line-number="2"><span class="dv">8</span></a></code></pre></div>
<p>I know, that seems like a ton of extra work. That brings me to…</p>
<h2 id="function-application">Function Application</h2>
<p><span class="newthought"><em>Function application</em></span> is something you normally get when you don’t do anything<label for="sidenote-33" class="margin-toggle sidenote-number"></label> <input type="checkbox" id="sidenote-33" class="margin-toggle"/> <span class="sidenote">You could make a joke about function application being lazy.</span>. It’s what happens when you do <code>head [1,2,3]</code> - the function <code>head</code> is <em>applied</em> to <code>[1,2,3]</code>. But sometimes it happens before you want it to. That’s where <code>$</code> comes in. It’s a function, and here is its type:</p>
<div class="sourceCode" id="cb133"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb133-1" data-line-number="1"><span class="dt">Prelude</span><span class="fu">&gt;</span> <span class="fu">:</span>t (<span class="fu">$</span>)</a>
<a class="sourceLine" id="cb133-2" data-line-number="2"><span class="ot">($) ::</span> (a <span class="ot">-&gt;</span> b) <span class="ot">-&gt;</span> a <span class="ot">-&gt;</span> b</a></code></pre></div>
<p>It takes a function, and an argument, and applies the argument to the function. We could define it like this<label for="sidenote-34" class="margin-toggle sidenote-number"></label> <input type="checkbox" id="sidenote-34" class="margin-toggle"/> <span class="sidenote">To make it complete, we’d also have to set the precedence with the <code>infixl</code> keyword.</span>.</p>
<div class="sourceCode" id="cb134"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb134-1" data-line-number="1"><span class="dt">Prelude</span><span class="fu">&gt;</span> f <span class="fu">$</span> x <span class="fu">=</span> f x</a></code></pre></div>
<p>And here’s how we’d use it:</p>
<div class="sourceCode" id="cb135"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb135-1" data-line-number="1"><span class="dt">Prelude</span><span class="fu">&gt;</span> head [<span class="dv">1</span>,<span class="dv">2</span>,<span class="dv">3</span>]</a>
<a class="sourceLine" id="cb135-2" data-line-number="2"><span class="dv">1</span></a>
<a class="sourceLine" id="cb135-3" data-line-number="3"><span class="dt">Prelude</span><span class="fu">&gt;</span> head <span class="fu">$</span> [<span class="dv">1</span>,<span class="dv">2</span>,<span class="dv">3</span>]</a>
<a class="sourceLine" id="cb135-4" data-line-number="4"><span class="dv">1</span></a></code></pre></div>
<p>You may have noticed it doesn’t seem to have changed anything. Well, that’s because <code>$</code> doesn’t really change anything. But it has one very useful property: it has very low precedence. This means it will happen after most other stuff has gotten done. Remember this issue in the last section?</p>
<div class="sourceCode" id="cb136"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb136-1" data-line-number="1"><span class="dt">Prelude</span><span class="fu">&gt;</span> times2 <span class="fu">.</span> plus1 <span class="dv">3</span></a>
<a class="sourceLine" id="cb136-2" data-line-number="2"><span class="co">-- error!</span></a></code></pre></div>
<p><code>plus1</code> was getting applied to <code>3</code> too soon. We wanted to wait until <code>times2 . plus1</code> happened, then apply the result<label for="marginnote-42" class="margin-toggle">⊕</label> <input type="checkbox" id="marginnote-42" class="margin-toggle"/> <span class="marginnote">As a reminder, the result of <code>times2 . plus1</code> is a function which adds one, then multiplies by two.</span> of that to <code>3</code>. We can make this dream a reality with <code>$</code>.</p>
<div class="sourceCode" id="cb137"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb137-1" data-line-number="1"><span class="dt">Prelude</span><span class="fu">&gt;</span> times2 <span class="fu">.</span> plus1 <span class="fu">$</span> <span class="dv">3</span></a>
<a class="sourceLine" id="cb137-2" data-line-number="2"><span class="dv">8</span></a></code></pre></div>
<p>Success! Let’s try a more complicated usage:</p>
<div class="sourceCode" id="cb138"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb138-1" data-line-number="1"><span class="dt">Prelude</span><span class="fu">&gt;</span> sum <span class="fu">.</span> take <span class="dv">3</span> <span class="fu">$</span> [<span class="dv">1</span><span class="fu">..</span><span class="dv">1000</span>]</a>
<a class="sourceLine" id="cb138-2" data-line-number="2"><span class="dv">6</span></a></code></pre></div>
<p>This may seem confusing, but I’ll add some parentheses to try and make it more clear:</p>
<div class="sourceCode" id="cb139"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb139-1" data-line-number="1"><span class="dt">Prelude</span><span class="fu">&gt;</span> sum <span class="fu">.</span> (take <span class="dv">3</span>) <span class="fu">$</span> [<span class="dv">1</span><span class="fu">..</span><span class="dv">1000</span>]</a>
<a class="sourceLine" id="cb139-2" data-line-number="2"><span class="dv">6</span></a></code></pre></div>
<p><code>take 3</code> returns a function that takes 3. It then gets composed with <code>sum</code>, which sums all the values of a List, to make a new function that applies <code>take 3</code> then applies <code>sum</code>. This function is then applied to <code>[1..1000]</code>, which results in <code>6</code><label for="sidenote-35" class="margin-toggle sidenote-number"></label> <input type="checkbox" id="sidenote-35" class="margin-toggle"/> <span class="sidenote">Note that due to Haskell’s laziness, this list is never actually fully evaluated or put into memory, it is only ever evaluated up to the 3rd item.</span>. Let’s try really going crazy with it.</p>
<div class="sourceCode" id="cb140"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb140-1" data-line-number="1"><span class="dt">Prelude</span><span class="fu">&gt;</span> sum <span class="fu">.</span> (drop <span class="dv">2</span>) <span class="fu">.</span> fmap (<span class="fu">+</span><span class="dv">1</span>) <span class="fu">.</span> (<span class="fu">++</span>[<span class="dv">1</span>,<span class="dv">2</span>,<span class="dv">3</span>]) <span class="fu">$</span> [<span class="fu">-</span><span class="dv">1</span>,<span class="dv">0</span>]</a>
<a class="sourceLine" id="cb140-2" data-line-number="2"><span class="dv">9</span></a></code></pre></div>
<p>As you can see, we use <code>.</code> between all our functions, then <code>$</code> to the value we want to apply it to. This takes the list <code>[-1,0]</code>, adds <code>[1,2,3]</code> to it, adds <code>1</code> to every number in the list, removes the first two items from the list, and then gets the sum of that list<label for="sidenote-36" class="margin-toggle sidenote-number"></label> <input type="checkbox" id="sidenote-36" class="margin-toggle"/> <span class="sidenote">You typically would want to use <code>let</code> or <code>where</code> to make an intermediate list instead of putting them all into one giant function composition chain, just to make it more readable.</span>.</p>
<h2 id="folds">Folds</h2>
<p><span class="newthought">There’s another</span> function you should be familiar with: <code>foldl1</code>. It’s useful when you want to reduce a whole list to a single value. Let’s use <code>foldl1</code> to implement <code>sum'</code>, a function that takes a list of numbers and sums them all up. We’ll need to make a new function, <code>add</code>, that takes two numbers and adds them.</p>
<div class="sourceCode" id="cb141"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb141-1" data-line-number="1"><span class="co">-- Write a function that takes two numbers and adds them.</span></a>
<a class="sourceLine" id="cb141-2" data-line-number="2"><span class="dt">Prelude</span><span class="fu">&gt;</span> add x acc <span class="fu">=</span> x <span class="fu">+</span> acc</a>
<a class="sourceLine" id="cb141-3" data-line-number="3"><span class="dt">Prelude</span><span class="fu">&gt;</span> add <span class="dv">1</span> <span class="dv">3</span></a>
<a class="sourceLine" id="cb141-4" data-line-number="4"><span class="dv">4</span></a>
<a class="sourceLine" id="cb141-5" data-line-number="5"></a>
<a class="sourceLine" id="cb141-6" data-line-number="6"><span class="co">-- Use that function to write sum&#39;.</span></a>
<a class="sourceLine" id="cb141-7" data-line-number="7"><span class="dt">Prelude</span><span class="fu">&gt;</span> sum&#39; xs <span class="fu">=</span> foldl1 add xs</a>
<a class="sourceLine" id="cb141-8" data-line-number="8"><span class="dt">Prelude</span><span class="fu">&gt;</span> sum&#39; [<span class="dv">1</span>,<span class="dv">3</span>,<span class="dv">5</span>,<span class="dv">9</span>]</a>
<a class="sourceLine" id="cb141-9" data-line-number="9"><span class="dv">18</span></a></code></pre></div>
<p>You’re probably wondering how this works. First, notice that <code>add</code> takes two values, but only returns one? For example, <code>add 1 4</code> evaluates to <code>5</code>. What <code>foldl1</code> does is use that to take a whole <em>list</em> of values and reduce it down to just one. It starts out by using the function to turn the first two values into one value.</p>
<figure>
<label for="figure-2" class="margin-toggle">⊕</label> <input type="checkbox" id="figure-2" class="margin-toggle"/> <span class="marginnote"></span> <img src="assets/exp_foldl1_step_1.svg" alt="" />
</figure>
<p>Notice that the list got shorter! <code>foldl1</code> just keeps doing that until there’s only one item left.</p>
<figure>
<label for="figure-3" class="margin-toggle">⊕</label> <input type="checkbox" id="figure-3" class="margin-toggle"/> <span class="marginnote"></span> <img src="assets/exp_foldl1_repeat_step_1.svg" alt="" />
</figure>
<p>There’s another function, <code>foldr1</code>, that does the same thing except it goes right-to-left instead of left-to-right. If possible, you should use <code>foldr1</code> instead of <code>foldl1</code> because <code>foldr1</code> is much more efficient. I only introduced <code>foldl1</code> first because it’s a bit easier to explain.</p>
<hr />
<p><strong><strong><em>Exercises</em></strong></strong></p>
<ol type="1">
<li><p>Write a function called <code>product'</code> which multiplies the items in the list, instead of adding.</p></li>
<li><p>Write the <code>foldl1</code> function yourself, calling it <code>foldl1'</code>. The answer is in the <code>writefoldl1.hs</code> file.</p>
<ol type="1">
<li><p>Hint! You need recursion.</p></li>
<li><p>Hint! The base case is a list with one value. If you get <code>foldl1' f [x]</code>, you can just return <code>x</code>.</p></li>
<li><p>Hint! Check out the chapter on <a href="#recursion-practice">Recursion Practice</a> if you’re stuck.</p></li>
</ol></li>
</ol>
<hr />
<p>You may have noticed our <code>add</code> function, which adds two numbers, is the same as <code>(+)</code> (due to currying). So this would also work:</p>
<div class="sourceCode" id="cb142"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb142-1" data-line-number="1"><span class="dt">Prelude</span><span class="fu">&gt;</span> sum&#39; xs <span class="fu">=</span> foldl1 (<span class="fu">+</span>) xs</a></code></pre></div>
<p>And, of course, due to currying we can do this:</p>
<div class="sourceCode" id="cb143"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb143-1" data-line-number="1"><span class="dt">Prelude</span><span class="fu">&gt;</span> sum&#39; <span class="fu">=</span> foldl1 (<span class="fu">+</span>)</a></code></pre></div>
<p>Now, <code>foldl1</code> is certainly useful, but it’s a bit restrictive. If we have a list of numbers, it has to return a number. If we have a list of characters, it has to return a character, and so on. However, there’s the <code>foldl</code> which is very similar but allows the output to be a different type than the input. Because of this, you also need to pass it a separate starting value. Let’s use <code>foldl</code> to write a function that takes a list of numbers and returns a string of all the numbers together. So <code>[1,2,3]</code> would be <code>&quot;123&quot;</code>. Remember, the <code>show</code> function takes a value and returns a <code>String</code>, so <code>show 3</code> returns <code>&quot;3&quot;</code>. We’ll also use a lambda to make a function in our expression, instead of defining to separately.</p>
<div class="sourceCode" id="cb144"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb144-1" data-line-number="1"><span class="dt">Prelude</span><span class="fu">&gt;</span> listString xs <span class="fu">=</span> foldl (\acc x <span class="ot">-&gt;</span> acc <span class="fu">++</span> (show x)) <span class="st">&quot;&quot;</span> xs</a>
<a class="sourceLine" id="cb144-2" data-line-number="2"><span class="dt">Prelude</span><span class="fu">&gt;</span> listString [<span class="dv">1</span>,<span class="dv">2</span>,<span class="dv">3</span>]</a>
<a class="sourceLine" id="cb144-3" data-line-number="3"><span class="st">&quot;123&quot;</span></a></code></pre></div>
<p>Here’s how this works:</p>
<figure>
<label for="figure-4" class="margin-toggle">⊕</label> <input type="checkbox" id="figure-4" class="margin-toggle"/> <span class="marginnote"></span> <img src="assets/exp_foldl_repeat_step_1.svg" alt="" />
</figure>
<p>Of course, there’s also <code>foldr</code>, which is much faster than <code>foldl</code>.</p>
<hr />
<p><strong><strong><em>Exercises</em></strong></strong></p>
<ol type="1">
<li><p>Rewrite <code>sum'</code> using <code>foldl</code> instead of <code>foldl1</code>. Hint: you can add anything to 0 and get the same number.</p></li>
<li><p>Write the <code>foldl1</code> function yourself. The base case is the empty list. Look at your <code>foldl1'</code> function for inspiration.</p></li>
</ol>
<hr />
<h1 id="a-brief-note-on-undefined">A Brief Note on Undefined</h1>
<p><span class="newthought">Haskell allows</span> you to use a special value called <code>undefined</code>, also known as <code>bottom</code>, also known as <code>⊥</code>, also known as <code>_|_</code><label for="sidenote-37" class="margin-toggle sidenote-number"></label> <input type="checkbox" id="sidenote-37" class="margin-toggle"/> <span class="sidenote"><code>_|_</code> is just an ASCII version of <code>⊥</code>. Both are pronounced “bottom”</span>. Here, I’ll be calling it <code>undefined</code>.</p>
<p>Normally Haskell will complain if you use a value of a type it doesn’t expect.</p>
<div class="sourceCode" id="cb145"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb145-1" data-line-number="1"><span class="dt">Prelude</span><span class="fu">&gt;</span> head <span class="st">&quot;hello!&quot;</span></a>
<a class="sourceLine" id="cb145-2" data-line-number="2"><span class="ch">&#39;h&#39;</span></a>
<a class="sourceLine" id="cb145-3" data-line-number="3"><span class="dt">Prelude</span><span class="fu">&gt;</span> head <span class="dt">True</span></a>
<a class="sourceLine" id="cb145-4" data-line-number="4"><span class="co">-- error! head wants an [a], not a bool.</span></a></code></pre></div>
<p>But there’s a special value in Haskell which is acceptable to all functions, <code>undefined</code><label for="sidenote-38" class="margin-toggle sidenote-number"></label> <input type="checkbox" id="sidenote-38" class="margin-toggle"/> <span class="sidenote">Technically, <code>undefined</code> is a member of all types.</span>. There’s a catch though - if a Haskell program tries to “look at” this value or actually do anything with it, your program will crash.</p>
<div class="sourceCode" id="cb146"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb146-1" data-line-number="1"><span class="dt">Prelude</span><span class="fu">&gt;</span> i <span class="fu">=</span> undefined</a>
<a class="sourceLine" id="cb146-2" data-line-number="2"><span class="dt">Prelude</span><span class="fu">&gt;</span> i <span class="fu">+</span> <span class="dv">1</span></a>
<a class="sourceLine" id="cb146-3" data-line-number="3"><span class="co">-- error!</span></a>
<a class="sourceLine" id="cb146-4" data-line-number="4"><span class="dt">Prelude</span><span class="fu">&gt;</span> l <span class="fu">=</span> [<span class="dv">1</span>,<span class="dv">2</span>,<span class="dv">3</span>,<span class="dv">4</span>,undefined]</a>
<a class="sourceLine" id="cb146-5" data-line-number="5"><span class="dt">Prelude</span><span class="fu">&gt;</span> l <span class="fu">!!</span> <span class="dv">3</span></a>
<a class="sourceLine" id="cb146-6" data-line-number="6"><span class="dv">4</span></a>
<a class="sourceLine" id="cb146-7" data-line-number="7"><span class="dt">Prelude</span><span class="fu">&gt;</span> l <span class="fu">!!</span> <span class="dv">4</span></a>
<a class="sourceLine" id="cb146-8" data-line-number="8"><span class="co">-- error!</span></a></code></pre></div>
<p>This may seem totally useless. What use is there for a value that you can’t use? Well, it comes in handy in a couple of situations, like demonstrating <em>laziness</em>. I haven’t talked much about laziness, but it’s basically the idea that Haskell won’t try and compute something it doesn’t have to. This is why you can have an infinite List in Haskell - the whole List isn’t ever made and loaded into memory, of course. It’s just only computed as far along as your program needs. You can demonstrate that the <code>head</code> function (which takes a List and returns the first value) doesn’t look at any values in the List besides the first one.</p>
<div class="sourceCode" id="cb147"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb147-1" data-line-number="1"><span class="dt">Prelude</span><span class="fu">&gt;</span> head [<span class="dv">1</span>, undefined]</a>
<a class="sourceLine" id="cb147-2" data-line-number="2"><span class="dv">1</span></a>
<a class="sourceLine" id="cb147-3" data-line-number="3"><span class="dt">Prelude</span><span class="fu">&gt;</span> head [undefined, <span class="dv">1</span>]</a>
<a class="sourceLine" id="cb147-4" data-line-number="4"><span class="co">-- error!</span></a></code></pre></div>
<p>If a function makes your program crash or gets caught in an infinite loop, we say its return value is <code>⊥</code>. Let’s say I tried to write this:</p>
<div class="sourceCode" id="cb148"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb148-1" data-line-number="1"><span class="dt">Prelude</span><span class="fu">&gt;</span> stupid <span class="fu">=</span> sum [<span class="dv">1</span><span class="fu">..</span>]</a>
<a class="sourceLine" id="cb148-2" data-line-number="2"><span class="dt">Prelude</span><span class="fu">&gt;</span> stupid</a>
<a class="sourceLine" id="cb148-3" data-line-number="3"><span class="co">-- infinite loop</span></a></code></pre></div>
<p><code>stupid</code>, when I try to evaluate it, will cause a program to hang. You can try to sum an infinite List, but you won’t ever finish., you’ll just keep adding values forever. So the value of <code>stupid</code> is said to be <code>⊥</code><label for="sidenote-39" class="margin-toggle sidenote-number"></label> <input type="checkbox" id="sidenote-39" class="margin-toggle"/> <span class="sidenote">This symbol is used because it looks like it’s pointing at the bottom of something. We say “bottom” because of some complicated type theory, but it basically means it’s “the most undefined” possible value.</span>, because once your program hits it, it won’t do anything else.</p>
<p>Sometimes you want to talk about the fact that you can pass a <code>⊥</code> to a function, and it won’t crash your program. Here’s an example:</p>
<div class="sourceCode" id="cb149"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb149-1" data-line-number="1"><span class="dt">Prelude</span><span class="fu">&gt;</span> weird x <span class="fu">=</span> <span class="dv">3</span></a></code></pre></div>
<p>This is a function that takes a value and returns <code>3</code>, no matter what you put in. Since Haskell is lazy, it won’t try to evaluate <code>x</code> until you need it, which this function never will since it throws it away and just returns <code>3</code>.</p>
<p>So I can write this, and it’ll work just fine:</p>
<div class="sourceCode" id="cb150"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb150-1" data-line-number="1"><span class="dt">Prelude</span><span class="fu">&gt;</span> weird <span class="fu">.</span> sum <span class="fu">$</span> [<span class="dv">1</span><span class="fu">..</span>]</a>
<a class="sourceLine" id="cb150-2" data-line-number="2"><span class="dv">3</span></a></code></pre></div>
<p>Haskell never needs the value of <code>sum [1..]</code>, so it never computes it. But sometimes you want to be able to say this in a way that’s a bit more general. That’s where <code>undefined</code><label for="marginnote-43" class="margin-toggle">⊕</label> <input type="checkbox" id="marginnote-43" class="margin-toggle"/> <span class="marginnote"><code>undefined</code> is a good name because, if a function takes your program into an infinite loop, there’s no definition for what that functions should return. It’ll never return anything!</span> comes in:</p>
<div class="sourceCode" id="cb151"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb151-1" data-line-number="1"><span class="dt">Prelude</span><span class="fu">&gt;</span> weird undefined</a>
<a class="sourceLine" id="cb151-2" data-line-number="2"><span class="dv">3</span></a></code></pre></div>
<p>Haskell is lazy and so our <code>weird</code> function doesn’t even look at the value of its parameter <code>x</code> (since it doesn’t need it). That’s good in our case since the value of <code>x</code> is <code>undefined</code> and looking at it would crash our program.</p>
<p><span class="newthought">Undefined can</span> also be a very useful tool. Let’s say you’re writing a program and you’re not really sure how to write a function you need. You can just define it as <code>undefined</code> and then you can go work on something else. Your program won’t work until you define that function for real, of course, but you can call it elsewhere and Haskell will do its work in making sure your types check out. Newer versions of GHC make this even easier, with what’s called a <em>type holes</em>. Anywhere GHC expects a value you can add a <code>_</code> and GHC will still allow you to compile but gives you a warning that your function won’t work at runtime.</p>
<h1 id="when-things-might-go-wrong.">When things might go wrong.</h1>
<p><span class="newthought">Often we</span> want to write a function that just doesn’t make sense for all possible inputs. For example, the <code>head</code> function<label for="marginnote-44" class="margin-toggle">⊕</label> <input type="checkbox" id="marginnote-44" class="margin-toggle"/> <span class="marginnote"><code>head</code> extracts the first element from a list.</span>. It works great for most lists, but for empty lists, it crashes your program.</p>
<div class="sourceCode" id="cb152"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb152-1" data-line-number="1"><span class="dt">Prelude</span><span class="fu">&gt;</span> head [<span class="dv">1</span>,<span class="dv">2</span>,<span class="dv">3</span>]</a>
<a class="sourceLine" id="cb152-2" data-line-number="2"><span class="dv">1</span></a>
<a class="sourceLine" id="cb152-3" data-line-number="3"><span class="dt">Prelude</span><span class="fu">&gt;</span> head []</a>
<a class="sourceLine" id="cb152-4" data-line-number="4"><span class="co">-- error!</span></a></code></pre></div>
<p>In other languages, what you might do is return some value like <code>null</code> or <code>None</code>. But those come with issues. For example, what if you forget to check to make sure you got a valid answer before using the value? In fact, this causes so many problems that it’s sometimes called <a href="https://www.infoq.com/presentations/Null-References-The-Billion-Dollar-Mistake-Tony-Hoare">The Billion Dollar Mistake</a>. Haskell provides a better way, using <code>Maybe</code>. Here’s how it works.</p>
<div class="sourceCode" id="cb153"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb153-1" data-line-number="1"><span class="co">-- maybeHead.hs</span></a>
<a class="sourceLine" id="cb153-2" data-line-number="2"><span class="ot">maybeHead ::</span> [a] <span class="ot">-&gt;</span> <span class="dt">Maybe</span> a</a>
<a class="sourceLine" id="cb153-3" data-line-number="3">maybeHead (x<span class="fu">:</span>xs) <span class="fu">=</span> <span class="dt">Just</span> x</a>
<a class="sourceLine" id="cb153-4" data-line-number="4">maybeHead _ <span class="fu">=</span> <span class="dt">Nothing</span></a></code></pre></div>
<p>We have three new things here. <code>Maybe a</code>, <code>Just</code> and <code>Nothing</code><label for="marginnote-45" class="margin-toggle">⊕</label> <input type="checkbox" id="marginnote-45" class="margin-toggle"/> <span class="marginnote">In case you’ve forgotten, <code>(x:xs)</code> is a pattern that will match any list with at least one element, and set <code>x</code> to the first element.</span>. <code>Maybe a</code> says that we don’t want to return just a regular <code>a</code>, we want to return it wrapped up in a <code>Maybe</code>. <code>Maybe a</code> is a different type than <code>a</code>, and you can’t return an <code>a</code> if your code expects a <code>Maybe a</code>. To convert a regular value into a <code>Maybe</code> value, we use the <code>Just</code> function<label for="marginnote-46" class="margin-toggle">⊕</label> <input type="checkbox" id="marginnote-46" class="margin-toggle"/> <span class="marginnote"><code>Just</code> takes a value and returns that value wrapped up in a <code>Maybe</code> type.</span>. But there’s another valid <code>Maybe a</code> value, and that’s <code>Nothing</code>. You can think of <code>Just</code> as saying “Give me a value of type <code>a</code>, and I will give you a value of type <code>Maybe a</code>”. Don’t worry if this seems confusing, let’s play with it a little bit.</p>
<div class="sourceCode" id="cb154"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb154-1" data-line-number="1"><span class="fu">*</span><span class="dt">Main</span><span class="fu">&gt;</span> maybeHead ([<span class="dv">1</span>,<span class="dv">2</span>,<span class="dv">3</span>]<span class="ot"> ::</span> [<span class="dt">Int</span>])</a>
<a class="sourceLine" id="cb154-2" data-line-number="2"><span class="dt">Just</span> <span class="dv">1</span></a>
<a class="sourceLine" id="cb154-3" data-line-number="3"><span class="fu">*</span><span class="dt">Main</span><span class="fu">&gt;</span> maybeHead []</a>
<a class="sourceLine" id="cb154-4" data-line-number="4"><span class="dt">Nothing</span></a></code></pre></div>
<p>See? No more crash. But we have an issue: our output isn’t an <code>Int</code> anymore, it’s a <code>Maybe Int</code>!</p>
<div class="sourceCode" id="cb155"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb155-1" data-line-number="1"><span class="fu">*</span><span class="dt">Main</span><span class="fu">&gt;</span> first <span class="fu">=</span> maybeHead ([<span class="dv">1</span>,<span class="dv">2</span>,<span class="dv">3</span>]<span class="ot"> ::</span> [<span class="dt">Int</span>])</a>
<a class="sourceLine" id="cb155-2" data-line-number="2"><span class="fu">*</span><span class="dt">Main</span><span class="fu">&gt;</span> <span class="fu">:</span>t first</a>
<a class="sourceLine" id="cb155-3" data-line-number="3"><span class="ot">first ::</span> <span class="dt">Maybe</span> <span class="dt">Int</span></a></code></pre></div>
<p>This means we’ve lost our ability to do Math on it. <code>Maybe Int</code> is a different type than <code>Int</code>, and we can’t add, subtract, multiply, or do anything else to it. However, luckily, <code>Maybe</code> plays nice with pattern matching. Let’s write a function that takes a <code>Maybe Int</code>, and returns a <code>Maybe Int</code> with the number increased by <code>1</code>. If you pass it a <code>Nothing</code>, it’ll return <code>Nothing</code>. We’ll also include our <code>maybeHead</code> function from earlier just to have them in the same file.</p>
<div class="sourceCode" id="cb156"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb156-1" data-line-number="1"><span class="co">-- maybeAddOne.hs</span></a>
<a class="sourceLine" id="cb156-2" data-line-number="2"><span class="ot">maybeAddOne ::</span> (<span class="dt">Num</span> a) <span class="ot">=&gt;</span> <span class="dt">Maybe</span> a <span class="ot">-&gt;</span> <span class="dt">Maybe</span> a</a>
<a class="sourceLine" id="cb156-3" data-line-number="3">maybeAddOne (<span class="dt">Just</span> x) <span class="fu">=</span> <span class="dt">Just</span> (x <span class="fu">+</span> <span class="dv">1</span>)</a>
<a class="sourceLine" id="cb156-4" data-line-number="4">maybeAddOne <span class="dt">Nothing</span> <span class="fu">=</span> <span class="dt">Nothing</span></a>
<a class="sourceLine" id="cb156-5" data-line-number="5"></a>
<a class="sourceLine" id="cb156-6" data-line-number="6"><span class="ot">maybeHead ::</span> [a] <span class="ot">-&gt;</span> <span class="dt">Maybe</span> a</a>
<a class="sourceLine" id="cb156-7" data-line-number="7">maybeHead (x<span class="fu">:</span>xs) <span class="fu">=</span> <span class="dt">Just</span> x</a>
<a class="sourceLine" id="cb156-8" data-line-number="8">maybeHead _ <span class="fu">=</span> <span class="dt">Nothing</span></a></code></pre></div>
<p>Time to see it in action!</p>
<div class="sourceCode" id="cb157"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb157-1" data-line-number="1"><span class="fu">*</span><span class="dt">Main</span><span class="fu">&gt;</span> first <span class="fu">=</span> maybeHead ([<span class="dv">1</span>,<span class="dv">2</span>,<span class="dv">3</span>]<span class="ot"> ::</span> [<span class="dt">Int</span>])</a>
<a class="sourceLine" id="cb157-2" data-line-number="2"><span class="fu">*</span><span class="dt">Main</span><span class="fu">&gt;</span> first</a>
<a class="sourceLine" id="cb157-3" data-line-number="3"><span class="dt">Just</span> <span class="dv">1</span></a>
<a class="sourceLine" id="cb157-4" data-line-number="4"><span class="fu">*</span><span class="dt">Main</span><span class="fu">&gt;</span> maybeAddOne first</a>
<a class="sourceLine" id="cb157-5" data-line-number="5"><span class="dt">Just</span> <span class="dv">2</span></a></code></pre></div>
<p>Let’s do that to multiply our <code>first</code> by <code>10</code>.</p>
<p>You’ll notice that we don’t have a case for if <code>first</code> is <code>Nothing</code>. This means our pattern is non-exhaustive and would crash if we provided it a <code>Nothing</code><label for="marginnote-47" class="margin-toggle">⊕</label> <input type="checkbox" id="marginnote-47" class="margin-toggle"/> <span class="marginnote">Since this is a big opportunity for bugs, later I’ll tell you a GHC option that will force all your patterns to be exhaustive.</span>.</p>
<div class="sourceCode" id="cb158"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb158-1" data-line-number="1"><span class="fu">*</span><span class="dt">Main</span><span class="fu">&gt;</span> first <span class="fu">=</span> maybeHead ([]<span class="ot"> ::</span> [<span class="dt">Int</span>])</a>
<a class="sourceLine" id="cb158-2" data-line-number="2"><span class="fu">*</span><span class="dt">Main</span><span class="fu">&gt;</span> <span class="kw">case</span> first <span class="kw">of</span> (<span class="dt">Just</span> x) <span class="ot">-&gt;</span> <span class="dt">Just</span> (x<span class="fu">*</span><span class="dv">10</span>)</a>
<a class="sourceLine" id="cb158-3" data-line-number="3"><span class="co">--- error!</span></a></code></pre></div>
<p><span class="newthought">We don’t</span> have to be super specific about what types our <code>Maybe</code> can use. Remember how we did <code>Maybe Int</code>? We could just as easily have changed the type signature to look like this:</p>
<div class="sourceCode" id="cb159"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb159-1" data-line-number="1"><span class="ot">maybeAddOne ::</span> (<span class="dt">Num</span> a) <span class="ot">=&gt;</span> <span class="dt">Maybe</span> a <span class="ot">-&gt;</span> <span class="dt">Maybe</span> a</a></code></pre></div>
<p>Which is better because it’s more general. If this seems confusing, don’t worry, in the next chapter we’ll address it more.</p>
<hr />
<p><strong><strong><em>Exercises</em></strong></strong>:</p>
<ol type="1">
<li><p>Write a function with the type signature:</p>
<div class="sourceCode" id="cb160"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb160-1" data-line-number="1"><span class="ot">maybeSquare ::</span> (<span class="dt">Num</span> a) <span class="ot">=&gt;</span> <span class="dt">Maybe</span> a <span class="ot">-&gt;</span> <span class="dt">Maybe</span> a</a></code></pre></div>
<p>It should take a <code>(Just &lt;number&gt;)</code> and return a <code>Just (&lt;number&gt;^2)</code>. If passed <code>Nothing</code>, it should return <code>Nothing</code>.</p>
<ol type="1">
<li><p>So <code>maybeSquare (Just 4)</code> should evaluate to <code>Just 16</code></p></li>
<li><p><code>maybeSquare Nothing</code> should evaluate to <code>Nothing</code>.</p></li>
</ol></li>
<li><p>Write a function with the type signature <code>maybePow :: Maybe Int -&gt; Int -&gt; Maybe Int</code>, that takes a <code>Maybe Int</code> and an <code>Int</code>, and raises the former to the latter power.</p>
<ol type="1">
<li><p>So <code>maybePow (Just 3) 2</code> should evaluate to <code>Just 9</code>.</p></li>
<li><p><code>maybePow Nothing 2</code> should evaluate to <code>Nothing</code>.</p></li>
</ol></li>
<li><p>Remember our <code>neck</code> function from earlier?</p>
<div class="sourceCode" id="cb161"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb161-1" data-line-number="1"><span class="ot">neck ::</span> [a] <span class="ot">-&gt;</span> a</a>
<a class="sourceLine" id="cb161-2" data-line-number="2">neck (_<span class="fu">:</span>x<span class="fu">:</span>_) <span class="fu">=</span> x</a></code></pre></div>
<p>Rewrite it to return a <code>Maybe a</code> instead of an <code>a</code>, and not crash when provided a list with less than two elements.</p></li>
</ol>
<hr />
<h1 id="creating-new-data-types">Creating New Data Types</h1>
<h2 id="basic-data-types">Basic data types</h2>
<p><span class="newthought">You know</span> by now that Haskell offers a variety of data types, like <code>Int</code>, <code>Integer</code>, <code>Bool</code>, and <code>Char</code>. But like most languages, it also allows you to create your own. Remember how <code>Bool</code> has two possible states, <code>True</code> and <code>False</code>? Let’s make one a new type <code>Answer</code>, that has two states <code>Yes</code> and <code>No</code>.</p>
<div class="sourceCode" id="cb162"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb162-1" data-line-number="1"><span class="dt">Prelude</span><span class="fu">&gt;</span> <span class="kw">data</span> <span class="dt">Answer</span>   <span class="fu">=</span>    <span class="dt">Yes</span>   <span class="fu">|</span>    <span class="dt">No</span></a>
<a class="sourceLine" id="cb162-2" data-line-number="2"><span class="co">--        [1]   [2]         [3]  [4]   [5]</span></a></code></pre></div>
<p>Let’s break this down.</p>
<ol type="1">
<li><p><code>data</code>: This is how we say we’re going to declare a new data type<label for="marginnote-48" class="margin-toggle">⊕</label> <input type="checkbox" id="marginnote-48" class="margin-toggle"/> <span class="marginnote">In this case, it’s what’s called a <em>sum type</em>, which is similar to an enum in other languages, only better.</span>.</p></li>
<li><p><code>Answer</code>: This is the name of our data type.</p></li>
<li><p><code>Yes</code>: This is a possible value our data type can take, like <code>True</code> or <code>False</code> for the data type <code>Bool</code>.</p></li>
<li><p><code>|</code>: This is telling Haskell we’re going to have multiple “constructors” for this data type, which is a fancy way of saying there are multiple ways we can make a value of type <code>Answer</code>. In our case, those two ways are typing <code>Yes</code> or <code>No</code>. This makes it a <em>sum type</em> - you can think of it as the sum of multiple different possible values.</p></li>
<li><p><code>No</code>: This is the other value our data type can take.</p></li>
</ol>
<p><span class="newthought">An important</span> restriction to note here is that data types have to begin with capital letters. <code>Person</code> is a valid data type, <code>person</code> is not<label for="marginnote-49" class="margin-toggle">⊕</label> <input type="checkbox" id="marginnote-49" class="margin-toggle"/> <span class="marginnote">You might have noticed something quite nice here - a type cannot begin with a lowercase letter, and a function or binding cannot begin with an uppercase letter. This makes it simple to tell the difference between <code>Foo</code> and <code>foo</code>.</span>.</p>
<p>On Facebook, when you are invited to an event, you can respond “attending”, “not attending”, or “might attend”<label for="sidenote-40" class="margin-toggle sidenote-number"></label> <input type="checkbox" id="sidenote-40" class="margin-toggle"/> <span class="sidenote">Don’t let all these enum-ey examples discourage you, we’ll get to more complicated uses in a moment.</span>. Let’s see how that would be represented in Haskell.</p>
<div class="sourceCode" id="cb163"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb163-1" data-line-number="1"><span class="dt">Prelude</span><span class="fu">&gt;</span> <span class="kw">data</span> <span class="dt">InvitationResponse</span> <span class="fu">=</span> <span class="dt">Attending</span> <span class="fu">|</span> <span class="dt">NotAttending</span> <span class="fu">|</span> <span class="dt">MightAttend</span></a></code></pre></div>
<p>If you’ve tried to play with them. you might have noticed that you don’t seem to be able to use these values for very much.</p>
<div class="sourceCode" id="cb164"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb164-1" data-line-number="1"><span class="dt">Prelude</span><span class="fu">&gt;</span> <span class="dt">Attending</span> <span class="fu">==</span> <span class="dt">Attending</span></a>
<a class="sourceLine" id="cb164-2" data-line-number="2"><span class="co">-- error!</span></a>
<a class="sourceLine" id="cb164-3" data-line-number="3"><span class="fu">&lt;</span>interactive<span class="fu">&gt;:</span><span class="dv">4</span><span class="fu">:</span><span class="dv">1</span><span class="fu">:</span> error<span class="fu">:</span></a>
<a class="sourceLine" id="cb164-4" data-line-number="4">    <span class="fu">*</span> <span class="dt">No</span> <span class="kw">instance</span> for (<span class="dt">Eq</span> <span class="dt">InvitationResponse</span>)</a>
<a class="sourceLine" id="cb164-5" data-line-number="5">        arising from a use <span class="kw">of</span> <span class="ot">`==&#39;</span></a>
<a class="sourceLine" id="cb164-6" data-line-number="6"><span class="ot">    * In the expression: Attending == Attending</span></a>
<a class="sourceLine" id="cb164-7" data-line-number="7"><span class="ot">      In an equation for `</span>it&#39;<span class="fu">:</span> it <span class="fu">=</span> <span class="dt">Attending</span> <span class="fu">==</span> <span class="dt">Attending</span></a>
<a class="sourceLine" id="cb164-8" data-line-number="8"><span class="dt">Prelude</span><span class="fu">&gt;</span> i <span class="fu">=</span> <span class="dt">Attending</span></a>
<a class="sourceLine" id="cb164-9" data-line-number="9"><span class="dt">Prelude</span><span class="fu">&gt;</span> i</a>
<a class="sourceLine" id="cb164-10" data-line-number="10"><span class="co">-- error!</span></a>
<a class="sourceLine" id="cb164-11" data-line-number="11"><span class="fu">&lt;</span>interactive<span class="fu">&gt;:</span><span class="dv">6</span><span class="fu">:</span><span class="dv">1</span><span class="fu">:</span> error<span class="fu">:</span></a>
<a class="sourceLine" id="cb164-12" data-line-number="12">    <span class="fu">*</span> <span class="dt">No</span> <span class="kw">instance</span> for (<span class="dt">Show</span> <span class="dt">InvitationResponse</span>)</a>
<a class="sourceLine" id="cb164-13" data-line-number="13">        arising from a use <span class="kw">of</span> <span class="ot">`print&#39;</span></a>
<a class="sourceLine" id="cb164-14" data-line-number="14"><span class="ot">    * In a stmt of an interactive GHCi command: print it</span></a></code></pre></div>
<p>Everything seems to be causing errors! That’s because there are no functions that we can use on our values with. Let’s write some. Make a new file called <code>invitationResponseFunctions.hs</code>.</p>
<div class="sourceCode" id="cb165"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb165-1" data-line-number="1"><span class="co">-- invitationResponseFunctions.hs</span></a>
<a class="sourceLine" id="cb165-2" data-line-number="2"><span class="kw">data</span> <span class="dt">InvitationResponse</span> <span class="fu">=</span> <span class="dt">Attending</span> <span class="fu">|</span> <span class="dt">NotAttending</span> <span class="fu">|</span> <span class="dt">MightAttend</span></a>
<a class="sourceLine" id="cb165-3" data-line-number="3"></a>
<a class="sourceLine" id="cb165-4" data-line-number="4"><span class="co">-- We should write a function to check to see if two InvitationResponse values are equal.</span></a>
<a class="sourceLine" id="cb165-5" data-line-number="5"><span class="co">-- By &quot;equal&quot; we mean the same. So two InvitationResponse values are equal if they&#39;re both Attending, NotAttending, or MightAttend.</span></a>
<a class="sourceLine" id="cb165-6" data-line-number="6"><span class="co">-- For that, we&#39;ll use pattern matching.</span></a>
<a class="sourceLine" id="cb165-7" data-line-number="7"><span class="co">-- We&#39;ll also put the name of the function in the middle of the two arguments, for greater readability. This is allowed because when you put ` backticks around a function, it becomes an infix function.</span></a>
<a class="sourceLine" id="cb165-8" data-line-number="8"><span class="ot">invitationResponseIsEqual ::</span> <span class="dt">InvitationResponse</span> <span class="ot">-&gt;</span> <span class="dt">InvitationResponse</span> <span class="ot">-&gt;</span> <span class="dt">Bool</span></a>
<a class="sourceLine" id="cb165-9" data-line-number="9"><span class="dt">Attending</span> <span class="ot">`invitationResponseIsEqual`</span> <span class="dt">Attending</span> <span class="fu">=</span> <span class="dt">True</span>        <span class="co">-- If both inputs are Attending, return True.</span></a>
<a class="sourceLine" id="cb165-10" data-line-number="10"><span class="dt">NotAttending</span> <span class="ot">`invitationResponseIsEqual`</span> <span class="dt">NotAttending</span> <span class="fu">=</span> <span class="dt">True</span>  <span class="co">-- If both inputs are NotAttending, return True.</span></a>
<a class="sourceLine" id="cb165-11" data-line-number="11"><span class="dt">MightAttend</span> <span class="ot">`invitationResponseIsEqual`</span> <span class="dt">MightAttend</span> <span class="fu">=</span> <span class="dt">True</span>    <span class="co">-- If both inputs are MightAttend, return True.</span></a>
<a class="sourceLine" id="cb165-12" data-line-number="12">_ <span class="ot">`invitationResponseIsEqual`</span> _ <span class="fu">=</span> <span class="dt">False</span>                       <span class="co">-- Otherwise, the two inputs can&#39;t be the same, so return False.</span></a>
<a class="sourceLine" id="cb165-13" data-line-number="13"></a>
<a class="sourceLine" id="cb165-14" data-line-number="14"><span class="co">-- Yes, you can pattern match like that. Let&#39;s make a function that turns </span></a>
<a class="sourceLine" id="cb165-15" data-line-number="15"><span class="co">-- an InvitationResponse and a name into a message to the person who made the invitation.</span></a>
<a class="sourceLine" id="cb165-16" data-line-number="16"></a>
<a class="sourceLine" id="cb165-17" data-line-number="17"><span class="ot">makeMessage ::</span> <span class="dt">String</span> <span class="ot">-&gt;</span> <span class="dt">InvitationResponse</span> <span class="ot">-&gt;</span> <span class="dt">String</span></a>
<a class="sourceLine" id="cb165-18" data-line-number="18">makeMessage name <span class="dt">Attending</span> <span class="fu">=</span> <span class="st">&quot;Yes, &quot;</span> <span class="fu">++</span> name <span class="fu">++</span> <span class="st">&quot; can attend your event!&quot;</span></a>
<a class="sourceLine" id="cb165-19" data-line-number="19">makeMessage name <span class="dt">NotAttending</span> <span class="fu">=</span> <span class="st">&quot;Sorry, &quot;</span> <span class="fu">++</span> name <span class="fu">++</span> <span class="st">&quot; can&#39;t attend your event.&quot;</span></a>
<a class="sourceLine" id="cb165-20" data-line-number="20">makeMessage name <span class="dt">MightAttend</span> <span class="fu">=</span> name <span class="fu">++</span> <span class="st">&quot; might attend your event.&quot;</span></a></code></pre></div>
<p>Now let’s load this into GHCi and play with it. To save time, we’ll use <code>:l</code> instead of <code>:load</code></p>
<div class="sourceCode" id="cb166"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb166-1" data-line-number="1"><span class="dt">Prelude</span><span class="fu">&gt;</span> <span class="fu">:</span>l invitationResponseFunctions<span class="fu">.</span>hs </a>
<a class="sourceLine" id="cb166-2" data-line-number="2">[<span class="dv">1</span> <span class="kw">of</span> <span class="dv">1</span>] <span class="dt">Compiling</span> <span class="dt">Main</span> ( invitationResponseFunctions<span class="fu">.</span>hs, interpreted )</a>
<a class="sourceLine" id="cb166-3" data-line-number="3"><span class="dt">Ok</span>, one <span class="kw">module</span> loaded<span class="fu">.</span></a>
<a class="sourceLine" id="cb166-4" data-line-number="4"><span class="fu">*</span><span class="dt">Main</span><span class="fu">&gt;</span> bob <span class="fu">=</span> <span class="st">&quot;Bob Vance&quot;</span></a>
<a class="sourceLine" id="cb166-5" data-line-number="5"><span class="fu">*</span><span class="dt">Main</span><span class="fu">&gt;</span> bobsResponse <span class="fu">=</span> <span class="dt">NotAttending</span></a>
<a class="sourceLine" id="cb166-6" data-line-number="6"><span class="fu">*</span><span class="dt">Main</span><span class="fu">&gt;</span> bobsResponse <span class="ot">`invitationResponseIsEqual`</span> <span class="dt">Attending</span></a>
<a class="sourceLine" id="cb166-7" data-line-number="7"><span class="dt">False</span></a>
<a class="sourceLine" id="cb166-8" data-line-number="8"><span class="fu">*</span><span class="dt">Main</span><span class="fu">&gt;</span> bobsResponse <span class="ot">`invitationResponseIsEqual`</span> <span class="dt">NotAttending</span></a>
<a class="sourceLine" id="cb166-9" data-line-number="9"><span class="dt">True</span></a>
<a class="sourceLine" id="cb166-10" data-line-number="10"><span class="fu">*</span><span class="dt">Main</span><span class="fu">&gt;</span> makeMessage bob bobsResponse</a>
<a class="sourceLine" id="cb166-11" data-line-number="11"><span class="st">&quot;Sorry, Bob Vance can&#39;t attend your event.&quot;</span></a></code></pre></div>
<p>But we still can’t use <code>==</code> with our data type. That’d be a lot better than using <code>invitationResponseIsEqual</code>. Think back to the chapter on typeclasses. Do you remember the <code>Eq</code> typeclass? It contains the functions <code>==</code> and <code>/=</code>. To be able to use those, we have to somehow declare that <code>InvitationResponse</code> is a member, or <em>instance</em>, of the <code>Eq</code> typeclass. To do that, we need to define <code>==</code><label for="marginnote-50" class="margin-toggle">⊕</label> <input type="checkbox" id="marginnote-50" class="margin-toggle"/> <span class="marginnote">We get ‘/=’ for free because <code>Eq</code> has it defined as <code>x /= y = not (x == y)</code> by default, so once you have <code>==</code> Haskell can define <code>/=</code> on its own.</span>. Here’s how we do that.</p>
<div class="sourceCode" id="cb167"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb167-1" data-line-number="1"><span class="co">-- invitationResponseFunctionsBetter.hs</span></a>
<a class="sourceLine" id="cb167-2" data-line-number="2"><span class="kw">data</span> <span class="dt">InvitationResponse</span> <span class="fu">=</span> <span class="dt">Attending</span> <span class="fu">|</span> <span class="dt">NotAttending</span> <span class="fu">|</span> <span class="dt">MightAttend</span></a>
<a class="sourceLine" id="cb167-3" data-line-number="3"></a>
<a class="sourceLine" id="cb167-4" data-line-number="4"><span class="kw">instance</span> <span class="dt">Eq</span> <span class="dt">InvitationResponse</span> <span class="kw">where</span></a>
<a class="sourceLine" id="cb167-5" data-line-number="5">    <span class="dt">Attending</span> <span class="fu">==</span> <span class="dt">Attending</span> <span class="fu">=</span> <span class="dt">True</span>        <span class="co">-- If both inputs are Attending, return True.</span></a>
<a class="sourceLine" id="cb167-6" data-line-number="6">    <span class="dt">NotAttending</span> <span class="fu">==</span> <span class="dt">NotAttending</span> <span class="fu">=</span> <span class="dt">True</span>  <span class="co">-- If both inputs are NotAttending, return True.</span></a>
<a class="sourceLine" id="cb167-7" data-line-number="7">    <span class="dt">MightAttend</span> <span class="fu">==</span> <span class="dt">MightAttend</span> <span class="fu">=</span> <span class="dt">True</span>    <span class="co">-- If both inputs are MightAttend, return True.</span></a>
<a class="sourceLine" id="cb167-8" data-line-number="8">    _ <span class="fu">==</span> _ <span class="fu">=</span> <span class="dt">False</span>                       <span class="co">-- Otherwise, the two inputs can&#39;t be the same, so return False.</span></a>
<a class="sourceLine" id="cb167-9" data-line-number="9"></a>
<a class="sourceLine" id="cb167-10" data-line-number="10"><span class="co">-- functions made only of special characters are called operators, and they&#39;re  are infix functions by default. That means so you don&#39;t have to put backticks around them, and can put them in the middle for definitions.</span></a></code></pre></div>
<p>Let’s take a closer look at what’s going on there.</p>
<div class="sourceCode" id="cb168"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb168-1" data-line-number="1">  <span class="kw">instance</span> <span class="dt">Eq</span> <span class="dt">InvitationResponse</span> <span class="kw">where</span></a>
<a class="sourceLine" id="cb168-2" data-line-number="2"><span class="co">--   [1]   [2]       [3]          [4]</span></a></code></pre></div>
<ol type="1">
<li><p><code>instance</code>: This is how we tell Haskell that we’re saying a type is an instance of a typeclass</p></li>
<li><p><code>Eq</code>: This is the typeclass we’re making <code>InvitationResponse</code> an instance of.</p></li>
<li><p><code>InvitationResponse</code>: This is the typeclass we’re making an instance of <code>Eq</code>.</p></li>
<li><p><code>where</code>: This is the same <code>where</code> you see in function definitions, it means there’s going to be bindings soon (bindings are things like <code>i = 3</code>, they’re values bound to names).</p></li>
</ol>
<p>After <code>instance Eq InvitationResponse where</code>, we have our definition of <code>==</code>. Let’s can import this and test it out, just to prove it works.</p>
<div class="sourceCode" id="cb169"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb169-1" data-line-number="1"><span class="fu">*</span><span class="dt">Main</span><span class="fu">&gt;</span> <span class="fu">:</span>l invitationResponseFunctionsBetter<span class="fu">.</span>hs</a>
<a class="sourceLine" id="cb169-2" data-line-number="2">[<span class="dv">1</span> <span class="kw">of</span> <span class="dv">1</span>] <span class="dt">Compiling</span> <span class="dt">Main</span> ( invitationResponseFunctionsBetter<span class="fu">.</span>hs, interpreted )</a>
<a class="sourceLine" id="cb169-3" data-line-number="3"><span class="dt">Ok</span>, one <span class="kw">module</span> loaded<span class="fu">.</span></a>
<a class="sourceLine" id="cb169-4" data-line-number="4"><span class="fu">*</span><span class="dt">Main</span><span class="fu">&gt;</span> <span class="dt">Attending</span> <span class="fu">==</span> <span class="dt">Attending</span></a>
<a class="sourceLine" id="cb169-5" data-line-number="5"><span class="dt">True</span></a></code></pre></div>
<p>But this is bad. It’s a lot of repetitive typing you’d have to do every time. In software this is called <em>boilerplate</em>. Fortunately, Haskell has a built-in way to automatically <em>derive</em> <code>Eq</code> for us, if we tell it to, using the <code>deriving</code> keyword<label for="sidenote-41" class="margin-toggle sidenote-number"></label> <input type="checkbox" id="sidenote-41" class="margin-toggle"/> <span class="sidenote">Imagine if you had to do that manually for every data type you made! Haskell gets some criticism of being “for academics”, but I find it’s usually quite practical.</span>. Let’s redefine <code>InvitationResponse</code> to use it.</p>
<div class="sourceCode" id="cb170"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb170-1" data-line-number="1"><span class="dt">Prelude</span><span class="fu">&gt;</span> <span class="kw">data</span> <span class="dt">InvitationResponse</span> <span class="fu">=</span> <span class="dt">Attending</span> <span class="fu">|</span> <span class="dt">NotAttending</span> <span class="fu">|</span> <span class="dt">MightAttend</span> <span class="kw">deriving</span> (<span class="dt">Eq</span>)</a>
<a class="sourceLine" id="cb170-2" data-line-number="2"><span class="dt">Prelude</span><span class="fu">&gt;</span> <span class="dt">Attending</span> <span class="fu">==</span> <span class="dt">Attending</span></a>
<a class="sourceLine" id="cb170-3" data-line-number="3"><span class="dt">True</span></a></code></pre></div>
<p>That’s much better. We should also add <code>Show</code> and <code>Read</code>, because they make sense here<label for="sidenote-42" class="margin-toggle sidenote-number"></label> <input type="checkbox" id="sidenote-42" class="margin-toggle"/> <span class="sidenote">The typeclasses you can automatically derive are <code>Eq</code>, <code>Ord</code>, <code>Enum</code>, <code>Bounded</code>, <code>Show</code>, and <code>Read</code>.</span>.</p>
<div class="sourceCode" id="cb171"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb171-1" data-line-number="1"><span class="dt">Prelude</span><span class="fu">&gt;</span> <span class="kw">data</span> <span class="dt">InvitationResponse</span> <span class="fu">=</span> <span class="dt">Attending</span> <span class="fu">|</span> <span class="dt">NotAttending</span> <span class="fu">|</span> <span class="dt">MightAttend</span> <span class="kw">deriving</span> (<span class="dt">Eq</span>, <span class="dt">Show</span>, <span class="dt">Read</span>)</a>
<a class="sourceLine" id="cb171-2" data-line-number="2"><span class="dt">Prelude</span><span class="fu">&gt;</span> show <span class="dt">Attending</span></a>
<a class="sourceLine" id="cb171-3" data-line-number="3"><span class="st">&quot;Attending&quot;</span></a>
<a class="sourceLine" id="cb171-4" data-line-number="4"><span class="dt">Prelude</span><span class="fu">&gt;</span> read <span class="st">&quot;Attending&quot;</span><span class="ot"> ::</span> <span class="dt">InvitationResponse</span></a>
<a class="sourceLine" id="cb171-5" data-line-number="5"><span class="dt">Attending</span></a></code></pre></div>
<p>As you might expect, we can also create our own typeclasses, but I’ll discuss that later.</p>
<h2 id="data-types-with-other-values">Data Types With Other Values</h2>
<p><span class="newthought">Some of</span> our data types need to be more complex. Sometimes they need to contain other values. This seems strange, but will be clear after a quick demonstration.</p>
<div class="sourceCode" id="cb172"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb172-1" data-line-number="1"><span class="dt">Prelude</span><span class="fu">&gt;</span> <span class="kw">data</span> <span class="dt">Color</span> <span class="fu">=</span> <span class="dt">White</span> <span class="fu">|</span> <span class="dt">Black</span> <span class="fu">|</span> <span class="dt">Red</span> <span class="fu">|</span> <span class="dt">Green</span> <span class="fu">|</span> <span class="dt">Blue</span> <span class="kw">deriving</span> (<span class="dt">Eq</span>, <span class="dt">Show</span>)</a>
<a class="sourceLine" id="cb172-2" data-line-number="2"><span class="dt">Prelude</span><span class="fu">&gt;</span> <span class="kw">data</span> <span class="dt">Residence</span> <span class="fu">=</span> <span class="dt">House</span> <span class="dt">Color</span> <span class="fu">|</span> <span class="dt">Apartment</span> <span class="kw">deriving</span> (<span class="dt">Eq</span>, <span class="dt">Show</span>)</a>
<a class="sourceLine" id="cb172-3" data-line-number="3"><span class="dt">Prelude</span><span class="fu">&gt;</span> <span class="dt">House</span> <span class="dt">White</span></a>
<a class="sourceLine" id="cb172-4" data-line-number="4"><span class="dt">House</span> <span class="dt">White</span></a></code></pre></div>
<p>We define two data types here. The first is the type <code>Color</code>, which can have the value <code>White</code>, <code>Black</code>, <code>Red</code>, <code>Green</code>, or <code>Blue</code>. We also make the type <code>Residence</code>, which can either be a <code>House</code> or an <code>Apartment</code>. In addition, if it’s a <code>House</code>, it contains a value of type <code>Color</code><label for="sidenote-43" class="margin-toggle sidenote-number"></label> <input type="checkbox" id="sidenote-43" class="margin-toggle"/> <span class="sidenote">This means any time we have a <code>House</code>, it also has to have an associated <code>Color</code>.</span>. Let’s see this in action:</p>
<div class="sourceCode" id="cb173"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb173-1" data-line-number="1"><span class="dt">Prelude</span><span class="fu">&gt;</span> <span class="kw">data</span> <span class="dt">Color</span> <span class="fu">=</span> <span class="dt">White</span> <span class="fu">|</span> <span class="dt">Black</span> <span class="fu">|</span> <span class="dt">Red</span> <span class="fu">|</span> <span class="dt">Green</span> <span class="fu">|</span> <span class="dt">Blue</span> <span class="kw">deriving</span> (<span class="dt">Eq</span>, <span class="dt">Show</span>)</a>
<a class="sourceLine" id="cb173-2" data-line-number="2"><span class="dt">Prelude</span><span class="fu">&gt;</span> <span class="kw">data</span> <span class="dt">Residence</span> <span class="fu">=</span> <span class="dt">House</span> <span class="dt">Color</span> <span class="fu">|</span> <span class="dt">Apartment</span> <span class="kw">deriving</span> (<span class="dt">Eq</span>, <span class="dt">Show</span>)</a>
<a class="sourceLine" id="cb173-3" data-line-number="3"></a>
<a class="sourceLine" id="cb173-4" data-line-number="4"><span class="co">-- My friend lives in an apartment.</span></a>
<a class="sourceLine" id="cb173-5" data-line-number="5"><span class="dt">Prelude</span><span class="fu">&gt;</span> myFriendsResidence <span class="fu">=</span> <span class="dt">Apartment</span></a>
<a class="sourceLine" id="cb173-6" data-line-number="6"></a>
<a class="sourceLine" id="cb173-7" data-line-number="7"><span class="co">-- I painted my house green, because it&#39;s my favorite color.</span></a>
<a class="sourceLine" id="cb173-8" data-line-number="8"><span class="dt">Prelude</span><span class="fu">&gt;</span> myFavoriteColor <span class="fu">=</span> <span class="dt">Green</span></a>
<a class="sourceLine" id="cb173-9" data-line-number="9"><span class="dt">Prelude</span><span class="fu">&gt;</span> myResidence <span class="fu">=</span> <span class="dt">House</span> myFavoriteColor</a>
<a class="sourceLine" id="cb173-10" data-line-number="10"></a>
<a class="sourceLine" id="cb173-11" data-line-number="11"><span class="dt">Prelude</span><span class="fu">&gt;</span> myResidence</a>
<a class="sourceLine" id="cb173-12" data-line-number="12"><span class="dt">House</span> <span class="dt">Green</span></a>
<a class="sourceLine" id="cb173-13" data-line-number="13"><span class="dt">Prelude</span><span class="fu">&gt;</span> myFriendsResidence</a>
<a class="sourceLine" id="cb173-14" data-line-number="14"><span class="dt">Apartment</span></a>
<a class="sourceLine" id="cb173-15" data-line-number="15"></a>
<a class="sourceLine" id="cb173-16" data-line-number="16"><span class="co">-- We can even have a little fun with it.</span></a>
<a class="sourceLine" id="cb173-17" data-line-number="17"><span class="dt">Prelude</span><span class="fu">&gt;</span> potusHouse <span class="fu">=</span> <span class="dt">House</span> <span class="dt">White</span></a>
<a class="sourceLine" id="cb173-18" data-line-number="18"></a>
<a class="sourceLine" id="cb173-19" data-line-number="19"><span class="co">-- myResidence, myFriendsResidence, and potusHouse are all of type Residence</span></a>
<a class="sourceLine" id="cb173-20" data-line-number="20"><span class="dt">Prelude</span><span class="fu">&gt;</span> <span class="fu">:</span>t myResidence</a>
<a class="sourceLine" id="cb173-21" data-line-number="21"><span class="ot">myResidence ::</span> <span class="dt">Residence</span></a></code></pre></div>
<p><span class="newthought">This seems</span> like a good time to introduce some new terminology.</p>
<ol type="1">
<li><p>Type constructors: When you write <code>data Color = [...]</code> or <code>data Residence = [...]</code>, that’s you declaring <code>Color</code> or <code>Residence</code> as a <em>type constructor</em><label for="sidenote-44" class="margin-toggle sidenote-number"></label> <input type="checkbox" id="sidenote-44" class="margin-toggle"/> <span class="sidenote">In this case, a type constructor that takes no parameters. Since it takes no parameters, we usually just call it a type. We’ll discuss type constructors that take parameters later in this chapter.</span>. Anywhere that Haskell expects a type, you can pass it <code>Color</code> or <code>Residence</code>. For example, if you had a function called <code>houseAppraisal</code> that takes a <code>Residence</code> and returns a number representing its value, it’s type signature could be <code>houseAppraisal :: (Num a) =&gt; Residence -&gt; a</code>. <code>Residence</code> here is a type constructor, but we’d usually just call it a type.</p></li>
<li><p>Data constructors: On the other hand, when you write <code>White | Black | Red | Green | Blue</code> or <code>Home Color | Apartment</code>, you’re defining <em>data constructors</em>. These are functions and can be used in expressions or pattern matching. For example, the function <code>warmInSummer (Home Black) = True</code>. Here, <code>Home</code> is a data constructor that takes one argument<label for="marginnote-51" class="margin-toggle">⊕</label> <input type="checkbox" id="marginnote-51" class="margin-toggle"/> <span class="marginnote">A data constructor that takes one argument is called a <em>unary</em> data constructor.</span>, and <code>Apartment</code> is a data constructor that doesn’t take any arguments either.<label for="marginnote-52" class="margin-toggle">⊕</label> <input type="checkbox" id="marginnote-52" class="margin-toggle"/> <span class="marginnote">Data constructors are sometimes also called <em>value constructors</em>.</span>.</p></li>
</ol>
<p>Data constructors can take as many data parameters as you want. Let’s write a <code>SongInfo</code> data type which stores a <code>Song</code>, with a <code>String</code> for the name of the song, a <code>String</code> for the artist, and a <code>Float</code> for the length of the song.</p>
<div class="sourceCode" id="cb174"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb174-1" data-line-number="1"><span class="dt">Prelude</span><span class="fu">&gt;</span> <span class="kw">data</span> <span class="dt">SongInfo</span> <span class="fu">=</span> <span class="dt">Song</span> <span class="dt">String</span> <span class="dt">String</span> <span class="dt">Float</span> <span class="kw">deriving</span> (<span class="dt">Show</span>)</a>
<a class="sourceLine" id="cb174-2" data-line-number="2"><span class="dt">Prelude</span><span class="fu">&gt;</span> <span class="dt">Song</span> <span class="st">&quot;Dirty Diana&quot;</span> <span class="st">&quot;Michael Jackson&quot;</span> <span class="fl">4.47</span></a>
<a class="sourceLine" id="cb174-3" data-line-number="3"><span class="dt">Song</span> <span class="st">&quot;Dirty Diana&quot;</span> <span class="st">&quot;Michael Jackson&quot;</span> <span class="fl">4.47</span></a></code></pre></div>
<hr />
<p><strong><strong><em>Exercises</em></strong></strong>:</p>
<ol type="1">
<li><p>Write a data type that has the possible values <code>A</code>, <code>B</code>, <code>C</code>, <code>D</code>, and <code>None</code>, that you might use to store the user’s answer if you were writing a program to administer multiple choice tests.</p></li>
<li><p>Write some data types used to store information about a car. You should have one data type for <code>Make</code> (<code>Honda</code>, <code>Toyota</code>, <code>GM</code>, or <code>Tesla</code>) and one for <code>EngineCylinders</code> (<code>Four</code>, <code>Six</code>, and <code>N/A</code>). Then make a data type <code>CarInfo</code> which stores the <code>Make</code> and the <code>EngineCylinders</code>, plus a <code>String</code> representing the name of the owner. Don’t forget to add <code>deriving (Show)</code>! This may seem difficult but once you’ve done it, it won’t seem bad at all.</p></li>
</ol>
<hr />
<p><span class="newthought">Since type</span> constructors and data constructors are always used in different places, Haskell allows you to have a data constructor with the same name as a type constructor. Take this somewhat useless type:</p>
<div class="sourceCode" id="cb175"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb175-1" data-line-number="1"><span class="kw">data</span> <span class="dt">Bob</span> <span class="fu">=</span> <span class="dt">Bob</span></a></code></pre></div>
<p>This makes a new data type, <code>Bob</code>, with one possible value, <code>Bob</code>. There’s not really a good reason to make this type, but Haskell will still allow you to. <code>Bob</code> the data constructor takes no arguments, so it is sometimes called <em>nullary</em> or <em>constant</em>. Compare it to <code>House</code> earlier, which took a <code>Color</code> as an argument.</p>
<p>You can also use regular types as parameters. Let’s make a <code>Person</code> type, with a <code>String</code> for his name.</p>
<div class="sourceCode" id="cb176"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb176-1" data-line-number="1"><span class="dt">Prelude</span><span class="fu">&gt;</span> <span class="kw">data</span> <span class="dt">Person</span> <span class="fu">=</span> <span class="dt">Person</span> <span class="dt">String</span> <span class="kw">deriving</span> (<span class="dt">Eq</span>, <span class="dt">Show</span>)</a>
<a class="sourceLine" id="cb176-2" data-line-number="2"><span class="dt">Prelude</span><span class="fu">&gt;</span> <span class="dt">Person</span> <span class="st">&quot;Andy&quot;</span></a>
<a class="sourceLine" id="cb176-3" data-line-number="3"><span class="dt">Person</span> <span class="st">&quot;Andy&quot;</span></a></code></pre></div>
<p>It’d also be useful to have a function that can extract the name from a <code>Person</code>. Let’s write one using pattern matching.</p>
<div class="sourceCode" id="cb177"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb177-1" data-line-number="1"><span class="dt">Prelude</span><span class="fu">&gt;</span> getName (<span class="dt">Person</span> name) <span class="fu">=</span> name</a>
<a class="sourceLine" id="cb177-2" data-line-number="2"><span class="dt">Prelude</span><span class="fu">&gt;</span> getName (<span class="dt">Person</span> <span class="st">&quot;andy&quot;</span>)</a>
<a class="sourceLine" id="cb177-3" data-line-number="3"><span class="st">&quot;andy&quot;</span></a></code></pre></div>
<p>I bet you’re beginning to see by now how important pattern matching is in Haskell! But we don’t actually have to write the <code>getName</code> function yourself, that would be a bit silly. Haskell has a way for you to write a name for each parameter represents, and create the necessary functions automatically. This is called <em>record syntax</em>.</p>
<div class="sourceCode" id="cb178"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb178-1" data-line-number="1"><span class="dt">Prelude</span><span class="fu">&gt;</span> <span class="kw">data</span> <span class="dt">Person</span> <span class="fu">=</span> <span class="dt">Person</span> {<span class="ot"> firstName ::</span> <span class="dt">String</span>,<span class="ot"> lastName ::</span> <span class="dt">String</span> } <span class="kw">deriving</span> (<span class="dt">Eq</span>, <span class="dt">Show</span>)</a>
<a class="sourceLine" id="cb178-2" data-line-number="2"><span class="dt">Prelude</span><span class="fu">&gt;</span> jDoe <span class="fu">=</span> <span class="dt">Person</span> <span class="st">&quot;John&quot;</span> <span class="st">&quot;Doe&quot;</span></a>
<a class="sourceLine" id="cb178-3" data-line-number="3"><span class="dt">Prelude</span><span class="fu">&gt;</span> jDoe</a>
<a class="sourceLine" id="cb178-4" data-line-number="4"><span class="dt">Person</span> {firstName <span class="fu">=</span> <span class="st">&quot;John&quot;</span>, lastName <span class="fu">=</span> <span class="st">&quot;Doe&quot;</span>}</a>
<a class="sourceLine" id="cb178-5" data-line-number="5"><span class="dt">Prelude</span><span class="fu">&gt;</span> firstName jDoe</a>
<a class="sourceLine" id="cb178-6" data-line-number="6"><span class="st">&quot;John&quot;</span></a>
<a class="sourceLine" id="cb178-7" data-line-number="7"><span class="dt">Prelude</span><span class="fu">&gt;</span> lastName jDoe</a>
<a class="sourceLine" id="cb178-8" data-line-number="8"><span class="st">&quot;Doe&quot;</span></a></code></pre></div>
<p>Let me break down record syntax. I’ll isolate just the data constructor, because that’s the interesting part.</p>
<div class="sourceCode" id="cb179"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb179-1" data-line-number="1">   <span class="dt">Person</span>   {<span class="ot">   firstName ::</span> <span class="dt">String</span>,<span class="ot"> lastName ::</span> <span class="dt">String</span>    } </a>
<a class="sourceLine" id="cb179-2" data-line-number="2"><span class="co">--   [1]   [2]    [3]          [4]     [5]         [6]    [7] </span></a></code></pre></div>
<ol type="1">
<li><p><code>Person</code>: You can think of this as the name of this specific data constructor<label for="sidenote-45" class="margin-toggle sidenote-number"></label> <input type="checkbox" id="sidenote-45" class="margin-toggle"/> <span class="sidenote">Which of course, is exactly what it is. A data constructor is a function and this one’s name is <code>Person</code>. Data constructors are the exception to the rule that functions must begin with a lowercase letter, as they must also begin with an uppercase letter.</span>.</p></li>
<li><p><code>{</code>: This is to indicate that we’re annotating the types for this data constructor with names using record syntax.</p></li>
<li><p><code>firstName</code>: This is the name of the first parameter to the data constructor.</p></li>
<li><p><code>String</code>: This is the type that corresponds to the name <code>firstName</code>.</p></li>
<li><p><code>lastName</code>: This is the name of the second parameter to the data constructor.</p></li>
<li><p><code>String</code>: This is the type that corresponds to the name <code>lastName</code>.</p></li>
<li><p><code>}</code>: This indicates we’re done with this data constructor and record syntax.</p></li>
</ol>
<p>Haskell then automatically makes <code>firstName</code> and <code>lastName</code> functions, which take a <code>Person</code> and return that value<label for="sidenote-46" class="margin-toggle sidenote-number"></label> <input type="checkbox" id="sidenote-46" class="margin-toggle"/> <span class="sidenote">Again, this is purely for convenience, as you could write all these functions yourself.</span>.</p>
<p>You’ll notice that <code>firstName :: String</code> and <code>lastName :: String</code> are just regular type signatures. But be careful, <code>firstName :: String</code> isn’t the type signature of the <code>firstName</code> function that’s created, it’s the type signature of what that function returns (in our case, a <code>String</code>)<label for="marginnote-53" class="margin-toggle">⊕</label> <input type="checkbox" id="marginnote-53" class="margin-toggle"/> <span class="marginnote">Note that you can’t have multiple records with the same name, even in different data types. So this is not allowed:</p>
<pre><code>```haskell
data Human = Human {name :: String}
data Dog = Dog {name :: String}
```</code></pre>
<p>This is because <code>name</code> is a function, just one that’s automatically written for us. It takes a <code>Human</code> and returns a <code>String</code>, so it can’t take a <code>Dog</code> and return a <code>String</code>. This is a limitation enforced by Haskell’s type system. If this irritates you, in a later chapter I will discuss <a href="https://downloads.haskell.org/~ghc/master/users-guide/glasgow_exts.html#duplicate-record-fields">a GHC feature</a> that loosens this restriction.</span></p>
<h2 id="type-aliases">Type Aliases</h2>
<p><span class="newthought">The</span> <code>type</code> keyword makes an <em>alias</em> of a data type<label for="sidenote-47" class="margin-toggle sidenote-number"></label> <input type="checkbox" id="sidenote-47" class="margin-toggle"/> <span class="sidenote">also called a <em>type synonym</em></span>. That just means it takes a data type and makes a new name for it. Remember how instead of writing <code>[Char]</code>, you can write <code>String</code>? That’s done with the <code>type</code> keyword.</p>
<div class="sourceCode" id="cb181"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb181-1" data-line-number="1"><span class="kw">type</span> <span class="dt">String</span> <span class="fu">=</span> [<span class="dt">Char</span>]  </a></code></pre></div>
<p>It doesn’t make a new type, just a new name for an existing type<label for="marginnote-54" class="margin-toggle">⊕</label> <input type="checkbox" id="marginnote-54" class="margin-toggle"/> <span class="marginnote">Although unfortunately in error messages GHC will use the original names and not your synonyms.</span>. It’s just to make our functions easier to read.</p>
<div class="sourceCode" id="cb182"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb182-1" data-line-number="1"><span class="co">-- Compare this:</span></a>
<a class="sourceLine" id="cb182-2" data-line-number="2"><span class="dt">Prelude</span><span class="fu">&gt;</span> p1 <span class="fu">=</span> (<span class="dv">3</span>, <span class="dv">3</span>)<span class="ot"> ::</span> (<span class="dt">Double</span>, <span class="dt">Double</span>)</a>
<a class="sourceLine" id="cb182-3" data-line-number="3"><span class="dt">Prelude</span><span class="fu">&gt;</span> p2 <span class="fu">=</span> (<span class="dv">10</span>, <span class="fu">-</span><span class="dv">1</span>)<span class="ot"> ::</span> (<span class="dt">Double</span>, <span class="dt">Double</span>)</a>
<a class="sourceLine" id="cb182-4" data-line-number="4"></a>
<a class="sourceLine" id="cb182-5" data-line-number="5"><span class="co">-- To this:</span></a>
<a class="sourceLine" id="cb182-6" data-line-number="6"><span class="dt">Prelude</span><span class="fu">&gt;</span> <span class="kw">type</span> <span class="dt">Point</span> <span class="fu">=</span> (<span class="dt">Double</span>, <span class="dt">Double</span>)</a>
<a class="sourceLine" id="cb182-7" data-line-number="7"><span class="dt">Prelude</span><span class="fu">&gt;</span> p1 <span class="fu">=</span> (<span class="dv">3</span>, <span class="dv">3</span>)<span class="ot"> ::</span> <span class="dt">Point</span></a>
<a class="sourceLine" id="cb182-8" data-line-number="8"><span class="dt">Prelude</span><span class="fu">&gt;</span> p2 <span class="fu">=</span> (<span class="dv">10</span>, <span class="fu">-</span><span class="dv">1</span>)<span class="ot"> ::</span> <span class="dt">Point</span></a></code></pre></div>
<p>Regular types can quickly get hard to manage, but with type aliases, that’s somewhat avoided<label for="sidenote-48" class="margin-toggle sidenote-number"></label> <input type="checkbox" id="sidenote-48" class="margin-toggle"/> <span class="sidenote">This example is based off a problem I had from before I knew about type aliases. As you can imagine, seeing <code>[[(Double, Double)]]</code> everywhere got pretty confusing.</span>.</p>
<div class="sourceCode" id="cb183"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb183-1" data-line-number="1"><span class="dt">Prelude</span><span class="fu">&gt;</span> <span class="kw">type</span> <span class="dt">Point</span> <span class="fu">=</span> (<span class="dt">Double</span>, <span class="dt">Double</span>)</a>
<a class="sourceLine" id="cb183-2" data-line-number="2"><span class="dt">Prelude</span><span class="fu">&gt;</span> <span class="kw">type</span> <span class="dt">Path</span> <span class="fu">=</span> [<span class="dt">Point</span>]</a>
<a class="sourceLine" id="cb183-3" data-line-number="3"><span class="dt">Prelude</span><span class="fu">&gt;</span> <span class="kw">type</span> <span class="dt">Polygon</span> <span class="fu">=</span> <span class="dt">Path</span></a>
<a class="sourceLine" id="cb183-4" data-line-number="4"><span class="dt">Prelude</span><span class="fu">&gt;</span> <span class="kw">type</span> <span class="dt">ComplexPolygon</span> <span class="fu">=</span> [<span class="dt">Polygon</span>]</a></code></pre></div>
<h2 id="parameterized-types">Parameterized Types</h2>
<p><span class="newthought">Some types</span> aren’t really their own types, they’re like modifications of other types. Let me explain. In the past, we’ve always seen data declarations like this:</p>
<div class="sourceCode" id="cb184"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb184-1" data-line-number="1"><span class="dt">Prelude</span><span class="fu">&gt;</span> <span class="kw">data</span> <span class="dt">Color</span> <span class="fu">=</span> <span class="dt">White</span> <span class="fu">|</span> <span class="dt">Black</span> <span class="fu">|</span> <span class="dt">Red</span> <span class="fu">|</span> <span class="dt">Green</span> <span class="fu">|</span> <span class="dt">Blue</span> </a>
<a class="sourceLine" id="cb184-2" data-line-number="2"><span class="dt">Prelude</span><span class="fu">&gt;</span> <span class="kw">data</span> <span class="dt">Residence</span> <span class="fu">=</span> <span class="dt">House</span> <span class="dt">Color</span> <span class="fu">|</span> <span class="dt">Apartment</span> </a></code></pre></div>
<p>Here, <code>House</code> is a data constructor<label for="sidenote-49" class="margin-toggle sidenote-number"></label> <input type="checkbox" id="sidenote-49" class="margin-toggle"/> <span class="sidenote">Which, remember, is a function.</span> that takes one argument of type <code>Color</code>. It then returns a value of type <code>Residence</code>. <code>Apartment</code> is also a data constructor, which takes no arguments and returns a value of type <code>Residence</code>. <code>White</code>, <code>Black</code>, <code>Red</code>, <code>Green</code>, and <code>Blue</code> are all data constructors that take no parameters and return a value of type <code>Color</code>.</p>
<div class="sourceCode" id="cb185"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb185-1" data-line-number="1"><span class="dt">Prelude</span><span class="fu">&gt;</span> <span class="fu">:</span>t <span class="dt">House</span></a>
<a class="sourceLine" id="cb185-2" data-line-number="2"><span class="dt">House</span><span class="ot"> ::</span> <span class="dt">Color</span> <span class="ot">-&gt;</span> <span class="dt">Residence</span></a></code></pre></div>
<p>See? <code>House</code> is a function that takes a color, and returns a <code>Residence</code><label for="marginnote-55" class="margin-toggle">⊕</label> <input type="checkbox" id="marginnote-55" class="margin-toggle"/> <span class="marginnote"><code>House</code> on its own is <em>not</em> a residence, but <code>House Green</code> is.</span>. But what I didn’t tell you back then is that type constructors can take parameters, too<label for="marginnote-56" class="margin-toggle">⊕</label> <input type="checkbox" id="marginnote-56" class="margin-toggle"/> <span class="marginnote">These are called <em>parameterized types</em> or <em>parameterized type constructors</em>.</span>. Except their parameters aren’t values, they’re other types! The most common example is probably the type constructor <code>Maybe</code>. Here’s how it’s defined:</p>
<div class="sourceCode" id="cb186"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb186-1" data-line-number="1"><span class="kw">data</span> <span class="dt">Maybe</span> a <span class="fu">=</span> <span class="dt">Nothing</span> <span class="fu">|</span> <span class="dt">Just</span> a  </a></code></pre></div>
<p><code>Maybe</code> isn’t a proper type on its own, it’s just a type constructor. It takes a type as a parameter, and then the <code>a</code> in <code>Just a</code> is replaced with that type. Here’s an example. Let’s say you want to make a function that takes two numbers and divides the first by the second. But there’s not really a good answer when the second value is <code>0</code>, because you can’t divide by zero. You could use <code>Maybe</code> to help write that function:</p>
<div class="sourceCode" id="cb187"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb187-1" data-line-number="1"><span class="co">-- maybeDivide.hs</span></a>
<a class="sourceLine" id="cb187-2" data-line-number="2"><span class="ot">maybeDivide ::</span> <span class="dt">Double</span> <span class="ot">-&gt;</span> <span class="dt">Double</span> <span class="ot">-&gt;</span> <span class="dt">Maybe</span> <span class="dt">Double</span> <span class="co">-- Maybe Double is a type. </span></a>
<a class="sourceLine" id="cb187-3" data-line-number="3">                                                <span class="co">-- It&#39;s automatically made from the definition of Maybe a. </span></a>
<a class="sourceLine" id="cb187-4" data-line-number="4">                                                <span class="co">-- It can be Nothing or Just Double.</span></a>
<a class="sourceLine" id="cb187-5" data-line-number="5">maybeDivide _ <span class="dv">0</span> <span class="fu">=</span> <span class="dt">Nothing</span></a>
<a class="sourceLine" id="cb187-6" data-line-number="6">maybeDivide x y <span class="fu">=</span> <span class="dt">Just</span> (x <span class="fu">/</span> y)</a></code></pre></div>
<p>We can load this into GHCi to test it:</p>
<div class="sourceCode" id="cb188"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb188-1" data-line-number="1"><span class="dt">Prelude</span><span class="fu">&gt;</span> <span class="fu">:</span>l maybeDivide<span class="fu">.</span>hs</a>
<a class="sourceLine" id="cb188-2" data-line-number="2">[<span class="dv">1</span> <span class="kw">of</span> <span class="dv">1</span>] <span class="dt">Compiling</span> <span class="dt">Main</span> ( maybeDivide<span class="fu">.</span>hs, interpreted )</a>
<a class="sourceLine" id="cb188-3" data-line-number="3"><span class="dt">Ok</span>, one <span class="kw">module</span> loaded<span class="fu">.</span></a>
<a class="sourceLine" id="cb188-4" data-line-number="4"><span class="fu">*</span><span class="dt">Main</span><span class="fu">&gt;</span> maybeDivide <span class="dv">3</span> <span class="dv">4</span></a>
<a class="sourceLine" id="cb188-5" data-line-number="5"><span class="dt">Just</span> <span class="fl">0.75</span></a>
<a class="sourceLine" id="cb188-6" data-line-number="6"><span class="fu">*</span><span class="dt">Main</span><span class="fu">&gt;</span> maybeDivide <span class="dv">3</span> <span class="dv">0</span></a>
<a class="sourceLine" id="cb188-7" data-line-number="7"><span class="dt">Nothing</span></a></code></pre></div>
<p><code>Maybe</code> isn’t a type, it’s a type constructor. <code>Maybe Double</code> is a type, but you can also call it a <em>concrete type</em><label for="marginnote-57" class="margin-toggle">⊕</label> <input type="checkbox" id="marginnote-57" class="margin-toggle"/> <span class="marginnote">Sometimes people call type constructors like <code>Maybe</code> types, either by accident or by laziness, but they really mean type constructors.</span>. Let’s look at the type of the <code>Just</code> data constructor.</p>
<div class="sourceCode" id="cb189"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb189-1" data-line-number="1"><span class="dt">Prelude</span><span class="fu">&gt;</span> <span class="fu">:</span>t <span class="dt">Just</span></a>
<a class="sourceLine" id="cb189-2" data-line-number="2"><span class="dt">Just</span><span class="ot"> ::</span> a <span class="ot">-&gt;</span> <span class="dt">Maybe</span> a</a></code></pre></div>
<p>It takes a value of type <code>a</code> and returns a value of type <code>Maybe a</code>, where <code>a</code> is a type variable and can be any type<label for="marginnote-58" class="margin-toggle">⊕</label> <input type="checkbox" id="marginnote-58" class="margin-toggle"/> <span class="marginnote">To reiterate, types and values are different things in Haskell. <code>Maybe Double</code> is a type, suitable for use in type signatures. <code>Just 4.5</code> is a value of type <code>Maybe Double</code>. A function whose return type is <code>Maybe Double</code> could return <code>Just 4.5</code>.</span>. Let’s look at some more types:</p>
<div class="sourceCode" id="cb190"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb190-1" data-line-number="1"><span class="dt">Prelude</span><span class="fu">&gt;</span> <span class="fu">:</span>t <span class="dt">Just</span> <span class="st">&quot;hello&quot;</span></a>
<a class="sourceLine" id="cb190-2" data-line-number="2"><span class="dt">Just</span> <span class="st">&quot;hello&quot;</span><span class="ot"> ::</span> <span class="dt">Maybe</span> [<span class="dt">Char</span>]</a>
<a class="sourceLine" id="cb190-3" data-line-number="3"><span class="co">-- Just &quot;hello&quot; returns a value of type Maybe [char]. </span></a>
<a class="sourceLine" id="cb190-4" data-line-number="4"><span class="co">-- This means Just &quot;hello&quot; can be the return value of any function that returns a Maybe [char]</span></a>
<a class="sourceLine" id="cb190-5" data-line-number="5"></a>
<a class="sourceLine" id="cb190-6" data-line-number="6"><span class="dt">Prelude</span><span class="fu">&gt;</span> <span class="fu">:</span>t <span class="dt">Nothing</span></a>
<a class="sourceLine" id="cb190-7" data-line-number="7"><span class="dt">Nothing</span><span class="ot"> ::</span> <span class="dt">Maybe</span> a</a>
<a class="sourceLine" id="cb190-8" data-line-number="8"><span class="co">-- Nothing is a value of type Maybe a, so it can be the return value of any function that returns a Maybe &lt;something&gt;.</span></a>
<a class="sourceLine" id="cb190-9" data-line-number="9"></a>
<a class="sourceLine" id="cb190-10" data-line-number="10"><span class="dt">Prelude</span><span class="fu">&gt;</span> <span class="fu">:</span>t <span class="dt">Just</span> <span class="dv">4</span></a>
<a class="sourceLine" id="cb190-11" data-line-number="11"><span class="dt">Just</span> <span class="dv">4</span><span class="ot"> ::</span> <span class="dt">Num</span> a <span class="ot">=&gt;</span> <span class="dt">Maybe</span> a</a>
<a class="sourceLine" id="cb190-12" data-line-number="12"><span class="co">-- Just 4 returns a Maybe a, where a is any type in the typeclass Num. We could use this for a function that was returning a Float, a Double, an Int, etc.</span></a></code></pre></div>
<p>These are also called <em>parameterized types</em> because their type constructors that take parameters.</p>
<p><span class="newthought">There’s another</span> very useful parameterized type called <code>Either</code>. It’s used when a function can return two different types, most often for error handling<label for="marginnote-59" class="margin-toggle">⊕</label> <input type="checkbox" id="marginnote-59" class="margin-toggle"/> <span class="marginnote"><code>Either</code> has an advantage over <code>Maybe</code> when there are multiple reasons an operation can fail, because you can return an error message instead of an uninformative <code>Nothing</code>.</span>. Here’s how it’s defined:</p>
<div class="sourceCode" id="cb191"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb191-1" data-line-number="1"><span class="kw">data</span> <span class="dt">Either</span> a b <span class="fu">=</span> <span class="dt">Left</span> a <span class="fu">|</span> <span class="dt">Right</span> b</a></code></pre></div>
<p>Let’s play with Either in GHCi.</p>
<div class="sourceCode" id="cb192"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb192-1" data-line-number="1"><span class="dt">Prelude</span><span class="fu">&gt;</span> <span class="dt">Left</span> <span class="st">&quot;hello&quot;</span></a>
<a class="sourceLine" id="cb192-2" data-line-number="2"><span class="dt">Left</span> <span class="st">&quot;hello&quot;</span></a>
<a class="sourceLine" id="cb192-3" data-line-number="3"><span class="dt">Prelude</span><span class="fu">&gt;</span> <span class="dt">Right</span> <span class="dt">True</span></a>
<a class="sourceLine" id="cb192-4" data-line-number="4"><span class="dt">Right</span> <span class="dt">True</span></a>
<a class="sourceLine" id="cb192-5" data-line-number="5"></a>
<a class="sourceLine" id="cb192-6" data-line-number="6"><span class="dt">Prelude</span><span class="fu">&gt;</span> <span class="fu">:</span>t <span class="dt">Left</span> <span class="st">&quot;hello&quot;</span></a>
<a class="sourceLine" id="cb192-7" data-line-number="7"><span class="dt">Left</span> <span class="st">&quot;hello&quot;</span><span class="ot"> ::</span> <span class="dt">Either</span> [<span class="dt">Char</span>] b</a>
<a class="sourceLine" id="cb192-8" data-line-number="8"></a>
<a class="sourceLine" id="cb192-9" data-line-number="9"><span class="dt">Prelude</span><span class="fu">&gt;</span> <span class="fu">:</span>t <span class="dt">Right</span> <span class="dt">True</span></a>
<a class="sourceLine" id="cb192-10" data-line-number="10"><span class="dt">Right</span> <span class="dt">True</span><span class="ot"> ::</span> <span class="dt">Either</span> a <span class="dt">Bool</span></a></code></pre></div>
<p>Parameterized types are hugely important in Haskell, so I want to go over it again here. <code>Left &quot;hello&quot;</code> returns a value of type <code>Either [Char] b</code>. That means if you’re writing a function, and its type signature says it returns a value of type <code>Either [Char] &lt;anything&gt;</code>, then you can return <code>Left &quot;hello&quot;</code><label for="sidenote-50" class="margin-toggle sidenote-number"></label> <input type="checkbox" id="sidenote-50" class="margin-toggle"/> <span class="sidenote">Recalling, of course, that a <code>[Char]</code> is any <code>String</code>, like <code>&quot;hello&quot;</code>.</span>. <code>Either</code> is a type constructor that takes two Types as arguments - one for the type of the <code>Left</code>, and one for the type of the <code>Right</code>. You can think of <code>Either</code> as the opposite of a 2-tuple - you use either when you want to return either this <em>or</em> that, you use a tuple when you want to return both this <em>and</em> that.</p>
<p>Let’s rewrite <code>maybeDivide</code> to use <code>Either</code> instead. It will return a <code>String</code> with an error message on the left<label for="sidenote-51" class="margin-toggle sidenote-number"></label> <input type="checkbox" id="sidenote-51" class="margin-toggle"/> <span class="sidenote">A better way would be to you a data type with values for all the possible errors instead of a <code>String</code>, but I didn’t want to complicate things</span> if it couldn’t do the division, otherwise it will return the result on the right.</p>
<div class="sourceCode" id="cb193"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb193-1" data-line-number="1"><span class="co">-- eitherDivide.hs</span></a>
<a class="sourceLine" id="cb193-2" data-line-number="2"><span class="ot">eitherDivide ::</span> <span class="dt">Double</span> <span class="ot">-&gt;</span> <span class="dt">Double</span> <span class="ot">-&gt;</span> <span class="dt">Either</span> <span class="dt">String</span> <span class="dt">Double</span></a>
<a class="sourceLine" id="cb193-3" data-line-number="3">eitherDivide _ <span class="dv">0</span> <span class="fu">=</span> <span class="dt">Left</span> <span class="st">&quot;Sorry, can&#39;t divide by zero&quot;</span></a>
<a class="sourceLine" id="cb193-4" data-line-number="4">eitherDivide x y <span class="fu">=</span> <span class="dt">Right</span> (x <span class="fu">/</span> y)</a></code></pre></div>
<p>We can load this into GHCi and play with it.</p>
<div class="sourceCode" id="cb194"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb194-1" data-line-number="1"><span class="dt">Prelude</span><span class="fu">&gt;</span> <span class="fu">:</span>l eitherDivide<span class="fu">.</span>hs</a>
<a class="sourceLine" id="cb194-2" data-line-number="2">[<span class="dv">1</span> <span class="kw">of</span> <span class="dv">1</span>] <span class="dt">Compiling</span> <span class="dt">Main</span> ( eitherDivide<span class="fu">.</span>hs, interpreted )</a>
<a class="sourceLine" id="cb194-3" data-line-number="3"><span class="dt">Ok</span>, one <span class="kw">module</span> loaded<span class="fu">.</span></a>
<a class="sourceLine" id="cb194-4" data-line-number="4"><span class="fu">*</span><span class="dt">Main</span><span class="fu">&gt;</span> eitherDivide <span class="dv">3</span> <span class="dv">4</span></a>
<a class="sourceLine" id="cb194-5" data-line-number="5"><span class="dt">Right</span> <span class="fl">0.75</span></a>
<a class="sourceLine" id="cb194-6" data-line-number="6"><span class="fu">*</span><span class="dt">Main</span><span class="fu">&gt;</span> eitherDivide <span class="dv">3</span> <span class="dv">0</span></a>
<a class="sourceLine" id="cb194-7" data-line-number="7"><span class="dt">Left</span> <span class="st">&quot;Sorry, can&#39;t divide by zero&quot;</span></a></code></pre></div>
<hr />
<p><strong><strong><em>Exercises</em></strong></strong>:</p>
<ol type="1">
<li><p>In <code>data Either a b = Left a | Right b</code>, find the type constructor(s), and find the value constructor(s).</p>
<p>Really try this, because understanding Haskell data types is important.</p>
<p>Answer: <code>Either</code> is the type constructor, which takes to parameters, <code>a</code> and <code>b</code>. The two value constructors are Left (which takes an <code>a</code>) and Right (which takes a <code>b</code>).</p></li>
</ol>
<hr />
<p><span class="newthought">Ok, lets</span> try writing our own parameterized type, it’ll represent a shape. We want the user to be able to use any type of number they want in defining our shape, so we’ll not specify one. Just for fun, let’s also write a function that takes a shape and tells us it’s area<label for="sidenote-52" class="margin-toggle sidenote-number"></label> <input type="checkbox" id="sidenote-52" class="margin-toggle"/> <span class="sidenote">A better way would be to make a <code>Shape</code> typeclass, but this works too.</span>.</p>
<div class="sourceCode" id="cb195"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb195-1" data-line-number="1"><span class="co">-- shapeTypes.hs</span></a>
<a class="sourceLine" id="cb195-2" data-line-number="2"><span class="co">-- For a circle we need a point and a radius. For a rectangle, we need two points.</span></a>
<a class="sourceLine" id="cb195-3" data-line-number="3"><span class="kw">data</span> <span class="dt">Shape</span> a <span class="fu">=</span> <span class="dt">Circle</span> (a, a) a <span class="fu">|</span> <span class="dt">Rectangle</span> (a, a) (a, a) <span class="kw">deriving</span> (<span class="dt">Show</span>)  </a>
<a class="sourceLine" id="cb195-4" data-line-number="4"></a>
<a class="sourceLine" id="cb195-5" data-line-number="5"><span class="ot">shapeArea ::</span> (<span class="dt">Fractional</span> a) <span class="ot">=&gt;</span> <span class="dt">Shape</span> a <span class="ot">-&gt;</span> a</a>
<a class="sourceLine" id="cb195-6" data-line-number="6">shapeArea (<span class="dt">Circle</span> (x, y) radius) <span class="fu">=</span> <span class="fl">0.5</span> <span class="fu">*</span> <span class="fl">3.14</span> <span class="fu">*</span> radius <span class="fu">^</span> <span class="dv">2</span></a>
<a class="sourceLine" id="cb195-7" data-line-number="7">shapeArea (<span class="dt">Rectangle</span> (x1, y1) (x2, y2)) <span class="fu">=</span> (x1<span class="fu">-</span>x2) <span class="fu">*</span> (y1<span class="fu">-</span>y2)</a></code></pre></div>
<p>Notice the parentheses when pattern matching in the <code>shapeArea</code> function. They’re there to ensure Haskell knows that <code>(Circle (x, y) radius)</code> is all supposed to be one pattern, so Haskell knows that <code>radius</code> is part of <code>Circle</code> and isn’t just another parameter. The same goes for <code>(Rectangle (x1, y1) (x2, y2))</code>. Without the parentheses, this code wouldn’t compile.</p>
<p>Let’s load this into GHCi and play with it.</p>
<div class="sourceCode" id="cb196"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb196-1" data-line-number="1"><span class="dt">Prelude</span><span class="fu">&gt;</span> <span class="fu">:</span>l shapeTypes<span class="fu">.</span>hs</a>
<a class="sourceLine" id="cb196-2" data-line-number="2">[<span class="dv">1</span> <span class="kw">of</span> <span class="dv">1</span>] <span class="dt">Compiling</span> <span class="dt">Main</span> ( shapeTypes<span class="fu">.</span>hs, interpreted )</a>
<a class="sourceLine" id="cb196-3" data-line-number="3"><span class="dt">Ok</span>, one <span class="kw">module</span> loaded<span class="fu">.</span></a>
<a class="sourceLine" id="cb196-4" data-line-number="4"><span class="fu">*</span><span class="dt">Main</span><span class="fu">&gt;</span> myShape <span class="fu">=</span> <span class="dt">Circle</span> (<span class="dv">2</span>, <span class="dv">2</span>) <span class="dv">5</span></a>
<a class="sourceLine" id="cb196-5" data-line-number="5"><span class="fu">*</span><span class="dt">Main</span><span class="fu">&gt;</span> shapeArea myShape</a>
<a class="sourceLine" id="cb196-6" data-line-number="6"><span class="fl">39.25</span></a></code></pre></div>
<p>Yep, looks like it’s working well! To really drive the point home, let’s look at the type for the data constructor <code>Circle</code>.</p>
<div class="sourceCode" id="cb197"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb197-1" data-line-number="1"><span class="fu">*</span><span class="dt">Main</span><span class="fu">&gt;</span> <span class="fu">:</span>t <span class="dt">Circle</span></a>
<a class="sourceLine" id="cb197-2" data-line-number="2"><span class="dt">Circle</span><span class="ot"> ::</span> (a, a) <span class="ot">-&gt;</span> a <span class="ot">-&gt;</span> <span class="dt">Shape</span> a</a></code></pre></div>
<p>So <code>Circle</code> is a data constructor that takes a tuple of two values of type <code>a</code>, and another value of type <code>a</code>, and returns a value of type <code>Shape a</code>.</p>
<p>You might have noticed that in our definition for <code>Shape</code> we never say the type <code>a</code> has to be in the typeclass <code>Num</code>. We could have, but it’s considered bad practice in Haskell. That’s because we’d have to duplicate the <code>(Num a) =&gt;</code> in every function that we made take a <code>Shape a</code>, even if it wasn’t relevant for that function. By not adding it, we have the option to only put <code>(Num a) =&gt;</code> on the functions that really need it<label for="sidenote-53" class="margin-toggle sidenote-number"></label> <input type="checkbox" id="sidenote-53" class="margin-toggle"/> <span class="sidenote">In fact, putting type constraints in <code>data</code> definitions is considered such bad practice that there are ways to make GHC warn you when you do it.</span>.</p>
<p>You can also parameterize type aliases. For example, we used <code>(a,a)</code> a few times in that definition - let’s try and make that clearer with type aliases.</p>
<div class="sourceCode" id="cb198"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb198-1" data-line-number="1"><span class="kw">type</span> <span class="dt">Point</span> a <span class="fu">=</span> (a, a)</a>
<a class="sourceLine" id="cb198-2" data-line-number="2"><span class="kw">data</span> <span class="dt">Shape</span> a <span class="fu">=</span> <span class="dt">Circle</span> (<span class="dt">Point</span> a) a <span class="fu">|</span> <span class="dt">Rectangle</span> (<span class="dt">Point</span> a) (<span class="dt">Point</span> a) <span class="kw">deriving</span> (<span class="dt">Show</span>)  </a></code></pre></div>
<p>In fact, let’s use record syntax to make it even clearer.</p>
<div class="sourceCode" id="cb199"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb199-1" data-line-number="1"><span class="fu">*</span><span class="dt">Main</span><span class="fu">&gt;</span> <span class="kw">type</span> <span class="dt">Point</span> a <span class="fu">=</span> (a, a)</a>
<a class="sourceLine" id="cb199-2" data-line-number="2"><span class="fu">*</span><span class="dt">Main</span><span class="fu">&gt;</span> <span class="kw">data</span> <span class="dt">Shape</span> a <span class="fu">=</span> <span class="dt">Circle</span> {<span class="ot">center ::</span> <span class="dt">Point</span> a,<span class="ot"> radius ::</span> a} <span class="fu">|</span> <span class="dt">Rectangle</span> {<span class="ot">corner1 ::</span> <span class="dt">Point</span> a,<span class="ot"> corner2 ::</span> <span class="dt">Point</span> a} <span class="kw">deriving</span> (<span class="dt">Show</span>)</a>
<a class="sourceLine" id="cb199-3" data-line-number="3"><span class="fu">*</span><span class="dt">Main</span><span class="fu">&gt;</span> myShape <span class="fu">=</span> <span class="dt">Circle</span> (<span class="dv">3</span>,<span class="dv">5</span>) <span class="dv">10</span></a>
<a class="sourceLine" id="cb199-4" data-line-number="4"><span class="fu">*</span><span class="dt">Main</span><span class="fu">&gt;</span> radius myShape</a>
<a class="sourceLine" id="cb199-5" data-line-number="5"><span class="dv">10</span></a></code></pre></div>
<p>This could now be a production-ready shape class!</p>
<h2 id="kinds">Kinds</h2>
<p><span class="newthought">Let’s try</span> and make this clearer by talking about <em>kinds</em>. We discussed earlier that there are two kinds of types. There are concrete types like <code>Int</code> or <code>[Char]</code> or <code>Maybe Int</code> or <code>(Num a) =&gt; Maybe a</code>, and not-real-types like <code>Maybe</code> and <code>Either</code> or even <code>Either Int</code><label for="sidenote-54" class="margin-toggle sidenote-number"></label> <input type="checkbox" id="sidenote-54" class="margin-toggle"/> <span class="sidenote">Remember, <code>Either</code> needs two values, such as <code>Either Int Int</code>. If you only provide one, you haven’t got a concrete type.</span>. The type constructors in the second group still need something else to turn into a concrete type that we’d be allowed to use in a type signature. <code>Int</code> and <code>Maybe Int</code> are concrete types - <code>Maybe</code> still needs another type to make it a concrete type, so you can’t use it in a type signature. We can see this by using the <code>:kind</code> or <code>:k</code><label for="marginnote-60" class="margin-toggle">⊕</label> <input type="checkbox" id="marginnote-60" class="margin-toggle"/> <span class="marginnote">Most GHCi commands let you just use the first letter instead of typing out the whole word, like <code>:load</code> and <code>:l</code> or <code>:type</code> and <code>:t</code>.</span> commands in GHCi.</p>
<div class="sourceCode" id="cb200"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb200-1" data-line-number="1"><span class="dt">Prelude</span><span class="fu">&gt;</span> <span class="fu">:</span>k <span class="dt">Int</span></a>
<a class="sourceLine" id="cb200-2" data-line-number="2"><span class="dt">Int</span><span class="ot"> ::</span> <span class="fu">*</span></a></code></pre></div>
<p>The <code>*</code> means it’s a concrete type<label for="marginnote-61" class="margin-toggle">⊕</label> <input type="checkbox" id="marginnote-61" class="margin-toggle"/> <span class="marginnote">In the future, <code>*</code> will be renamed to <code>Type</code>. If you’re using GHCi and seeing <code>Type</code> instead of <code>*</code>, it means you may be reading an out-of-date version of this book.</span>. You could pronounce it like “star” or just “concrete type”. Let’s look at some other concrete types.</p>
<div class="sourceCode" id="cb201"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb201-1" data-line-number="1"><span class="dt">Prelude</span><span class="fu">&gt;</span> <span class="fu">:</span>k [<span class="dt">Char</span>]</a>
<a class="sourceLine" id="cb201-2" data-line-number="2">[<span class="dt">Char</span>]<span class="ot"> ::</span> <span class="fu">*</span></a>
<a class="sourceLine" id="cb201-3" data-line-number="3"><span class="dt">Prelude</span><span class="fu">&gt;</span> <span class="fu">:</span>k <span class="dt">Maybe</span> <span class="dt">Int</span></a>
<a class="sourceLine" id="cb201-4" data-line-number="4"><span class="dt">Maybe</span> <span class="dt">Int</span><span class="ot"> ::</span> <span class="fu">*</span></a></code></pre></div>
<p>See? They’re all concrete types.</p>
<p>Let’s look at some type constructors instead, like <code>Maybe</code>.</p>
<div class="sourceCode" id="cb202"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb202-1" data-line-number="1"><span class="fu">:</span>k <span class="dt">Maybe</span></a>
<a class="sourceLine" id="cb202-2" data-line-number="2"><span class="dt">Maybe</span><span class="ot"> ::</span> <span class="fu">*</span> <span class="ot">-&gt;</span> <span class="fu">*</span></a>
<a class="sourceLine" id="cb202-3" data-line-number="3"><span class="fu">:</span>k <span class="dt">Maybe</span> <span class="dt">Int</span></a>
<a class="sourceLine" id="cb202-4" data-line-number="4"><span class="dt">Maybe</span> <span class="dt">Int</span><span class="ot"> ::</span> <span class="fu">*</span></a></code></pre></div>
<p>Ah, see? <code>Maybe</code> needs another type as a parameter before it can be a concrete type. You can read this as “The type constructor Maybe takes a concrete type and returns a concrete type”. Let’s look at <code>Either</code>.</p>
<div class="sourceCode" id="cb203"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb203-1" data-line-number="1"><span class="dt">Prelude</span><span class="fu">&gt;</span> <span class="fu">:</span>k <span class="dt">Either</span></a>
<a class="sourceLine" id="cb203-2" data-line-number="2"><span class="dt">Either</span><span class="ot"> ::</span> <span class="fu">*</span> <span class="ot">-&gt;</span> <span class="fu">*</span> <span class="ot">-&gt;</span> <span class="fu">*</span>             <span class="co">-- Either is a type constructor that takes two concrete types and returns a concrete type</span></a>
<a class="sourceLine" id="cb203-3" data-line-number="3"><span class="dt">Prelude</span><span class="fu">&gt;</span> <span class="fu">:</span>k <span class="dt">Either</span> <span class="dt">String</span></a>
<a class="sourceLine" id="cb203-4" data-line-number="4"><span class="dt">Either</span> <span class="dt">String</span><span class="ot"> ::</span> <span class="fu">*</span> <span class="ot">-&gt;</span> <span class="fu">*</span>           <span class="co">-- Through Currying, we can see the value of Either String. It still needs another concrete type </span></a>
<a class="sourceLine" id="cb203-5" data-line-number="5"><span class="dt">Prelude</span><span class="fu">&gt;</span> <span class="fu">:</span>k <span class="dt">Either</span> <span class="dt">String</span> <span class="dt">Double</span></a>
<a class="sourceLine" id="cb203-6" data-line-number="6"><span class="dt">Either</span> <span class="dt">String</span> <span class="dt">Double</span><span class="ot"> ::</span> <span class="fu">*</span>         <span class="co">-- Either String Double is finally a concrete type that we could use in a type signature!</span></a></code></pre></div>
<p>When Haskell wants a concrete type, any concrete type will work, even one made from other type constructors.</p>
<div class="sourceCode" id="cb204"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb204-1" data-line-number="1"><span class="dt">Prelude</span><span class="fu">&gt;</span> <span class="fu">:</span>k <span class="dt">Maybe</span> (<span class="dt">Either</span> <span class="dt">String</span> <span class="dt">Double</span>)</a>
<a class="sourceLine" id="cb204-2" data-line-number="2"><span class="dt">Maybe</span> (<span class="dt">Either</span> <span class="dt">String</span> <span class="dt">Double</span>)<span class="ot"> ::</span> <span class="fu">*</span></a></code></pre></div>
<p><code>Either String Double</code> is a <code>*</code><label for="marginnote-62" class="margin-toggle">⊕</label> <input type="checkbox" id="marginnote-62" class="margin-toggle"/> <span class="marginnote">Remember, <code>*</code> means concrete type.</span>, and <code>Maybe</code> takes a <code>*</code> and returns a <code>*</code>, so <code>Maybe (Either String Double)</code> is a concrete type. You may have noticed that lists seem like they’re just a modification of another type, like how an <code>[Int]</code> is just a List of <code>Int</code>s. Well, <code>[]</code> is actually a type constructor!</p>
<div class="sourceCode" id="cb205"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb205-1" data-line-number="1"><span class="dt">Prelude</span><span class="fu">&gt;</span> <span class="fu">:</span>k []</a>
<a class="sourceLine" id="cb205-2" data-line-number="2">[]<span class="ot"> ::</span> <span class="fu">*</span> <span class="ot">-&gt;</span> <span class="fu">*</span></a></code></pre></div>
<p><code>[]</code> the type constructor is different from <code>[]</code> the data constructor, so don’t get them confused. <code>[Int]</code> is a concrete type appropriate in a type signature (and is actually syntax sugar for <code>[] Int</code>), <code>[1]</code> is a value (and is syntax sugar for <code>1:[]</code>).</p>
<p><span class="newthought">But when</span> is learning about kinds useful? Well, let’s talk about the <code>Functor</code> typeclass. The <code>Functor</code> typeclass is for things that can be mapped over. You might remember the <code>map</code> function, which takes a function and a List, and applies the function to everything in the List.</p>
<div class="sourceCode" id="cb206"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb206-1" data-line-number="1"><span class="dt">Prelude</span><span class="fu">&gt;</span> map (<span class="fu">+</span><span class="dv">5</span>) [<span class="dv">1</span>,<span class="dv">2</span>,<span class="dv">3</span>]</a>
<a class="sourceLine" id="cb206-2" data-line-number="2">[<span class="dv">6</span>,<span class="dv">7</span>,<span class="dv">8</span>]</a></code></pre></div>
<p>Well, for historical reasons <code>map</code> only works on lists, but there are lots of other things that can be mapped over. In Haskell you can have sets, arrays, fingertrees, and all kinds of other data structures we’ll discuss later. These data structures are in the <code>Functor</code> typeclass. Because <code>map</code> was stuck as only working on lists for historical reasons<label for="marginnote-63" class="margin-toggle">⊕</label> <input type="checkbox" id="marginnote-63" class="margin-toggle"/> <span class="marginnote">You’ll find that “historical reasons” explains quite a bit about Haskell.</span>, they made <code>fmap</code>, which is the same but works on any <code>Functor</code>. Here’s how it’s defined.</p>
<div class="sourceCode" id="cb207"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb207-1" data-line-number="1"><span class="kw">class</span> <span class="dt">Functor</span> f <span class="kw">where</span>  </a>
<a class="sourceLine" id="cb207-2" data-line-number="2"><span class="ot">    fmap ::</span> (a <span class="ot">-&gt;</span> b) <span class="ot">-&gt;</span> f a <span class="ot">-&gt;</span> f b  </a></code></pre></div>
<p>You might be curious what that <code>f a</code> is (notice that it’s the same <code>f</code> from <code>Functor f</code>). It’s something we haven’t seen before. The <code>f</code> <em>represents a type constructor</em>, and it later an <code>a</code> (which can be of any type) and returns a concrete type<label for="marginnote-64" class="margin-toggle">⊕</label> <input type="checkbox" id="marginnote-64" class="margin-toggle"/> <span class="marginnote">This means that type constructors can be instances of type classes, not just concrete types. This is very powerful because it lets us make functions that work on all lists, like <code>fmap</code>, but also works on other type constructors, like <code>Maybe</code> (which we’ll see in a moment).</span>! So <code>Functor</code> is a typeclass that applies to type constructors, not complete types. <code>[]</code> is an instance of <code>Functor</code>, of course. Let’s see how that’s defined.</p>
<div class="sourceCode" id="cb208"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb208-1" data-line-number="1"><span class="kw">instance</span> <span class="dt">Functor</span> [] <span class="kw">where</span>  </a>
<a class="sourceLine" id="cb208-2" data-line-number="2">    fmap <span class="fu">=</span> map  </a></code></pre></div>
<p>Pretty basic. <code>fmap</code> is just the functor typeclass version of the List-specific <code>map</code>. When applied to lists, <code>fmap</code> only needs to do what <code>map</code> already does. Let’s try applying it to <code>Maybe</code>. <code>fmap (+1) (Just 4)</code> evaluates to <code>Just 5</code>. <code>fmap (+1) Nothing</code> evaluates to <code>Nothing</code>. If you’re mapping over <code>Just &lt;something&gt;</code> you apply the function to <code>&lt;something&gt;</code>, if it’s <code>Nothing</code> you return <code>Nothing</code>. Here’s it in Haskell.</p>
<div class="sourceCode" id="cb209"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb209-1" data-line-number="1"><span class="kw">instance</span> <span class="dt">Functor</span> <span class="dt">Maybe</span> <span class="kw">where</span>  </a>
<a class="sourceLine" id="cb209-2" data-line-number="2">    fmap f (<span class="dt">Just</span> x) <span class="fu">=</span> <span class="dt">Just</span> (f x)  </a>
<a class="sourceLine" id="cb209-3" data-line-number="3">    fmap f <span class="dt">Nothing</span> <span class="fu">=</span> <span class="dt">Nothing</span>  </a></code></pre></div>
<p>Let’s try it out.</p>
<div class="sourceCode" id="cb210"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb210-1" data-line-number="1"><span class="dt">Prelude</span><span class="fu">&gt;</span> fmap (\x <span class="ot">-&gt;</span> x <span class="fu">*</span> <span class="dv">2</span> <span class="fu">+</span> <span class="dv">1</span>) (<span class="dt">Just</span> <span class="dv">1</span>)</a>
<a class="sourceLine" id="cb210-2" data-line-number="2"><span class="dt">Just</span> <span class="dv">3</span></a>
<a class="sourceLine" id="cb210-3" data-line-number="3"><span class="dt">Prelude</span><span class="fu">&gt;</span> fmap (\x <span class="ot">-&gt;</span> x <span class="fu">*</span> <span class="dv">2</span> <span class="fu">+</span> <span class="dv">1</span>) (<span class="dt">Nothing</span>)</a>
<a class="sourceLine" id="cb210-4" data-line-number="4"><span class="dt">Nothing</span></a></code></pre></div>
<p>You can probably see how this would be useful! Imagine we had a function that returned a <code>Maybe Int</code>, and we wanted to do some calculations on the <code>Int</code> inside. We can do them all with <code>fmap</code>s, and wouldn’t have to first check if it was really a <code>Nothing</code>.</p>
<p>I hope this made sense. Types and kinds of types are probably the trickiest part of Haskell, so don’t feel discouraged if it takes some time to understand this.</p>
<hr />
<p><strong><strong><em>Exercises</em></strong></strong>:</p>
<ol type="1">
<li><p>Do you remember the <code>foldr</code> function? We used it to sum a list with <code>sum xs = foldr (\x acc -&gt; acc + x) 0 xs</code>. Here is its type:</p>
<div class="sourceCode" id="cb211"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb211-1" data-line-number="1"><span class="dt">Prelude</span><span class="fu">&gt;</span> <span class="fu">:</span>t foldr</a>
<a class="sourceLine" id="cb211-2" data-line-number="2">foldr<span class="ot"> ::</span> <span class="dt">Foldable</span> t <span class="ot">=&gt;</span> (a <span class="ot">-&gt;</span> b <span class="ot">-&gt;</span> b) <span class="ot">-&gt;</span> b <span class="ot">-&gt;</span> t a <span class="ot">-&gt;</span> b</a></code></pre></div>
<p>What does the type variable <code>t</code> take when folding over a list? Hint: look at the third argument of <code>foldr (\x acc -&gt; acc + x) 0 xs</code>.</p></li>
</ol>
<hr />
<h2 id="making-our-own-typeclasses">Making Our Own Typeclasses</h2>
<p><span class="newthought">As you</span> know, we have access to quite a few typeclasses in Haskell, such as <code>Eq</code>, <code>Ord</code>, <code>Show</code>, and <code>Num</code>. Let’s see how <code>Eq</code> `might be defined<label for="marginnote-65" class="margin-toggle">⊕</label> <input type="checkbox" id="marginnote-65" class="margin-toggle"/> <span class="marginnote">Note that this is not the full definition because it lacks the default implementations, which we’ll add in a moment.</span>:</p>
<div class="sourceCode" id="cb212"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb212-1" data-line-number="1"><span class="kw">class</span> <span class="dt">Eq</span> a <span class="kw">where</span>  </a>
<a class="sourceLine" id="cb212-2" data-line-number="2"><span class="ot">    (==) ::</span> a <span class="ot">-&gt;</span> a <span class="ot">-&gt;</span> <span class="dt">Bool</span>  </a>
<a class="sourceLine" id="cb212-3" data-line-number="3"><span class="ot">    (/=) ::</span> a <span class="ot">-&gt;</span> a <span class="ot">-&gt;</span> <span class="dt">Bool</span>  </a></code></pre></div>
<p>Let’s zoom in on this, although it’s pretty simple.</p>
<div class="sourceCode" id="cb213"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb213-1" data-line-number="1">   <span class="kw">class</span>     <span class="dt">Eq</span> a     <span class="kw">where</span>  </a>
<a class="sourceLine" id="cb213-2" data-line-number="2"><span class="co">--  [1]      [2]       [3]</span></a></code></pre></div>
<ol type="1">
<li><p><code>class</code> - This keyword tells Haskell that we’re declaring a new typeclass.</p></li>
<li><p><code>Eq a</code> - Then comes the name of the typeclass that we’re defining, and the type variable that we’ll be using.</p></li>
<li><p><code>where</code> - This keyword should look familiar! It means we’re going to be defining bindings soon. Here though, all we’ve done is declare functions and give their type signature - we don’t actually give the definition of the function.</p></li>
</ol>
<p>To make a data type an instance of this typeclass, we’d have to use the <code>instance</code> keyword<label for="sidenote-55" class="margin-toggle sidenote-number"></label> <input type="checkbox" id="sidenote-55" class="margin-toggle"/> <span class="sidenote">see <a href="#basic-data-types">Basic data types</a> for more</span>. To make a type an instance of a typeclass, a definition for every function declared in the typeclass must be given, unless there is a default implementation. This is done in the <code>Eq</code> typeclass, like this.</p>
<div class="sourceCode" id="cb214"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb214-1" data-line-number="1"><span class="kw">class</span> <span class="dt">Eq</span> a <span class="kw">where</span>  </a>
<a class="sourceLine" id="cb214-2" data-line-number="2"><span class="ot">    (==) ::</span> a <span class="ot">-&gt;</span> a <span class="ot">-&gt;</span> <span class="dt">Bool</span>  </a>
<a class="sourceLine" id="cb214-3" data-line-number="3"><span class="ot">    (/=) ::</span> a <span class="ot">-&gt;</span> a <span class="ot">-&gt;</span> <span class="dt">Bool</span>  </a>
<a class="sourceLine" id="cb214-4" data-line-number="4">    x <span class="fu">==</span> y <span class="fu">=</span> not (x <span class="fu">/=</span> y)  </a>
<a class="sourceLine" id="cb214-5" data-line-number="5">    x <span class="fu">/=</span> y <span class="fu">=</span> not (x <span class="fu">==</span> y)  </a></code></pre></div>
<p>Of course, you must override one of these, otherwise you will find yourself in an infinite loop. Remember the <code>Show</code> typeclass? It contains a function, <code>show</code><label for="marginnote-66" class="margin-toggle">⊕</label> <input type="checkbox" id="marginnote-66" class="margin-toggle"/> <span class="marginnote"><code>Show</code> also has some other functions that aren’t relevant here, like <code>showsPrec</code>.</span>, which takes a value and returns a <code>String</code> which is supposed to represent the value somehow. Let’s write our own, <code>ShowFrench</code>, which will be similar, but return a representation in French instead of English.</p>
<div class="sourceCode" id="cb215"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb215-1" data-line-number="1"><span class="co">-- showFrench.hs</span></a>
<a class="sourceLine" id="cb215-2" data-line-number="2"><span class="co">-- We&#39;ll only need one function in our typeclass - showFrench, which takes a value and returns a String</span></a>
<a class="sourceLine" id="cb215-3" data-line-number="3"><span class="kw">class</span> <span class="dt">ShowFrench</span> a <span class="kw">where</span></a>
<a class="sourceLine" id="cb215-4" data-line-number="4"><span class="ot">    showFrench ::</span> a <span class="ot">-&gt;</span> <span class="dt">String</span></a>
<a class="sourceLine" id="cb215-5" data-line-number="5"></a>
<a class="sourceLine" id="cb215-6" data-line-number="6"><span class="co">-- Now, let&#39;s make Int a member of this typeclass</span></a>
<a class="sourceLine" id="cb215-7" data-line-number="7"><span class="kw">instance</span> <span class="dt">ShowFrench</span> <span class="dt">Int</span> <span class="kw">where</span></a>
<a class="sourceLine" id="cb215-8" data-line-number="8">    showFrench <span class="dv">0</span> <span class="fu">=</span> <span class="st">&quot;zéro&quot;</span></a>
<a class="sourceLine" id="cb215-9" data-line-number="9">    showFrench <span class="dv">1</span> <span class="fu">=</span> <span class="st">&quot;un&quot;</span></a>
<a class="sourceLine" id="cb215-10" data-line-number="10">    showFrench <span class="dv">2</span> <span class="fu">=</span> <span class="st">&quot;deux&quot;</span></a>
<a class="sourceLine" id="cb215-11" data-line-number="11">    showFrench <span class="dv">3</span> <span class="fu">=</span> <span class="st">&quot;trois&quot;</span></a>
<a class="sourceLine" id="cb215-12" data-line-number="12">    <span class="co">-- this pattern match isn&#39;t complete, but that&#39;s ok, this is just for demonstration purposes</span></a>
<a class="sourceLine" id="cb215-13" data-line-number="13"></a>
<a class="sourceLine" id="cb215-14" data-line-number="14"><span class="co">-- Let&#39;s also make Boolean an instance</span></a>
<a class="sourceLine" id="cb215-15" data-line-number="15"><span class="kw">instance</span> <span class="dt">ShowFrench</span> <span class="dt">Bool</span> <span class="kw">where</span></a>
<a class="sourceLine" id="cb215-16" data-line-number="16">    showFrench <span class="dt">True</span> <span class="fu">=</span> <span class="st">&quot;vrai&quot;</span></a>
<a class="sourceLine" id="cb215-17" data-line-number="17">    showFrench <span class="dt">False</span> <span class="fu">=</span> <span class="st">&quot;faux&quot;</span></a></code></pre></div>
<p>Now, let’s load this into GHCi to test it out!</p>
<div class="sourceCode" id="cb216"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb216-1" data-line-number="1"><span class="dt">Prelude</span><span class="fu">&gt;</span> <span class="fu">:</span>l showFrench<span class="fu">.</span>hs</a>
<a class="sourceLine" id="cb216-2" data-line-number="2">[<span class="dv">1</span> <span class="kw">of</span> <span class="dv">1</span>] <span class="dt">Compiling</span> <span class="dt">Main</span> ( showFrench<span class="fu">.</span>hs, interpreted )</a>
<a class="sourceLine" id="cb216-3" data-line-number="3"><span class="dt">Ok</span>, one <span class="kw">module</span> loaded<span class="fu">.</span></a>
<a class="sourceLine" id="cb216-4" data-line-number="4"><span class="fu">*</span><span class="dt">Main</span><span class="fu">&gt;</span> showFrench (<span class="dv">1</span><span class="ot"> ::</span> <span class="dt">Int</span>)</a>
<a class="sourceLine" id="cb216-5" data-line-number="5"><span class="st">&quot;un&quot;</span></a>
<a class="sourceLine" id="cb216-6" data-line-number="6"><span class="fu">*</span><span class="dt">Main</span><span class="fu">&gt;</span> showFrench <span class="dt">True</span></a>
<a class="sourceLine" id="cb216-7" data-line-number="7"><span class="st">&quot;vrai&quot;</span></a></code></pre></div>
<p>Seems to work, but if you pass <code>showFrench</code> an <code>Int</code> greater than <code>3</code>, your program will crash<label for="marginnote-67" class="margin-toggle">⊕</label> <input type="checkbox" id="marginnote-67" class="margin-toggle"/> <span class="marginnote">Specifically, what will happen is an exception will be triggered, and it probably won’t be handled because we haven’t learned how to handle exceptions yet.</span>. In those cases, it would be nice to just show the number. Let’s use this opportunity to also require that instances of <code>ShowFrench</code> must also be instances of <code>Show</code>, and then just run <code>show</code> on the number if we don’t have a French translation. Here’s how we’d do that.</p>
<div class="sourceCode" id="cb217"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb217-1" data-line-number="1"><span class="co">-- showFrenchBetter.hs</span></a>
<a class="sourceLine" id="cb217-2" data-line-number="2"><span class="kw">class</span> (<span class="dt">Show</span> a) <span class="ot">=&gt;</span> <span class="dt">ShowFrench</span> a <span class="kw">where</span></a>
<a class="sourceLine" id="cb217-3" data-line-number="3"><span class="ot">    showFrench ::</span> a <span class="ot">-&gt;</span> <span class="dt">String</span></a>
<a class="sourceLine" id="cb217-4" data-line-number="4"></a>
<a class="sourceLine" id="cb217-5" data-line-number="5"><span class="kw">instance</span> <span class="dt">ShowFrench</span> <span class="dt">Int</span> <span class="kw">where</span></a>
<a class="sourceLine" id="cb217-6" data-line-number="6">    showFrench <span class="dv">0</span> <span class="fu">=</span> <span class="st">&quot;zéro&quot;</span></a>
<a class="sourceLine" id="cb217-7" data-line-number="7">    showFrench <span class="dv">1</span> <span class="fu">=</span> <span class="st">&quot;un&quot;</span></a>
<a class="sourceLine" id="cb217-8" data-line-number="8">    showFrench <span class="dv">2</span> <span class="fu">=</span> <span class="st">&quot;deux&quot;</span></a>
<a class="sourceLine" id="cb217-9" data-line-number="9">    showFrench <span class="dv">3</span> <span class="fu">=</span> <span class="st">&quot;trois&quot;</span></a>
<a class="sourceLine" id="cb217-10" data-line-number="10">    showFrench x <span class="fu">=</span> show x</a>
<a class="sourceLine" id="cb217-11" data-line-number="11"></a>
<a class="sourceLine" id="cb217-12" data-line-number="12"></a>
<a class="sourceLine" id="cb217-13" data-line-number="13"><span class="kw">instance</span> <span class="dt">ShowFrench</span> <span class="dt">Bool</span> <span class="kw">where</span></a>
<a class="sourceLine" id="cb217-14" data-line-number="14">    showFrench <span class="dt">True</span> <span class="fu">=</span> <span class="st">&quot;vrai&quot;</span></a>
<a class="sourceLine" id="cb217-15" data-line-number="15">    showFrench <span class="dt">False</span> <span class="fu">=</span> <span class="st">&quot;faux&quot;</span></a></code></pre></div>
<p>Notice how we changed <code>ShowFrench a</code> to <code>(Show a) =&gt; ShowFrench a</code>. This means that our type variable <code>a</code> must be an instance of <code>Show</code>. This will basically do what you expect, so I won’t load it into GHCi to play with it, but you should!</p>
<h1 id="recursion-practice">Recursion Practice</h1>
<p><span class="newthought">We’ve used</span> a little bit of recursion in previous chapters, but it’s very important<label for="marginnote-68" class="margin-toggle">⊕</label> <input type="checkbox" id="marginnote-68" class="margin-toggle"/> <span class="marginnote">Haskell actually doesn’t have the primitive <code>while</code> or <code>for</code> loops you might be familiar with from other languages. All looping behavior must be accomplished with recursion at some level.</span> so I’d like to get some practice in.</p>
<ol type="1">
<li><p>Let’s write a copy of the <code>length</code> function<label for="marginnote-69" class="margin-toggle">⊕</label> <input type="checkbox" id="marginnote-69" class="margin-toggle"/> <span class="marginnote">In case you’ve forgotten, <code>length</code> is a function that takes a List and returns its length.</span>. Now, let’s think about how we would write this recursively.</p>
<p>A strategy tip for writing recursive programs is to think about what case is the most basic. For us, it’s probably the empty List, which obviously has length zero. Here’s how it’s done.</p>
<div class="sourceCode" id="cb218"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb218-1" data-line-number="1"><span class="co">-- length.hs</span></a>
<a class="sourceLine" id="cb218-2" data-line-number="2">    <span class="kw">class</span> (<span class="dt">Show</span> a) <span class="ot">=&gt;</span> <span class="dt">ShowFrench</span> a <span class="kw">where</span></a>
<a class="sourceLine" id="cb218-3" data-line-number="3"><span class="ot">    showFrench ::</span> a <span class="ot">-&gt;</span> <span class="dt">String</span></a>
<a class="sourceLine" id="cb218-4" data-line-number="4"></a>
<a class="sourceLine" id="cb218-5" data-line-number="5"><span class="kw">instance</span> <span class="dt">ShowFrench</span> <span class="dt">Int</span> <span class="kw">where</span></a>
<a class="sourceLine" id="cb218-6" data-line-number="6">    showFrench <span class="dv">0</span> <span class="fu">=</span> <span class="st">&quot;zéro&quot;</span></a>
<a class="sourceLine" id="cb218-7" data-line-number="7">    showFrench <span class="dv">1</span> <span class="fu">=</span> <span class="st">&quot;un&quot;</span></a>
<a class="sourceLine" id="cb218-8" data-line-number="8">    showFrench <span class="dv">2</span> <span class="fu">=</span> <span class="st">&quot;deux&quot;</span></a>
<a class="sourceLine" id="cb218-9" data-line-number="9">    showFrench <span class="dv">3</span> <span class="fu">=</span> <span class="st">&quot;trois&quot;</span></a>
<a class="sourceLine" id="cb218-10" data-line-number="10">    showFrench x <span class="fu">=</span> show x</a>
<a class="sourceLine" id="cb218-11" data-line-number="11"></a>
<a class="sourceLine" id="cb218-12" data-line-number="12"></a>
<a class="sourceLine" id="cb218-13" data-line-number="13"><span class="kw">instance</span> <span class="dt">ShowFrench</span> <span class="dt">Bool</span> <span class="kw">where</span></a>
<a class="sourceLine" id="cb218-14" data-line-number="14">    showFrench <span class="dt">True</span> <span class="fu">=</span> <span class="st">&quot;vrai&quot;</span></a>
<a class="sourceLine" id="cb218-15" data-line-number="15">    showFrench <span class="dt">False</span> <span class="fu">=</span> <span class="st">&quot;faux&quot;</span></a></code></pre></div>
<p>This may seem like it’s less efficient than a more iterative approach like you’d see in other programming languages. But GHC does something called <em>tail call optimization</em>, which means that if a function ends in a recursive call, it will be optimized into something more similar to a <em>while loop</em> from other languages<label for="sidenote-56" class="margin-toggle sidenote-number"></label> <input type="checkbox" id="sidenote-56" class="margin-toggle"/> <span class="sidenote">Provided you have the correct optimization settings turned on in GHC.</span>.</p></li>
<li><p>Let’s write a function that will take a List of numbers, and return a List of all those numbers raised to the second power.</p>
<p>As before, the most basic case for this function is the empty List, because it doesn’t have to do anything. We’ll also be using the classic <code>:</code> operator, which takes a value of type <code>s</code> and a List of type <code>[a]</code>, and returns a new List with that value at the beginning. So <code>1:[2,3]</code> evaluates to <code>[1,2,3]</code>, and <code>1:[]</code> evaluates to <code>[1]</code><label for="marginnote-70" class="margin-toggle">⊕</label> <input type="checkbox" id="marginnote-70" class="margin-toggle"/> <span class="marginnote">You may remember that <code>[1,2,3,4]</code> is actually syntax sugar for <code>1:2:3:4:[]</code>, so saying “<code>1:[]</code> evaluates to <code>[1]</code>” is a bit of a simplification.</span>.</p>
<div class="sourceCode" id="cb219"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb219-1" data-line-number="1"><span class="co">-- squares.hs</span></a>
<a class="sourceLine" id="cb219-2" data-line-number="2"><span class="ot">    squares ::</span> (<span class="dt">Num</span> a) <span class="ot">=&gt;</span> [a] <span class="ot">-&gt;</span> [a]</a>
<a class="sourceLine" id="cb219-3" data-line-number="3">squares [] <span class="fu">=</span> []</a>
<a class="sourceLine" id="cb219-4" data-line-number="4">squares (x<span class="fu">:</span>xs) <span class="fu">=</span> (x<span class="fu">^</span><span class="dv">2</span>)<span class="fu">:</span>(squares xs)</a></code></pre></div></li>
<li><p>Let’s write <code>map :: (a -&gt; b) -&gt; [a] -&gt; [b]</code>. If you’ve forgotten, <code>map</code> takes a function and a List, and applies the function to every element in the List. So <code>map (+1) [1,10,20]</code> evaluates to <code>[2,11,21]</code></p>
<p>You’ll notice that the most basic case (the <em>base case</em>, if you will) is usually the empty List, for functions that operate on lists. Here’s how we’d write this:</p>
<div class="sourceCode" id="cb220"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb220-1" data-line-number="1"><span class="co">-- map.hs</span></a>
<a class="sourceLine" id="cb220-2" data-line-number="2"><span class="ot">    map&#39; ::</span> (a <span class="ot">-&gt;</span> b) <span class="ot">-&gt;</span> [a] <span class="ot">-&gt;</span> [b]</a>
<a class="sourceLine" id="cb220-3" data-line-number="3">map&#39; f [] <span class="fu">=</span> []</a>
<a class="sourceLine" id="cb220-4" data-line-number="4">map&#39; f (x<span class="fu">:</span>xs) <span class="fu">=</span> (f x)<span class="fu">:</span>(map f xs)</a></code></pre></div>
<p>I’d recommend studying this until you grok how it works - it’s very similar to the <code>map</code> function we wrote earlier.</p></li>
<li><p>Let’s write a function that iterates over a List of numbers and removes all the even numbers, we’ll call it <code>odds</code>.</p>
<p>To aid with this, we’ll use the <code>rem</code> function, which divides two numbers and tells us the remainder<label for="sidenote-57" class="margin-toggle sidenote-number"></label> <input type="checkbox" id="sidenote-57" class="margin-toggle"/> <span class="sidenote">We could also use the <code>mod</code> function, which is similar, but <code>rem</code> is faster.</span>. If a number is odd, it’s remainder won’t be <code>0</code><label for="sidenote-58" class="margin-toggle sidenote-number"></label> <input type="checkbox" id="sidenote-58" class="margin-toggle"/> <span class="sidenote">It will either be <code>1</code> or <code>-1</code>.</span>. <code>rem</code> is only available for <code>Integral</code>, not <code>Num</code>, so we’ll have to limit ourselves to that.</p>
<div class="sourceCode" id="cb221"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb221-1" data-line-number="1"><span class="co">-- odds.hs</span></a>
<a class="sourceLine" id="cb221-2" data-line-number="2"><span class="ot">        odds ::</span> (<span class="dt">Integral</span> a) <span class="ot">=&gt;</span> [a] <span class="ot">-&gt;</span> [a]</a>
<a class="sourceLine" id="cb221-3" data-line-number="3">    odds [] <span class="fu">=</span> []</a>
<a class="sourceLine" id="cb221-4" data-line-number="4">    odds (x<span class="fu">:</span>xs) <span class="fu">=</span> <span class="kw">if</span> (x <span class="ot">`mod`</span> <span class="dv">2</span>) <span class="fu">/=</span> <span class="dv">0</span> </a>
<a class="sourceLine" id="cb221-5" data-line-number="5">                    <span class="kw">then</span> (x)<span class="fu">:</span>(odds xs)</a>
<a class="sourceLine" id="cb221-6" data-line-number="6">                    <span class="kw">else</span> odds xs</a></code></pre></div>
<p>What this does is check if the first element in the List is odd, and if so, combine it with <code>odds</code> called on the rest of the list. Otherwise, we’ll just return <code>odds</code> called on the rest of the List. And as usual, if the List is empty, we return the empty List.</p></li>
</ol>
<hr />
<p><strong><strong><em>Exercises</em></strong></strong>:</p>
<ol type="1">
<li><p>Write the <code>filter :: (a -&gt; Bool) -&gt; [a] -&gt; [a]</code> function, call it <code>filter'</code>. It takes a function of type <code>(a -&gt; Bool)</code> and a List of type <code>[a]</code>, and then <em>filters</em> the List by removing the elements where the function returns <code>false</code> when that element is passed into it. For example,</p>
<div class="sourceCode" id="cb222"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb222-1" data-line-number="1"><span class="dt">Prelude</span><span class="fu">&gt;</span> filter (\x <span class="ot">-&gt;</span> x <span class="fu">&gt;</span> <span class="dv">5</span>) [<span class="dv">1</span>,<span class="dv">2</span>,<span class="dv">3</span>,<span class="dv">4</span>,<span class="dv">5</span>,<span class="dv">6</span>,<span class="dv">7</span>,<span class="dv">8</span>,<span class="dv">9</span>,<span class="dv">10</span>,<span class="fu">-</span><span class="dv">20</span>,<span class="dv">400</span>] </a>
<a class="sourceLine" id="cb222-2" data-line-number="2">[<span class="dv">6</span>,<span class="dv">7</span>,<span class="dv">8</span>,<span class="dv">9</span>,<span class="dv">10</span>,<span class="dv">400</span>]</a></code></pre></div>
<p>Hint: Look at our <code>squares</code> function and our <code>map'</code> function.</p></li>
<li><p>Rewrite your filter function using <a href="##%20Guards">guards</a>.</p></li>
</ol>
<hr />
<h1 id="newtype">Newtype</h1>
<p>Sometimes you want to make a type that’s almost the same as another type. For example imagine our program calls for a <code>Dollar</code> type, a <code>Yen</code> type, and a <code>Euro</code> type, which are all just wrappers around <code>Double</code>. And let’s say also we had a <code>Currency</code> typeclass with a <code>convertToDollars</code> and <code>convertFromDollars</code> function. We’d like to add, subtract, and multiply our currency like we could regular numbers.</p>
<p>One way to make our types would be as follows:</p>
<div class="sourceCode" id="cb223"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb223-1" data-line-number="1"><span class="kw">data</span> <span class="dt">Dollar</span> <span class="fu">=</span> <span class="dt">Dollar</span> <span class="dt">Double</span>  <span class="kw">deriving</span> (<span class="dt">Read</span>, <span class="dt">Show</span>)</a>
<a class="sourceLine" id="cb223-2" data-line-number="2"><span class="kw">data</span> <span class="dt">Euro</span> <span class="fu">=</span> <span class="dt">Euro</span> <span class="dt">Double</span>      <span class="kw">deriving</span> (<span class="dt">Read</span>, <span class="dt">Show</span>)</a>
<a class="sourceLine" id="cb223-3" data-line-number="3"><span class="kw">data</span> <span class="dt">Yen</span> <span class="fu">=</span> <span class="dt">Yen</span> <span class="dt">Double</span>        <span class="kw">deriving</span> (<span class="dt">Read</span>, <span class="dt">Show</span>)</a></code></pre></div>
<p>Now, this has two issues. The first is that we can’t add or subtract two <code>Dollars</code>. We’d have to make each of these an instance of the <code>Num</code> typeclass, like this.</p>
<div class="sourceCode" id="cb224"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb224-1" data-line-number="1"><span class="kw">data</span> <span class="dt">Dollar</span> <span class="fu">=</span> <span class="dt">Dollar</span> <span class="dt">Double</span>  <span class="kw">deriving</span> (<span class="dt">Read</span>, <span class="dt">Show</span>)</a>
<a class="sourceLine" id="cb224-2" data-line-number="2"><span class="kw">data</span> <span class="dt">Euro</span> <span class="fu">=</span> <span class="dt">Euro</span> <span class="dt">Double</span>      <span class="kw">deriving</span> (<span class="dt">Read</span>, <span class="dt">Show</span>)</a>
<a class="sourceLine" id="cb224-3" data-line-number="3"><span class="kw">data</span> <span class="dt">Yen</span> <span class="fu">=</span> <span class="dt">Yen</span> <span class="dt">Double</span>        <span class="kw">deriving</span> (<span class="dt">Read</span>, <span class="dt">Show</span>)</a>
<a class="sourceLine" id="cb224-4" data-line-number="4"></a>
<a class="sourceLine" id="cb224-5" data-line-number="5"><span class="co">-- This, but for every currency:</span></a>
<a class="sourceLine" id="cb224-6" data-line-number="6"><span class="kw">instance</span> <span class="dt">Num</span> <span class="dt">Dollar</span> <span class="kw">where</span></a>
<a class="sourceLine" id="cb224-7" data-line-number="7">    (<span class="dt">Dollar</span> a) <span class="fu">+</span> (<span class="dt">Dollar</span> b) <span class="fu">=</span> <span class="dt">Dollar</span> (a <span class="fu">+</span> b) </a>
<a class="sourceLine" id="cb224-8" data-line-number="8">    (<span class="dt">Dollar</span> a) <span class="fu">-</span> (<span class="dt">Dollar</span> b) <span class="fu">=</span> <span class="dt">Dollar</span> (a <span class="fu">-</span> b) </a>
<a class="sourceLine" id="cb224-9" data-line-number="9">    (<span class="dt">Dollar</span> a) <span class="fu">*</span> (<span class="dt">Dollar</span> b) <span class="fu">=</span> <span class="dt">Dollar</span> (a <span class="fu">*</span> b) </a>
<a class="sourceLine" id="cb224-10" data-line-number="10">    negate (<span class="dt">Dollar</span> a) <span class="fu">=</span> <span class="dt">Dollar</span> (<span class="fu">-</span>a) </a>
<a class="sourceLine" id="cb224-11" data-line-number="11">    abs (<span class="dt">Dollar</span> a) <span class="fu">=</span> <span class="dt">Dollar</span> (abs a) </a></code></pre></div>
<p>This is some pretty boring boilerplate - it’d be almost the exact same for every currency! Wrapping one type (in our case, <code>Double</code>) in another (in our case, <code>Dollar</code>) is such a common need that we have special syntax for it, <code>newtype</code>.</p>
<div class="sourceCode" id="cb225"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb225-1" data-line-number="1"><span class="kw">newtype</span> <span class="dt">Dollar</span> <span class="fu">=</span> <span class="dt">Dollar</span> <span class="dt">Double</span>  <span class="kw">deriving</span> (<span class="dt">Read</span>, <span class="dt">Show</span>)</a>
<a class="sourceLine" id="cb225-2" data-line-number="2"><span class="kw">newtype</span> <span class="dt">Euro</span> <span class="fu">=</span> <span class="dt">Euro</span> <span class="dt">Double</span>      <span class="kw">deriving</span> (<span class="dt">Read</span>, <span class="dt">Show</span>)</a>
<a class="sourceLine" id="cb225-3" data-line-number="3"><span class="kw">newtype</span> <span class="dt">Yen</span> <span class="fu">=</span> <span class="dt">Yen</span> <span class="dt">Double</span>        <span class="kw">deriving</span> (<span class="dt">Read</span>, <span class="dt">Show</span>)</a></code></pre></div>
<p>The main difference between using <code>newtype</code> and <code>data</code> is that <code>newtype</code> only works with the very simple situation of wrapping one type in one other type. You can’t use sum types or have multiple types wrapped up in one. And there’s a special GHC feature that makes <code>newtype</code> much more useful by letting it automatically derive typeclasses for you, and you turn it on by putting <code>{-# LANGUAGE GeneralizedNewtypeDeriving #-}</code> at the top of your code. This is called a <em>pragma</em> to turn on a <em>language extension</em>. We’ll discuss these later, for now just know that putting that at the top of a file turns on an extra feature of GHC. Here’s how it looks in action:</p>
<div class="sourceCode" id="cb226"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb226-1" data-line-number="1"><span class="ot">{-# LANGUAGE GeneralizedNewtypeDeriving #-}</span></a>
<a class="sourceLine" id="cb226-2" data-line-number="2"></a>
<a class="sourceLine" id="cb226-3" data-line-number="3"><span class="kw">newtype</span> <span class="dt">Dollar</span> <span class="fu">=</span> <span class="dt">Dollar</span> <span class="dt">Double</span>  <span class="kw">deriving</span> (<span class="dt">Read</span>, <span class="dt">Show</span>, <span class="dt">Num</span>)</a>
<a class="sourceLine" id="cb226-4" data-line-number="4"><span class="kw">newtype</span> <span class="dt">Euro</span> <span class="fu">=</span> <span class="dt">Euro</span> <span class="dt">Double</span>      <span class="kw">deriving</span> (<span class="dt">Read</span>, <span class="dt">Show</span>, <span class="dt">Num</span>)</a>
<a class="sourceLine" id="cb226-5" data-line-number="5"><span class="kw">newtype</span> <span class="dt">Yen</span> <span class="fu">=</span> <span class="dt">Yen</span> <span class="dt">Double</span>        <span class="kw">deriving</span> (<span class="dt">Read</span>, <span class="dt">Show</span>, <span class="dt">Num</span>)</a></code></pre></div>
<p>With <code>GeneralizedNewtypeDeriving</code> turned on, we were able to add <code>Num</code> to our list of typeclasses we’d like to be automatically derived, which is very useful! We’d be able to run <code>(Dollar 3) + (Dollar 4)</code> to get <code>Dollar 7.0</code>.</p>
<p>There’s one other difference between <code>newtype</code> and <code>data</code>. Specifically, whether the constructor is strict or lazy. Imagine the following:</p>
<div class="sourceCode" id="cb227"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb227-1" data-line-number="1"><span class="kw">data</span> <span class="dt">D</span> <span class="fu">=</span> <span class="dt">D</span> <span class="dt">Int</span></a>
<a class="sourceLine" id="cb227-2" data-line-number="2"><span class="kw">newtype</span> <span class="dt">N</span> <span class="fu">=</span> <span class="dt">N</span> <span class="dt">Int</span></a></code></pre></div>
<p>Now, you may remember that Haskell tries to only evaluate things when really necessary, so if you write <code>1+2</code> it won’t actually evaluate that until it needs to. Haskell also has a special value named <code>undefined</code> which you can pass to any function and causes your program to instantly crash when it’s evaluated.</p>
<div class="sourceCode" id="cb228"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb228-1" data-line-number="1"><span class="dt">Prelude</span><span class="fu">&gt;</span> undefined</a>
<a class="sourceLine" id="cb228-2" data-line-number="2"><span class="co">-- Error!</span></a></code></pre></div>
<p>But, it won’t evaluate it until it has to.</p>
<div class="sourceCode" id="cb229"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb229-1" data-line-number="1"><span class="dt">Prelude</span><span class="fu">&gt;</span> a <span class="fu">=</span> undefined</a>
<a class="sourceLine" id="cb229-2" data-line-number="2"><span class="co">-- Works fine, until we try to use a</span></a></code></pre></div>
<p>You can even pass it to a function, and if the function doesn’t look at it your program will still run.</p>
<div class="sourceCode" id="cb230"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb230-1" data-line-number="1"><span class="dt">Prelude</span><span class="fu">&gt;</span> a <span class="fu">=</span> undefined</a>
<a class="sourceLine" id="cb230-2" data-line-number="2"><span class="dt">Prelude</span><span class="fu">&gt;</span> silly v <span class="fu">=</span> <span class="st">&quot;silly&quot;</span></a>
<a class="sourceLine" id="cb230-3" data-line-number="3"><span class="dt">Prelude</span><span class="fu">&gt;</span> silly a</a>
<a class="sourceLine" id="cb230-4" data-line-number="4"><span class="st">&quot;silly&quot;</span></a></code></pre></div>
<p>Now, we’d like our <code>Dollar</code> to function identically to a <code>Double</code>. But if we defined it with <code>data</code>, it wouldn’t! Let’s see how.</p>
<div class="sourceCode" id="cb231"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb231-1" data-line-number="1"><span class="dt">Prelude</span><span class="fu">&gt;</span> sillyD (<span class="dt">Dollar</span> v) <span class="fu">=</span> <span class="st">&quot;silly&quot;</span></a>
<a class="sourceLine" id="cb231-2" data-line-number="2"><span class="dt">Prelude</span><span class="fu">&gt;</span> sillyD undefined</a>
<a class="sourceLine" id="cb231-3" data-line-number="3"><span class="co">-- error!</span></a></code></pre></div>
<p>We could run <code>silly undefined</code> without crashing, but we can’t for <code>sillyD undefined</code>! However, this works as expected with <code>newtype</code>.</p>
<div class="sourceCode" id="cb232"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb232-1" data-line-number="1"><span class="dt">Prelude</span><span class="fu">&gt;</span> sillyD (<span class="dt">Dollar</span> v) <span class="fu">=</span> <span class="st">&quot;silly&quot;</span></a>
<a class="sourceLine" id="cb232-2" data-line-number="2"><span class="dt">Prelude</span><span class="fu">&gt;</span> sillyD undefined</a>
<a class="sourceLine" id="cb232-3" data-line-number="3"><span class="st">&quot;silly&quot;</span></a></code></pre></div>
<p>This difference is somewhat technical and academic, but I thought it was worth discussing. To reiterate:</p>
<ol type="1">
<li><p><code>data</code> is for making new, complicated types, like <code>data Person = Bob | Cindy | Sue</code>.</p></li>
<li><p><code>newtype</code> is for “decorating” or making a copy of an existing type, like <code>newtype Dollar = Dollar Double</code>.</p></li>
<li><p><code>type</code> is for renaming a type, like <code>type Polygon = [Point]</code>, which just makes <code>Dollar</code> be equivalent to <code>Double</code> and is mostly only used for making certain code easier to read.</p></li>
</ol>
<h1 id="writing-real-haskell-programs">Writing Real Haskell Programs</h1>
<p><span class="newthought">There are</span> a few things you must be able to do before you can write real Haskell programs. You need to be able to write a program, compile it, and run it. You need to be able to make this program do things that contain the dreaded <em>side-effects</em> - stuff that pure functions can’t do, like read files or write text to the terminal. And, most importantly, you need a stylish environment to develop your Haskell in!</p>
<h2 id="environment">Environment</h2>
<p><span class="newthought">For developing</span> Haskell, there are many excellent options. There’s <a href="https://code.visualstudio.com/">VSCode</a> with <a href="https://marketplace.visualstudio.com/items?itemName=Vans.haskero">Haskero</a> (what I personally use), <a href="http://spacemacs.org/">Spacemacs</a> (which is great if you’re used to Emacs or Vim), and <a href="https://www.gnu.org/software/emacs/">Emacs</a> with <a href="https://github.com/jyp/dante">Dante</a> are common options. Extensions also exist for Atom and Sublime Text. I will be assuming you use the same setup as me, VSCode and Haskero.</p>
<p>In VSCode I find the <code>&quot;files.autoSave&quot;: &quot;onFocusChange&quot;</code> setting to be invaluable, as it will mostly keep your files saved without too much trouble This also works well with some GHC options that automatically rebuild your code every time it changes, more on that later. I recommend checking if your favorite text editor has something similar.</p>
<h2 id="stack-projects">Stack Projects</h2>
<h2 id="definitions">Definitions</h2>
<p>First some quick names you might not be familiar with.</p>
<ol type="1">
<li><p><strong>GHC</strong> is a Haskell compiler. It reads your Haskell source code and <em>compiles</em> it into a form readable by a computer. There are many other Haskell compilers, but GHC is the best<label for="marginnote-71" class="margin-toggle">⊕</label> <input type="checkbox" id="marginnote-71" class="margin-toggle"/> <span class="marginnote">It’s somewhat unfortunate that there’s only one popular Haskell compiler, since it’s not without issues. But in general it’s very nice, especially with all the nonstandard but very useful language extensions it contains.</span>. You got it when you installed the Haskell platform.</p></li>
<li><p><strong>Cabal</strong> is a file format for describing certain information about your project. There’s also a tool called Cabal, but we won’t be using it. Well, we’ll be using Stack, which uses Cabal in the backend. The file you describe your package in is normally called <code>projectName.cabal</code><label for="sidenote-59" class="margin-toggle sidenote-number"></label> <input type="checkbox" id="sidenote-59" class="margin-toggle"/> <span class="sidenote">Obviously, <code>projectName</code> replaced with the name of your project.</span>.</p></li>
<li><p><strong>Stack</strong> is a program for managing the packages you use in your project. It is mostly used to aid in using 3rd party code and installing the correct version of GHC. It has a file called <code>stack.yaml</code>, but also reads <code>&lt;projectName&gt;.cabal</code>, and confusingly a file named <code>package.yaml</code> that overrides <code>&lt;projectName&gt;.cabal</code>. An important goal of Stack is that if it works on my machine, it should work the exact same way on yours, too. This is called <em>reproducible builds</em><label for="marginnote-72" class="margin-toggle">⊕</label> <input type="checkbox" id="marginnote-72" class="margin-toggle"/> <span class="marginnote">The goal actually is that it creates the exact same binary, so it’s <em>guaranteed</em> to run the same way.</span>, and is a very helpful property. You already got Stack when you installed the Haskell platform.</p></li>
</ol>
<h2 id="creating-a-project">Creating a Project</h2>
<p><span class="newthought">Stack contains</span> many useful features. One is that it allows you to instantly create projects according to some <a href="https://github.com/commercialhaskell/stack-templates">common templates</a>. The one we will use is <code>simple</code>. In a terminal, navigate to your development directory and run the following.</p>
<div class="sourceCode" id="cb233"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb233-1" data-line-number="1">stack new project1 simple <span class="fu">-</span>p <span class="st">&quot;author-name:Andre Popovitch&quot;</span></a></code></pre></div>
<p>This will make a new project called <code>project1</code> according to the <code>simple</code> template, and in the licence text it will attribute everything to me<label for="marginnote-73" class="margin-toggle">⊕</label> <input type="checkbox" id="marginnote-73" class="margin-toggle"/> <span class="marginnote">There are a number of other parameters you can use as well. They are <code>author-email</code>, <code>author-name</code>, <code>category</code>, <code>copyright</code>, <code>year</code> and <code>github-username</code>.</span>! Of course, you can change this to your name if you’d prefer I don’t own copyright over all the code in your project. After running this, you’ll see a lot of output in the terminal. Hopefully it’ll look something like this:</p>
<div class="sourceCode" id="cb234"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb234-1" data-line-number="1">λ stack new project1 simple <span class="fu">-</span>p <span class="st">&quot;author-name:Andre Popovitch&quot;</span></a>
<a class="sourceLine" id="cb234-2" data-line-number="2"><span class="dt">Downloading</span> template <span class="st">&quot;simple&quot;</span> to create project <span class="st">&quot;project1&quot;</span> <span class="kw">in</span> project1\ <span class="fu">...</span></a>
<a class="sourceLine" id="cb234-3" data-line-number="3"></a>
<a class="sourceLine" id="cb234-4" data-line-number="4">[<span class="fu">...</span>]</a>
<a class="sourceLine" id="cb234-5" data-line-number="5"></a>
<a class="sourceLine" id="cb234-6" data-line-number="6"><span class="dt">Selected</span> resolver<span class="fu">:</span> lts<span class="fu">-</span><span class="fl">12.8</span></a>
<a class="sourceLine" id="cb234-7" data-line-number="7"><span class="dt">Initialising</span> configuration using resolver<span class="fu">:</span> lts<span class="fu">-</span><span class="fl">12.8</span></a>
<a class="sourceLine" id="cb234-8" data-line-number="8"><span class="dt">Total</span> number <span class="kw">of</span> user packages considered<span class="fu">:</span> <span class="dv">1</span></a>
<a class="sourceLine" id="cb234-9" data-line-number="9"><span class="dt">Writing</span> configuration to file<span class="fu">:</span> project1\stack<span class="fu">.</span>yaml</a>
<a class="sourceLine" id="cb234-10" data-line-number="10"><span class="dt">All</span> done<span class="fu">.</span></a></code></pre></div>
<p>And here what the contents of the <code>project1</code> folder should be<label for="marginnote-74" class="margin-toggle">⊕</label> <input type="checkbox" id="marginnote-74" class="margin-toggle"/> <span class="marginnote">This uses the <code>cd</code> command and the <code>ls</code> command. <code>cd</code> is short for “change directory”, and allows you to navigate to a different folder (in our case, the one we just made). <code>ls</code> is short for “list”, and lists all the files and folders in the folder we’re currently in.</span>:</p>
<div class="sourceCode" id="cb235"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb235-1" data-line-number="1">λ cd project1\</a>
<a class="sourceLine" id="cb235-2" data-line-number="2">λ ls</a>
<a class="sourceLine" id="cb235-3" data-line-number="3"><span class="dt">LICENSE</span>  README.md  Setup.hs  project1<span class="fu">.</span>cabal  src  stack<span class="fu">.</span>yaml</a></code></pre></div>
<p><span class="newthought">First on</span> the List is the <code>LICENSE</code> file. Open it in your favorite text editor (mine is VSCode) and take a look. If you plan to share your code, this license bears looking at. If you don’t care who uses it, the current license is fine. Otherwise, check out <a href="https://choosealicense.com/">ChooseALicense</a> to pick one that works for you. If you don’t want anyone to use your code, just replace the contents of this file with the text <code>no license provided, all rights reserved</code>.</p>
<p><span class="newthought">Next up</span> is the <code>README.md</code> file. This is used by other programmers or possible users of your software to determine what it’s purpose is and how to use it<label for="sidenote-60" class="margin-toggle sidenote-number"></label> <input type="checkbox" id="sidenote-60" class="margin-toggle"/> <span class="sidenote">It’s also the file that will be displayed front-and-center if you ever decide to share your project on <a href="https://github.com/">Github</a> or <a href="https://about.gitlab.com/">Gitlab</a>.</span>. If you intend on sharing your code, it’s wise to put some information about your project here. Even if you don’t plan on sharing, this can be a useful place to leave notes to your future self.</p>
<p><span class="newthought">Following that</span> begins the real meat of our project. <code>Setup.hs</code> contains only two lines.</p>
<div class="sourceCode" id="cb236"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb236-1" data-line-number="1"><span class="co">-- Setup.hs</span></a>
<a class="sourceLine" id="cb236-2" data-line-number="2"><span class="kw">import</span> <span class="dt">Distribution.Simple</span></a>
<a class="sourceLine" id="cb236-3" data-line-number="3">main <span class="fu">=</span> defaultMain</a></code></pre></div>
<p>The purpose of this code is somewhat complicated to explain right now, just know that most projects shouldn’t have to modify it or really care about what it does.</p>
<p><span class="newthought">Next up</span> is <code>project1.cabal</code>. Remember the <code>.cabal</code> files I mentioned earlier? This is one of those. Let’s see what it contains.</p>
<div class="sourceCode" id="cb237"><pre class="sourceCode yaml"><code class="sourceCode yaml"><a class="sourceLine" id="cb237-1" data-line-number="1"><span class="fu">name:</span><span class="at">                project1</span></a>
<a class="sourceLine" id="cb237-2" data-line-number="2"><span class="fu">version:</span><span class="at">             0.1.0.0</span></a>
<a class="sourceLine" id="cb237-3" data-line-number="3"><span class="kw">-</span>- <span class="fu">synopsis:</span></a>
<a class="sourceLine" id="cb237-4" data-line-number="4"><span class="kw">-</span>- <span class="fu">description:</span></a>
<a class="sourceLine" id="cb237-5" data-line-number="5"><span class="fu">homepage:</span><span class="at">            https://github.com/githubuser/project1</span><span class="co">#readme</span></a>
<a class="sourceLine" id="cb237-6" data-line-number="6"><span class="fu">license:</span><span class="at">             BSD3</span></a>
<a class="sourceLine" id="cb237-7" data-line-number="7"><span class="fu">license-file:</span><span class="at">        LICENSE</span></a>
<a class="sourceLine" id="cb237-8" data-line-number="8"><span class="fu">author:</span><span class="at">              Andre Popovitch</span></a>
<a class="sourceLine" id="cb237-9" data-line-number="9"><span class="fu">maintainer:</span><span class="at">          example@example.com</span></a>
<a class="sourceLine" id="cb237-10" data-line-number="10"><span class="fu">copyright:</span><span class="at">           2018 Andre Popovitch</span></a>
<a class="sourceLine" id="cb237-11" data-line-number="11"><span class="fu">category:</span><span class="at">            Web</span></a>
<a class="sourceLine" id="cb237-12" data-line-number="12"><span class="fu">build-type:</span><span class="at">          Simple</span></a>
<a class="sourceLine" id="cb237-13" data-line-number="13"><span class="fu">cabal-version:</span><span class="at">       &gt;=1.10</span></a>
<a class="sourceLine" id="cb237-14" data-line-number="14"><span class="fu">extra-source-files:</span><span class="at">  README.md</span></a>
<a class="sourceLine" id="cb237-15" data-line-number="15"></a>
<a class="sourceLine" id="cb237-16" data-line-number="16">executable project1</a>
<a class="sourceLine" id="cb237-17" data-line-number="17">  <span class="fu">hs-source-dirs:</span><span class="at">      src</span></a>
<a class="sourceLine" id="cb237-18" data-line-number="18">  <span class="fu">main-is:</span><span class="at">             Main.hs</span></a>
<a class="sourceLine" id="cb237-19" data-line-number="19">  <span class="fu">default-language:</span><span class="at">    Haskell2010</span></a>
<a class="sourceLine" id="cb237-20" data-line-number="20">  <span class="fu">build-depends:</span><span class="at">       base &gt;= 4.7 &amp;&amp; &lt; 5</span></a></code></pre></div>
<p>Most of this is just data presented in the machine-readable format YAML. so someone could search a database for all projects written by <code>Andre Popovitch</code> or similar. This is also where we’d add project dependencies (I’ll show you how to do that later).</p>
<p><span class="newthought">Next is</span> the <code>src</code> folder, which only contains one file, <code>Main.hs</code>. This is where we’d start writing our actual program. Here are the contents of <code>Main.hs</code>.</p>
<div class="sourceCode" id="cb238"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb238-1" data-line-number="1"><span class="co">-- Main.hs</span></a>
<a class="sourceLine" id="cb238-2" data-line-number="2"><span class="kw">module</span> <span class="dt">Main</span> <span class="kw">where</span></a>
<a class="sourceLine" id="cb238-3" data-line-number="3"></a>
<a class="sourceLine" id="cb238-4" data-line-number="4"><span class="ot">main ::</span> <span class="dt">IO</span> ()</a>
<a class="sourceLine" id="cb238-5" data-line-number="5">main <span class="fu">=</span></a>
<a class="sourceLine" id="cb238-6" data-line-number="6">  putStrLn <span class="st">&quot;Hello, World!&quot;</span></a></code></pre></div>
<p>Every single line of this program contains something we haven’t talked about yet. Let’s go over them now.</p>
<ol type="1">
<li><p><code>module Main where</code>: This defines a new <em>module</em> called <code>Main</code>, which contains the full contents of the file below it. Modules are collections of related code - they’re nice because if you break your project into small modules, you can reuse them in future projects or share them with the world<label for="marginnote-75" class="margin-toggle">⊕</label> <input type="checkbox" id="marginnote-75" class="margin-toggle"/> <span class="marginnote">There are many sites where you can share your code, but the largest is (Hackage)[https://hackage.haskell.org/]. It’s often a good idea to search here if you’re looking for third-party code, just beware because much of it is somewhat low quality.</span> for fame and fortune.</p></li>
<li><p><code>main :: IO ()</code>: This is the type signature for the function <code>main</code>. Its type is <code>IO ()</code>, which seems like a very strange type. It would seem to be a function that takes no arguments, and returns a value of type <code>IO ()</code>? It won’t make complete sense until the next chapter, but for now, remember two things.</p>
<ol type="1">
<li><p><code>IO</code> is a type constructor which takes a type<label for="marginnote-76" class="margin-toggle">⊕</label> <input type="checkbox" id="marginnote-76" class="margin-toggle"/> <span class="marginnote">You should be familiar with other type constructors from the last chapter. They’re things like <code>Maybe</code> or <code>Either</code>, they take one or more types and return a concrete type.</span>. But <code>IO</code> is special and known by the Haskell runtime, and it’s the magic that allows us to accomplish impure things, like reading and writing files or printing to the terminal.</p></li>
<li><p><code>()</code> is the type of a tuple with nothing in it. The tuples we’ve seen before have all had types like <code>(Int, Bool)</code> or <code>(Int, Int, Int)</code>, but they can have one or even no values, like <code>(Int)</code> or <code>()</code>. The only tuple of type <code>()</code> is <code>()</code><label for="marginnote-77" class="margin-toggle">⊕</label> <input type="checkbox" id="marginnote-77" class="margin-toggle"/> <span class="marginnote">Since the type <code>()</code> only has one value, it takes no memory at runtime.</span>, which is sometimes pronounced “unit”.</p></li>
</ol></li>
<li><p><code>main = do</code>: <code>main</code> is a special function that Haskell treats in a different way from all the rest. It’s similar to <code>main</code> functions in other languages: it’s the function Haskell calls for you, so it’s where your program begins<label for="marginnote-78" class="margin-toggle">⊕</label> <input type="checkbox" id="marginnote-78" class="margin-toggle"/> <span class="marginnote"><code>main</code> has some other unique properties as well, relating to <code>IO</code>.</span>. What we have on this line is the first line of a multi-line function.</p>
<p><code>do</code> is special syntax that we won’t cover until the next section, so don’t worry about it just yet. In our case, the program would evaluate the exact same without it, so <strong>just delete it for now</strong>. This is the first change we’re making to this project!</p></li>
<li><p><code>putStrLn &quot;hello world&quot;</code>: Like <code>print</code>, <code>printf</code>, or <code>console.log</code> in other languages, <code>putStrLn</code> is a function that takes some text and writes it to the terminal (with a newline at the end). Now I know what you’re thinking - that sounds impure! How can a Haskell function, which is supposed to take some input and return a result based on that input and do nothing else, possibly write to the terminal! And what would it return? Well, that will be clear if we examine the type of <code>putStrLn</code>.</p>
<div class="sourceCode" id="cb239"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb239-1" data-line-number="1"><span class="dt">Prelude</span><span class="fu">&gt;</span> <span class="fu">:</span>t putStrLn</a>
<a class="sourceLine" id="cb239-2" data-line-number="2">putStrLn<span class="ot"> ::</span> <span class="dt">String</span> <span class="ot">-&gt;</span> <span class="dt">IO</span> ()</a></code></pre></div>
<p>So it takes a value of type String and returns a value of type <code>IO ()</code>? Well that makes some sense to the typechecker, since <code>main</code>’s type is <code>IO ()</code>. But what does all this <code>IO ()</code> business actually mean? I will explain that very soon.</p></li>
</ol>
<h2 id="running-the-project">Running the Project</h2>
<p><span class="newthought">Now, we</span> need to run this! A very easy way to test our work is to load it in GHCi. In the root directory of <code>project1</code>, run <code>stack ghci</code>. This is similar to running <code>ghci</code> on its own, but it’s a special Stack command that will automatically load the project.</p>
<p>Running <code>stack ghci</code>, you should see some output then eventually be greeted by a somewhat-familiar prompt.</p>
<div class="sourceCode" id="cb240"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb240-1" data-line-number="1"><span class="fu">*</span><span class="dt">Main</span><span class="fu">&gt;</span></a></code></pre></div>
<p>Now, remember our confusing <code>main</code> function from before? It takes no parameters, so we can just type <code>main</code> to run it.</p>
<div class="sourceCode" id="cb241"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb241-1" data-line-number="1"><span class="fu">*</span><span class="dt">Main</span><span class="fu">&gt;</span> main</a>
<a class="sourceLine" id="cb241-2" data-line-number="2">hello world</a></code></pre></div>
<p>This is how we run our program for testing. Note that this is the first time we’ve seen something like this! if our main function was just defined as the string <code>&quot;hello world&quot;</code>, we’d see quotes around it.</p>
<div class="sourceCode" id="cb242"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb242-1" data-line-number="1"><span class="fu">*</span><span class="dt">Main</span><span class="fu">&gt;</span> main&#39; <span class="fu">=</span> <span class="st">&quot;hello world&quot;</span></a>
<a class="sourceLine" id="cb242-2" data-line-number="2"><span class="fu">*</span><span class="dt">Main</span><span class="fu">&gt;</span> main&#39;</a>
<a class="sourceLine" id="cb242-3" data-line-number="3"><span class="st">&quot;hello world&quot;</span></a></code></pre></div>
<p>We can also just write <code>putStrLn &quot;hello world&quot;</code> to print <code>hello world</code>, instead of calling <code>main</code><label for="marginnote-79" class="margin-toggle">⊕</label> <input type="checkbox" id="marginnote-79" class="margin-toggle"/> <span class="marginnote">Remember, <code>putStrLn</code> takes a string, prints it to the terminal, then returns an <code>IO ()</code>.</span>.</p>
<div class="sourceCode" id="cb243"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb243-1" data-line-number="1"><span class="fu">*</span><span class="dt">Main</span><span class="fu">&gt;</span> putStrLn <span class="st">&quot;hello world&quot;</span></a>
<a class="sourceLine" id="cb243-2" data-line-number="2">hello world</a></code></pre></div>
<p>Let’s change our function from printing a boring <code>hello world</code> to a more modern <code>Hello, World!</code>. Just go into <code>src/Main.hs</code> and change</p>
<div class="sourceCode" id="cb244"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb244-1" data-line-number="1">main <span class="fu">=</span></a>
<a class="sourceLine" id="cb244-2" data-line-number="2">  putStrLn <span class="st">&quot;hello world&quot;</span></a></code></pre></div>
<p>to</p>
<div class="sourceCode" id="cb245"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb245-1" data-line-number="1">main <span class="fu">=</span></a>
<a class="sourceLine" id="cb245-2" data-line-number="2">  putStrLn <span class="st">&quot;Hello, World!&quot;</span></a></code></pre></div>
<p>Then go back to GHCi and type <code>:r</code>. Short for <code>:reload</code>, this reloads everything we’ve loaded into GHCi.</p>
<div class="sourceCode" id="cb246"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb246-1" data-line-number="1"><span class="fu">*</span><span class="dt">Main</span><span class="fu">&gt;</span> <span class="fu">:</span>r</a>
<a class="sourceLine" id="cb246-2" data-line-number="2">[<span class="dv">1</span> <span class="kw">of</span> <span class="dv">1</span>] <span class="dt">Compiling</span> <span class="dt">Main</span> ( <span class="fu">...</span>\project1\src\Main.hs, interpreted )</a>
<a class="sourceLine" id="cb246-3" data-line-number="3"><span class="dt">Ok</span>, one <span class="kw">module</span> loaded<span class="fu">.</span></a>
<a class="sourceLine" id="cb246-4" data-line-number="4"><span class="fu">*</span><span class="dt">Main</span><span class="fu">&gt;</span> main</a>
<a class="sourceLine" id="cb246-5" data-line-number="5"><span class="dt">Hello</span>, <span class="dt">World</span><span class="fu">!</span></a></code></pre></div>
<p>Now, it’s time to explain what all this strange <code>IO ()</code> business represents.</p>
<h2 id="containing-impurity">Containing Impurity</h2>
<p><span class="newthought">This section</span> provides background for the next but is not required for understanding anything in this book. However, I think it’s quite interesting!</p>
<p>Haskell has some important principles. First, purity, which includes <em>referential transparency</em>. It means if you call a function, and the function returns <code>3</code>, that’s the same as if you just wrote <code>3</code> instead of calling the function with those parameters. <strong>Functions in Haskell must always return the same value for the same parameters</strong>. The other restriction, which is closely related, is a lack of side effects. This means functions can’t do anything besides return a result. They can’t write a file, open a browser, draw to the screen, etc. This provides Haskell with an issue: how is it supposed to do anything productive if functions can’t do anything besides return values? We couldn’t print to the terminal, draw on the screen, or do anything interesting.</p>
<p>This conundrum is resolved with two things: the <code>main</code> function, and the <code>IO</code> type constructor.</p>
<p><code>main</code> is a special Haskell function. Your <code>main</code> function will be automatically executed by Haskell, and it should be of type <code>IO ()</code>. Haskell will evaluate this function, and execute all the <em>IO actions</em> returned by <code>main</code>. An example of an IO action is the output of <code>putStrLn &quot;hello&quot;</code>. It contains some instructions to Haskell telling it to print <code>hello</code>. <code>IO</code> and <code>main</code> are <em>magic</em> in Haskell. That means they’re special constructs that let you do things that would be impossible otherwise<label for="marginnote-80" class="margin-toggle">⊕</label> <input type="checkbox" id="marginnote-80" class="margin-toggle"/> <span class="marginnote">On the other hand, <code>do</code> is not magic. It’s just special syntax, which is very helpful but we won’t be using it just yet. <code>IO</code> is somewhat complicated, and it’s easier if you don’t have strange magic-seeming syntax confusing you.</span></p>
<p><span class="newthought">Here’s why</span> we need <code>IO</code>. Let’s say we had a function that was very un-Haskell-like. Imagine a hypothetical function <code>readFromFoo</code>. The first time you call it, it will open a file <code>Foo.txt</code> and return the first character. The second time, it will return the second character. The third time, it will return the third character, etc. <code>readFromFoo</code> is <strong>not</strong> a real function, so this won’t work, but here’s how it might look in GHCi.</p>
<p><label for="marginfigure-2" class="margin-toggle">⊕</label> <input type="checkbox" id="marginfigure-2" class="margin-toggle"/> <span class="marginnote"><img src="assets/exp_impurity_demo.svg" alt="`readFromFoo` is impure - it does not have the same output for the same input (in this case, no input)."/><code>readFromFoo</code> is impure - it does not have the same output for the same input (in this case, no input).</span></p>
<div class="sourceCode" id="cb247"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb247-1" data-line-number="1"><span class="dt">Prelude</span><span class="fu">&gt;</span> <span class="fu">:</span>t readFromFoo</a>
<a class="sourceLine" id="cb247-2" data-line-number="2"><span class="ot">readFromFoo ::</span> <span class="dt">Char</span></a>
<a class="sourceLine" id="cb247-3" data-line-number="3"><span class="co">-- For example purposes, let&#39;s say `Foo.txt` contains `ABC123`.</span></a>
<a class="sourceLine" id="cb247-4" data-line-number="4"><span class="dt">Prelude</span><span class="fu">&gt;</span> readFromFoo</a>
<a class="sourceLine" id="cb247-5" data-line-number="5"><span class="ch">&#39;A&#39;</span></a>
<a class="sourceLine" id="cb247-6" data-line-number="6"><span class="dt">Prelude</span><span class="fu">&gt;</span> readFromFoo</a>
<a class="sourceLine" id="cb247-7" data-line-number="7"><span class="ch">&#39;B&#39;</span></a>
<a class="sourceLine" id="cb247-8" data-line-number="8"><span class="dt">Prelude</span><span class="fu">&gt;</span> readFromFoo</a>
<a class="sourceLine" id="cb247-9" data-line-number="9"><span class="ch">&#39;C&#39;</span></a>
<a class="sourceLine" id="cb247-10" data-line-number="10"><span class="dt">Prelude</span><span class="fu">&gt;</span> readFromFoo</a>
<a class="sourceLine" id="cb247-11" data-line-number="11"><span class="ch">&#39;1&#39;</span></a>
<a class="sourceLine" id="cb247-12" data-line-number="12"><span class="dt">Prelude</span><span class="fu">&gt;</span> readFromFoo</a>
<a class="sourceLine" id="cb247-13" data-line-number="13"><span class="ch">&#39;2&#39;</span></a>
<a class="sourceLine" id="cb247-14" data-line-number="14"><span class="dt">Prelude</span><span class="fu">&gt;</span> readFromFoo</a>
<a class="sourceLine" id="cb247-15" data-line-number="15"><span class="ch">&#39;3&#39;</span></a></code></pre></div>
<p>This is an impure function. As you can see, every time we call it, its input stays the same (we don’t pass it anything), but its output changes. This is bad because GHC assumes all functions are pure. This means that it will assume that if it evaluated <code>readFromFoo</code> once, it won’t have to evaluate it again, and can just re-use the same result from last time. So our code might actually end up looking like this!</p>
<div class="sourceCode" id="cb248"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb248-1" data-line-number="1"><span class="dt">Prelude</span><span class="fu">&gt;</span> readFromFoo</a>
<a class="sourceLine" id="cb248-2" data-line-number="2"><span class="ch">&#39;A&#39;</span></a>
<a class="sourceLine" id="cb248-3" data-line-number="3"><span class="dt">Prelude</span><span class="fu">&gt;</span> readFromFoo</a>
<a class="sourceLine" id="cb248-4" data-line-number="4"><span class="ch">&#39;A&#39;</span></a>
<a class="sourceLine" id="cb248-5" data-line-number="5"><span class="dt">Prelude</span><span class="fu">&gt;</span> readFromFoo</a>
<a class="sourceLine" id="cb248-6" data-line-number="6"><span class="ch">&#39;A&#39;</span></a>
<a class="sourceLine" id="cb248-7" data-line-number="7">[<span class="fu">...</span>]</a></code></pre></div>
<p>This is obviously not what we intended<label for="marginnote-81" class="margin-toggle">⊕</label> <input type="checkbox" id="marginnote-81" class="margin-toggle"/> <span class="marginnote">The issue, really, is that GHC assumes functions are pure and does optimizations based on that assumption. If that assumption is not correct, then GHC’s attempts at optimization can break our code! This section discusses how we can force GHC to not optimize our impure functions.</span>. But that’s okay, this is easily fixed. GHC will only try to reuse the old results if the parameters were the same. So we can just add a parameter that does nothing, just to keep GHC from re-using old results, and the output will be what we want.</p>
<div class="sourceCode" id="cb249"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb249-1" data-line-number="1"><span class="dt">Prelude</span><span class="fu">&gt;</span> readFromFoo <span class="dv">17281</span></a>
<a class="sourceLine" id="cb249-2" data-line-number="2"><span class="ch">&#39;A&#39;</span></a>
<a class="sourceLine" id="cb249-3" data-line-number="3"><span class="dt">Prelude</span><span class="fu">&gt;</span> readFromFoo <span class="dv">387</span></a>
<a class="sourceLine" id="cb249-4" data-line-number="4"><span class="ch">&#39;B&#39;</span></a>
<a class="sourceLine" id="cb249-5" data-line-number="5"><span class="dt">Prelude</span><span class="fu">&gt;</span> readFromFoo <span class="dv">2811002</span></a>
<a class="sourceLine" id="cb249-6" data-line-number="6"><span class="ch">&#39;C&#39;</span></a></code></pre></div>
<p>I just made these numbers by typing randomly on my keyboard. But this seems kind of inelegant - having to spam your keyboard every time we want to read from our file. But there’s an even bigger issue that this doesn’t even fix!</p>
<p>Haskell provides very few guarantees about the order you can expect evaluation to happen. We only know one function <code>a</code> will be called before function <code>b</code> if the result of <code>a</code> is a parameter to <code>b</code><label for="marginnote-82" class="margin-toggle">⊕</label> <input type="checkbox" id="marginnote-82" class="margin-toggle"/> <span class="marginnote">This is called <a href="https://www.wikiwand.com/en/Dependency_injection">dependency injection</a>.</span>. For example, in <code>foo (bar x)</code>, <code>bar</code> must be evaluated before <code>foo</code>, because an output of <code>bar</code> is an input of <code>foo</code>.</p>
<p>That’s not the case here, so we don’t know what order evaluation will happen in! Consider the following function:</p>
<div class="sourceCode" id="cb250"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb250-1" data-line-number="1">readFromFooTwice <span class="fu">=</span> [first, second] </a>
<a class="sourceLine" id="cb250-2" data-line-number="2">                   <span class="kw">where</span> first <span class="fu">=</span> readFromFoo <span class="dv">2423</span></a>
<a class="sourceLine" id="cb250-3" data-line-number="3">                         second <span class="fu">=</span> readFromFoo <span class="dv">414</span></a></code></pre></div>
<p>The random numbers keep Haskell from re-using the value of <code>readFromFoo</code>. But, GHC would be free to evaluate the two <code>readFromFoo</code>s in any order it wanted! If we’re lucky we could get <code>first</code> evaluated first, and <code>second</code> evaluated second, in which case <code>readFromFooTwice</code> would return <code>&quot;AB&quot;</code><label for="marginnote-83" class="margin-toggle">⊕</label> <input type="checkbox" id="marginnote-83" class="margin-toggle"/> <span class="marginnote">Remember, calling <code>readFromFoo</code> 6 times is supposed to return <code>'A'</code>, <code>'B'</code>, <code>'C'</code>, <code>'1'</code>, <code>'2'</code>, <code>'3'</code>.</span>. But they could just as easily be evaluated in the opposite order, leaving us with <code>&quot;BA&quot;</code>! To fix this, let’s change what <code>readFromFoo</code> actually does. Now, instead of just returning a <code>Char</code>, it’ll return a tuple of type <code>(Char, Int)</code>. The <code>Int</code> is just whatever <code>Int</code> we passed in, incremented by one.</p>
<pre><code>Prelude&gt; readFromFoo =
(&#39;A&#39;, 1)
Prelude&gt; readFromFoo 387
(&#39;B&#39;, 388)</code></pre>
<p><label for="marginfigure-3" class="margin-toggle">⊕</label> <input type="checkbox" id="marginfigure-3" class="margin-toggle"/> <span class="marginnote"><img src="assets/exp_readFromFoo_comparison_1.svg" alt="The changes made to our `readFromFoo` function"/>The changes made to our <code>readFromFoo</code> function</span></p>
<p>Then, instead of just passing in random values, we’ll pass the result of the first as an input to the second! Let’s rewrite our fake-function <code>readFromFooTwice</code>.</p>
<div class="sourceCode" id="cb252"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb252-1" data-line-number="1">readFromFooTwice <span class="fu">=</span> [first, second] <span class="kw">where</span></a>
<a class="sourceLine" id="cb252-2" data-line-number="2">                      (first, int1) <span class="fu">=</span> readFromFoo <span class="dv">2423</span></a>
<a class="sourceLine" id="cb252-3" data-line-number="3">                      (second, int2) <span class="fu">=</span> readFromFoo int1</a></code></pre></div>
<p>Now, GHC will have to evaluate the <code>readFromFoo 2423</code> before it can evaluate <code>readFromFoo int1</code>, because it doesn’t know what <code>int1</code> will be yet! You’d think the problem is solved, this is really only a band-aid. Let’s say we wanted to call <code>readFromFooTwice</code> twice.</p>
<div class="sourceCode" id="cb253"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb253-1" data-line-number="1">readFromFooFourTimes <span class="fu">=</span> oneAndTwo <span class="fu">++</span> threeAndFour <span class="kw">where</span></a>
<a class="sourceLine" id="cb253-2" data-line-number="2">                      oneAndTwo <span class="fu">=</span> readFromFooTwice</a>
<a class="sourceLine" id="cb253-3" data-line-number="3">                      threeAndFour <span class="fu">=</span> readFromFooTwice</a></code></pre></div>
<p>Just like before, GHC could run <code>oneAndTwo</code> after it ran <code>threeAndFour</code>! There’s nothing that compels it to run <code>oneAndTwo</code> first. And worse, because we do <code>readFromFoo 2423</code> in <code>readFromFooTwice</code>, there’s nothing that stops Haskell from reusing the output, even though that isn’t what we want. What we wanted was:</p>
<div class="sourceCode" id="cb254"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb254-1" data-line-number="1"><span class="dt">Prelude</span><span class="fu">&gt;</span> readFromFooFourTimes</a>
<a class="sourceLine" id="cb254-2" data-line-number="2"><span class="st">&quot;abc1&quot;</span></a></code></pre></div>
<p>But we might end up with</p>
<div class="sourceCode" id="cb255"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb255-1" data-line-number="1"><span class="dt">Prelude</span><span class="fu">&gt;</span> readFromFooFourTimes</a>
<a class="sourceLine" id="cb255-2" data-line-number="2"><span class="st">&quot;c1ab&quot;</span> <span class="co">-- or worse, &quot;abab&quot;!</span></a></code></pre></div>
<p>Do you remember how we modified <code>readFromFoo</code> to return the number that was passed to it, incremented by one? We can solve the issue with <code>readFromFooTwice</code> the same way. Let’s modify <code>readFromFooTwice</code> to take an <code>Int</code>, and return a tuple with the result and the extra value.</p>
<div class="sourceCode" id="cb256"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb256-1" data-line-number="1">readFromFooTwice int0 <span class="fu">=</span> ([first, second], int2) <span class="kw">where</span> <span class="co">-- notice the new parameter, int0</span></a>
<a class="sourceLine" id="cb256-2" data-line-number="2">                      (first, int1) <span class="fu">=</span> readFromFoo int0 <span class="co">-- we use the new parameter instead of a hardcoded number.</span></a>
<a class="sourceLine" id="cb256-3" data-line-number="3">                      (second, int2) <span class="fu">=</span> readFromFoo int1</a></code></pre></div>
<p>Now, we can modify <code>readFromFooTwice</code> so it takes a number and uses that instead of using the name number every time. Let’s rewrite <code>readFromFooFourTimes</code>.</p>
<div class="sourceCode" id="cb257"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb257-1" data-line-number="1">readFromFooFourTimes int0 <span class="fu">=</span> (oneAndTwo <span class="fu">++</span> threeAndFour, int1) <span class="kw">where</span></a>
<a class="sourceLine" id="cb257-2" data-line-number="2">                      (oneAndTwo, int1) <span class="fu">=</span> readFromFooTwice int0</a>
<a class="sourceLine" id="cb257-3" data-line-number="3">                      (threeAndFour, int2) <span class="fu">=</span> readFromFooTwice int1</a></code></pre></div>
<p>Let’s look at the flow of <code>Int</code>s here. <code>readFromFooFourTimes</code> takes <code>int0</code> and passes it to the first <code>readFromFooTwice</code>. Internally it goes into <code>readFromFoo</code>, comes out, goes into the next <code>readFromFoo</code>, and comes out of our <code>readFromFooTwice</code> function as <code>int1</code>. We then pass it to the second <code>readFromTwice</code>, where the process repeats.</p>
<p>You’ll notice that, if we chose this style to represent our impurity, every function that touches impurity would have to return its result decorated with an extra <code>Int</code>. Any function that calls an impure function is “corrupted” by their impurity, and must do the dance of passing <code>Int</code>s around. Without too much effort, we’ve forced Haskell to never evaluate our functions out of order and never re-use previous values. Of course, we don’t have to do all this when writing real Haskell. Haskell has a way to handle this all for us, and we don’t even need to be aware it’s doing it.</p>
<h2 id="the-sequencing-operator">The Sequencing Operator</h2>
<p><span class="newthought">You can</span> think of an IO action, like the result of <code>putStrLn &quot;hello world&quot;</code>, as a piece of data that contains all the information necessary to execute that action. <strong>Whatever that action would return, that’s the type of <code>a</code> in <code>IO a</code></strong>. That’s why <code>putStrLn</code> returns <code>IO ()</code>. It doesn’t really make sense for it to return anything, so <code>()</code> is used to signify that - there’s only one possible value of type <code>()</code>, so a function that returns type <code>()</code> means it doesn’t tell you any new information.</p>
<p>Whatever <code>IO</code> action gets returned by <code>main</code>, Haskell takes it and executes it. This is another thing that makes <code>main</code> special<label for="marginnote-84" class="margin-toggle">⊕</label> <input type="checkbox" id="marginnote-84" class="margin-toggle"/> <span class="marginnote">Also, remember how we could write a value in GHCi and it would be evaluated, then the result would be printed? Well, there’s an exception to that. If it’s an <code>IO a</code> function, GHCi will execute the IO action inside. If one of those actions is writing to the terminal (as is the case of <code>putStrLn</code>), that’s just what GHCi will do. Then, it’ll look at the type <code>a</code>, the return type of the IO action we just performed. If it’s not <code>()</code>, GHCi will print the return value. You’ll see that when I introduce an <code>IO</code> function which isn’t <code>IO ()</code>.</span>.</p>
<p>Let’s write a simple <code>IO ()</code> function. All it will do is write “helloworld” to the terminal.</p>
<div class="sourceCode" id="cb258"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb258-1" data-line-number="1"><span class="dt">Prelude</span><span class="fu">&gt;</span> helloWorld <span class="fu">=</span> putStrLn <span class="st">&quot;helloworld&quot;</span></a>
<a class="sourceLine" id="cb258-2" data-line-number="2"><span class="dt">Prelude</span><span class="fu">&gt;</span> helloWorld</a>
<a class="sourceLine" id="cb258-3" data-line-number="3">helloworld</a>
<a class="sourceLine" id="cb258-4" data-line-number="4"><span class="dt">Prelude</span><span class="fu">&gt;</span> helloWorld</a>
<a class="sourceLine" id="cb258-5" data-line-number="5">helloworld</a></code></pre></div>
<p>You can think of <code>putStrLn &quot;helloworld&quot;</code> as returning a note that says “Print <code>helloworld</code> to the terminal”. When GHCi sees the note, it follows the instruction and prints <code>helloworld</code>. Now, you can’t run <code>show</code> on an <code>IO</code> value, so we can’t really see inside. But, like our <code>readFromFoo</code> example above, The tricky part is you can’t just throw <code>IO</code> values around, they have to be called from another <code>IO</code> function. To perform multiple IO actions in one function, we chain them together with the <code>&gt;&gt;</code> function. It returns a new IO action with the type of the last action in the chain.</p>
<p>Here’s how we’d chain up two <code>putStrLn &quot;helloworld&quot;</code>s.</p>
<div class="sourceCode" id="cb259"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb259-1" data-line-number="1"><span class="dt">Prelude</span><span class="fu">&gt;</span> helloWorldDouble <span class="fu">=</span> putStrLn <span class="st">&quot;helloworld1&quot;</span> <span class="fu">&gt;&gt;</span> putStrLn <span class="st">&quot;helloworld2&quot;</span></a>
<a class="sourceLine" id="cb259-2" data-line-number="2"><span class="dt">Prelude</span><span class="fu">&gt;</span> helloWorldDouble</a>
<a class="sourceLine" id="cb259-3" data-line-number="3">helloworld1</a>
<a class="sourceLine" id="cb259-4" data-line-number="4">helloworld2</a></code></pre></div>
<p>Let’s try it some more.</p>
<div class="sourceCode" id="cb260"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb260-1" data-line-number="1"><span class="co">-- Let&#39;s also examine the type of (putStrLn &quot;helloworld1&quot; &gt;&gt;)</span></a>
<a class="sourceLine" id="cb260-2" data-line-number="2"><span class="dt">Prelude</span><span class="fu">&gt;</span> <span class="fu">:</span>t (putStrLn <span class="st">&quot;helloworld2&quot;</span> <span class="fu">&gt;&gt;</span>)</a>
<a class="sourceLine" id="cb260-3" data-line-number="3">(putStrLn <span class="st">&quot;helloworld2&quot;</span> <span class="fu">&gt;&gt;</span>)<span class="ot"> ::</span> <span class="dt">IO</span> b <span class="ot">-&gt;</span> <span class="dt">IO</span> b</a>
<a class="sourceLine" id="cb260-4" data-line-number="4"></a>
<a class="sourceLine" id="cb260-5" data-line-number="5"><span class="co">-- So (putStrLn &quot;helloworld2&quot; &gt;&gt;) is a function that </span></a>
<a class="sourceLine" id="cb260-6" data-line-number="6"><span class="co">-- takes a value of type IO b and returns an IO b. </span></a>
<a class="sourceLine" id="cb260-7" data-line-number="7"><span class="co">-- Whatever (putStrLn &quot;helloworld2&quot;) returns is essentially thrown away. </span></a>
<a class="sourceLine" id="cb260-8" data-line-number="8"></a>
<a class="sourceLine" id="cb260-9" data-line-number="9"><span class="co">-- Let&#39;s see what the type is when we provide it with a second argument.</span></a>
<a class="sourceLine" id="cb260-10" data-line-number="10"><span class="dt">Prelude</span><span class="fu">&gt;</span> a <span class="fu">=</span> putStrLn <span class="st">&quot;helloworld2&quot;</span> <span class="fu">&gt;&gt;</span> putStrLn <span class="st">&quot;helloworld3&quot;</span></a>
<a class="sourceLine" id="cb260-11" data-line-number="11"><span class="dt">Prelude</span><span class="fu">&gt;</span> <span class="fu">:</span>t a</a>
<a class="sourceLine" id="cb260-12" data-line-number="12"><span class="ot">a ::</span> <span class="dt">IO</span> ()</a>
<a class="sourceLine" id="cb260-13" data-line-number="13"></a>
<a class="sourceLine" id="cb260-14" data-line-number="14"><span class="co">-- So putStrLn &quot;helloworld2&quot; &gt;&gt; putStrLn &quot;helloworld3&quot; returns something of type IO (). </span></a>
<a class="sourceLine" id="cb260-15" data-line-number="15"><span class="co">-- That means we can pass it to &gt;&gt; again, like this</span></a>
<a class="sourceLine" id="cb260-16" data-line-number="16"><span class="dt">Prelude</span><span class="fu">&gt;</span> helloWorldTriple <span class="fu">=</span> putStrLn <span class="st">&quot;helloworld1&quot;</span> <span class="fu">&gt;&gt;</span> (putStrLn <span class="st">&quot;helloworld2&quot;</span> <span class="fu">&gt;&gt;</span> putStrLn <span class="st">&quot;helloworld3&quot;</span>)</a>
<a class="sourceLine" id="cb260-17" data-line-number="17"><span class="dt">Prelude</span><span class="fu">&gt;</span> helloWorldTriple</a>
<a class="sourceLine" id="cb260-18" data-line-number="18">helloworld1</a>
<a class="sourceLine" id="cb260-19" data-line-number="19">helloworld2</a>
<a class="sourceLine" id="cb260-20" data-line-number="20">helloworld3</a></code></pre></div>
<p>Like all Haskell functions, <code>putStrLn &quot;helloworld1&quot;</code> is totally pure. We just cheat because <code>IO</code> types contain some instructions to do possibly-impure things, and GHCi executes those instructions when it sees them.</p>
<p>If you didn’t understand everything that went on here, that’s okay. Just remember: <strong>we can chain <code>IO a</code> actions together with <code>&gt;&gt;</code>, and <code>main</code> is a function that’s automatically called so your program starts</strong>.</p>
<h2 id="the-bind-operator">The Bind Operator</h2>
<p><span class="newthought">Now, that’s</span> well and good, but what if we want to do some IO action based on the value of another IO action? To explain this, I’ll be making heavy use of lambdas, so let me remind you how they work.</p>
<div class="sourceCode" id="cb261"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb261-1" data-line-number="1"><span class="co">-- Create an anonymous function that takes a value, then applies show to it, then applies putStrLn to that, then returns the result.</span></a>
<a class="sourceLine" id="cb261-2" data-line-number="2"><span class="dt">Prelude</span><span class="fu">&gt;</span> myLambda <span class="fu">=</span> (\x <span class="ot">-&gt;</span> putStrLn <span class="fu">.</span> show <span class="fu">$</span> x)</a>
<a class="sourceLine" id="cb261-3" data-line-number="3"></a>
<a class="sourceLine" id="cb261-4" data-line-number="4"><span class="dt">Prelude</span><span class="fu">&gt;</span> myLambda <span class="dv">3</span></a>
<a class="sourceLine" id="cb261-5" data-line-number="5"><span class="dv">3</span></a>
<a class="sourceLine" id="cb261-6" data-line-number="6"><span class="dt">Prelude</span><span class="fu">&gt;</span> myLambda <span class="st">&quot;hello&quot;</span></a>
<a class="sourceLine" id="cb261-7" data-line-number="7"><span class="st">&quot;hello&quot;</span></a>
<a class="sourceLine" id="cb261-8" data-line-number="8"></a>
<a class="sourceLine" id="cb261-9" data-line-number="9"><span class="co">-- Since we call show on the input, the type of whatever we pass in must be a member of the Show typeclass</span></a>
<a class="sourceLine" id="cb261-10" data-line-number="10"><span class="co">-- putStrLn&#39;s return type is IO (), and since we return putStrLn . show $ x, our lambda&#39;s return type is also IO ().</span></a>
<a class="sourceLine" id="cb261-11" data-line-number="11"><span class="dt">Prelude</span><span class="fu">&gt;</span> <span class="fu">:</span>t myLambda</a>
<a class="sourceLine" id="cb261-12" data-line-number="12"><span class="ot">myLambda ::</span> <span class="dt">Show</span> a <span class="ot">=&gt;</span> a <span class="ot">-&gt;</span> <span class="dt">IO</span> ()</a></code></pre></div>
<p>Now that you’ve seen <code>&gt;&gt;</code>, let’s talk about the <code>&gt;&gt;=</code> function, pronounced “bind”. Anything you can do with <code>&gt;&gt;</code> you can also do with <code>&gt;&gt;=</code>, so <code>&gt;&gt;=</code> is a bit more popular. Remember how <code>&gt;&gt;</code> worked?</p>
<div class="sourceCode" id="cb262"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb262-1" data-line-number="1"><span class="dt">Prelude</span><span class="fu">&gt;</span> helloWorldDouble <span class="fu">=</span> putStrLn <span class="st">&quot;helloworld1&quot;</span> <span class="fu">&gt;&gt;</span> putStrLn <span class="st">&quot;helloworld2&quot;</span></a>
<a class="sourceLine" id="cb262-2" data-line-number="2"><span class="dt">Prelude</span><span class="fu">&gt;</span> helloWorldDouble</a>
<a class="sourceLine" id="cb262-3" data-line-number="3">helloworld1</a>
<a class="sourceLine" id="cb262-4" data-line-number="4">helloworld2</a></code></pre></div>
<p>It took two values, in our case <code>IO ()</code> and <code>IO ()</code>, and chained them together<label for="marginnote-85" class="margin-toggle">⊕</label> <input type="checkbox" id="marginnote-85" class="margin-toggle"/> <span class="marginnote">In general though, they wouldn’t both have to be <code>IO ()</code>.</span>. Remember, the <code>a</code> in type <code>IO a</code> is the return value for the IO action we’re performing. Take, for example, the <code>getLine</code> function. Here’s the type for <code>getLine</code>.</p>
<div class="sourceCode" id="cb263"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb263-1" data-line-number="1"><span class="dt">Prelude</span><span class="fu">&gt;</span> <span class="fu">:</span>t getLine</a>
<a class="sourceLine" id="cb263-2" data-line-number="2">getLine<span class="ot"> ::</span> <span class="dt">IO</span> <span class="dt">String</span></a></code></pre></div>
<p>I want you to go into GHCi and play with it before I tell you what it does. Can you figure it out? Don’t forget that if you give GHCi a value of type <code>IO a</code>, GHCi will execute it and then if <code>a</code> is not <code>()</code>, it’ll call <code>show</code> on it and print the result.</p>
<p>Did you try it?</p>
<div class="sourceCode" id="cb264"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb264-1" data-line-number="1"><span class="dt">Prelude</span><span class="fu">&gt;</span> getLine</a>
<a class="sourceLine" id="cb264-2" data-line-number="2">test</a>
<a class="sourceLine" id="cb264-3" data-line-number="3"><span class="st">&quot;test&quot;</span></a>
<a class="sourceLine" id="cb264-4" data-line-number="4"><span class="dt">Prelude</span><span class="fu">&gt;</span> getLine</a>
<a class="sourceLine" id="cb264-5" data-line-number="5"><span class="dt">Woah</span>, <span class="dt">Haskell</span> is cool<span class="fu">!</span></a>
<a class="sourceLine" id="cb264-6" data-line-number="6"><span class="st">&quot;Woah, Haskell is cool!&quot;</span></a></code></pre></div>
<p>Here’s the answer. <code>getLine</code> is an IO function, of course. What it does is prompt the user to enter some characters, then return that those characters inside an <code>IO String</code> type. This makes sense: whatever the <code>a</code> is in <code>IO a</code> is the type of the result of the <code>IO</code> action, and <code>String</code> is the natural result type for a function that lets the user input some text into the terminal.</p>
<p>Now, let’s see the <code>&gt;&gt;=</code> operator. Let’s redefine <code>helloWorldDouble</code> to use <code>&gt;&gt;=</code> instead of <code>&gt;&gt;</code>.</p>
<div class="sourceCode" id="cb265"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb265-1" data-line-number="1"><span class="dt">Prelude</span><span class="fu">&gt;</span> helloWorldDouble <span class="fu">=</span> putStrLn <span class="st">&quot;helloworld1&quot;</span> <span class="fu">&gt;&gt;=</span> (\_ <span class="ot">-&gt;</span> putStrLn <span class="st">&quot;helloworld2&quot;</span>)</a>
<a class="sourceLine" id="cb265-2" data-line-number="2"><span class="dt">Prelude</span><span class="fu">&gt;</span> helloWorldDouble</a>
<a class="sourceLine" id="cb265-3" data-line-number="3">helloworld1</a>
<a class="sourceLine" id="cb265-4" data-line-number="4">helloworld2</a></code></pre></div>
<p>Instead of passing <code>&gt;&gt;=</code> a plain <code>putStrLn &quot;helloworld2&quot;</code>, we wrapped it up in a lambda that takes one parameter and does nothing it. The reason we did this is that <code>&gt;&gt;=</code> has to take a function as it’s right-hand argument. What it’s actually doing here is taking the output of <code>putStrLn &quot;helloworld1&quot;</code> (which is <code>()</code>) and passing it to the <code>(\x -&gt; putStrLn &quot;helloworld2&quot;)</code> function, which ignores it and returns an IO action that prints <code>helloworld2</code> to the terminal. However, that’s not where <code>&gt;&gt;=</code> shines. It’s most useful in situations where you actually care about the output of an IO action. Let’s use it with <code>getLine</code> to have a little more fun.</p>
<div class="sourceCode" id="cb266"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb266-1" data-line-number="1"><span class="co">-- Let&#39;s use a simple function that takes a value and prints it with two exclamation marks after it. Then we&#39;ll use that function as the argument to(getLine &gt;&gt;=).</span></a>
<a class="sourceLine" id="cb266-2" data-line-number="2"><span class="dt">Prelude</span><span class="fu">&gt;</span> beLoud <span class="fu">=</span> getLine <span class="fu">&gt;&gt;=</span> (\x <span class="ot">-&gt;</span> putStrLn (x <span class="fu">++</span> <span class="st">&quot;!!&quot;</span>))</a>
<a class="sourceLine" id="cb266-3" data-line-number="3"><span class="dt">Prelude</span><span class="fu">&gt;</span> beLoud</a>
<a class="sourceLine" id="cb266-4" data-line-number="4"><span class="dt">I</span> like <span class="dt">Haskell</span></a>
<a class="sourceLine" id="cb266-5" data-line-number="5"><span class="dt">I</span> like <span class="dt">Haskell</span><span class="fu">!!</span></a></code></pre></div>
<p>I <em>strongly</em> recommend playing with this, as having a firm understanding of what’s going on here is critical. It’s running the <code>getLine</code> function, which returns an <code>IO String</code>. Then <code>&gt;&gt;=</code> extracts the <code>String</code> and passes it to the function <code>\x -&gt; putStrLn (x ++ &quot;!!&quot;)</code>. That function takes the string, then returns an IO action that prints it with <code>&quot;!!&quot;</code> added to the end. Notice that even though <code>getLine</code> returns an <code>IO String</code>, the <code>x</code> is just a regular <code>String</code>. The bind operator “unwraps” it.</p>
<p>The powerful thing about the <code>&gt;&gt;=</code> operator is that you can chain it as much as you want. Let’s use it to write a function that uses five different IO actions.</p>
<div class="sourceCode" id="cb267"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb267-1" data-line-number="1"><span class="dt">Prelude</span><span class="fu">&gt;</span> spongebob <span class="fu">=</span> putStrLn <span class="st">&quot;Are you ready, kids?&quot;</span> <span class="fu">&gt;&gt;=</span> (\_ <span class="ot">-&gt;</span> (getLine <span class="fu">&gt;&gt;=</span> (\_ <span class="ot">-&gt;</span> (putStrLn <span class="st">&quot;I can&#39;t hear you!&quot;</span> <span class="fu">&gt;&gt;=</span> (\_ <span class="ot">-&gt;</span> (getLine <span class="fu">&gt;&gt;=</span> (\_ <span class="ot">-&gt;</span> putStrLn <span class="st">&quot;Ohhhhh!&quot;</span>)))))))</a>
<a class="sourceLine" id="cb267-2" data-line-number="2"><span class="dt">Prelude</span><span class="fu">&gt;</span> spongebob</a>
<a class="sourceLine" id="cb267-3" data-line-number="3"><span class="dt">Are</span> you ready, kids<span class="fu">?</span></a>
<a class="sourceLine" id="cb267-4" data-line-number="4"><span class="dt">Aye</span> aye, captain</a>
<a class="sourceLine" id="cb267-5" data-line-number="5"><span class="dt">I</span> can&#39;t hear you<span class="fu">!</span></a>
<a class="sourceLine" id="cb267-6" data-line-number="6"><span class="dt">Aye</span> aye, captain<span class="fu">!</span></a>
<a class="sourceLine" id="cb267-7" data-line-number="7"><span class="dt">Ohhhhh</span><span class="fu">!</span></a></code></pre></div>
<p>Now, you might have thought that was somewhat of a pain to type into GHCi<label for="marginnote-86" class="margin-toggle">⊕</label> <input type="checkbox" id="marginnote-86" class="margin-toggle"/> <span class="marginnote">You <em>are</em> typing all these examples into GHCi, right?</span>. Well luckily for us, Haskell provides something called <code>do</code> notation to save us some work.</p>
<h2 id="do-notation">Do Notation</h2>
<p><span class="newthought">Let’s look</span> at that spongebob example again, but this time let’s put it in a file.</p>
<div class="sourceCode" id="cb268"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb268-1" data-line-number="1"><span class="co">-- spongebob.hs</span></a>
<a class="sourceLine" id="cb268-2" data-line-number="2">spongebob <span class="fu">=</span> putStrLn <span class="st">&quot;Are you ready, kids?&quot;</span> <span class="fu">&gt;&gt;=</span> (\_ <span class="ot">-&gt;</span> (getLine <span class="fu">&gt;&gt;=</span> (\_ <span class="ot">-&gt;</span> (putStrLn <span class="st">&quot;I can&#39;t hear you!&quot;</span> <span class="fu">&gt;&gt;=</span> (\_ <span class="ot">-&gt;</span> (getLine <span class="fu">&gt;&gt;=</span> (\_ <span class="ot">-&gt;</span> putStrLn <span class="st">&quot;Ohhhhh!&quot;</span>)))))))</a></code></pre></div>
<p>This is, to put it mildly, a mess. Let’s add some newlines to make it slightly more clear what’s going on.</p>
<div class="sourceCode" id="cb269"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb269-1" data-line-number="1"><span class="co">-- spongebobNewlines.hs</span></a>
<a class="sourceLine" id="cb269-2" data-line-number="2">spongebob <span class="fu">=</span></a>
<a class="sourceLine" id="cb269-3" data-line-number="3">    putStrLn <span class="st">&quot;Are you ready, kids?&quot;</span> <span class="fu">&gt;&gt;=</span> \_ <span class="ot">-&gt;</span> (</a>
<a class="sourceLine" id="cb269-4" data-line-number="4">    getLine                         <span class="fu">&gt;&gt;=</span> \_ <span class="ot">-&gt;</span> (</a>
<a class="sourceLine" id="cb269-5" data-line-number="5">    putStrLn <span class="st">&quot;I can&#39;t hear you!&quot;</span>    <span class="fu">&gt;&gt;=</span> \_ <span class="ot">-&gt;</span> (</a>
<a class="sourceLine" id="cb269-6" data-line-number="6">    getLine                         <span class="fu">&gt;&gt;=</span> \_ <span class="ot">-&gt;</span> (</a>
<a class="sourceLine" id="cb269-7" data-line-number="7">    putStrLn <span class="st">&quot;Ohhhhh!&quot;</span>))))</a></code></pre></div>
<p>That’s a bit more readable. But we’re still typing a lot of repetitive lambdas. Do you know what type <code>spongebob</code> will return?</p>
<div class="sourceCode" id="cb270"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb270-1" data-line-number="1"><span class="dt">Prelude</span><span class="fu">&gt;</span> <span class="fu">:</span>t spongebob</a>
<a class="sourceLine" id="cb270-2" data-line-number="2"><span class="ot">spongebob ::</span> <span class="dt">IO</span> ()</a></code></pre></div>
<p>Whatever is the type of the last element in our huge chain, that’s what type the whole thing will return. Since <code>putStrLn &quot;Ohhhhh!&quot;</code> returns type <code>IO ()</code>, and it’s the last thing that’ll get done in our sequence, that’s the type of the <code>spongebob</code> function.</p>
<p>But although this formatting is better, we’re forced to write <code>&lt;stuff&gt; &gt;&gt;= \_ -&gt; &lt;stuff&gt;</code> over and over, which is a bit annoying when we’d rather just be focusing on the logic of our program. That’s why Haskell provides <code>do</code> notation. Let’s see how it works</p>
<div class="sourceCode" id="cb271"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb271-1" data-line-number="1"><span class="co">-- spongebobDo.hs</span></a>
<a class="sourceLine" id="cb271-2" data-line-number="2">spongebob <span class="fu">=</span> <span class="kw">do</span></a>
<a class="sourceLine" id="cb271-3" data-line-number="3">    putStrLn <span class="st">&quot;Are you ready, kids?&quot;</span></a>
<a class="sourceLine" id="cb271-4" data-line-number="4">    getLine</a>
<a class="sourceLine" id="cb271-5" data-line-number="5">    putStrLn <span class="st">&quot;I can&#39;t hear you!&quot;</span></a>
<a class="sourceLine" id="cb271-6" data-line-number="6">    getLine</a>
<a class="sourceLine" id="cb271-7" data-line-number="7">    putStrLn <span class="st">&quot;Ohhhhh!&quot;</span></a></code></pre></div>
<p>Look how simple that made it! Remember, this is just syntax sugar. Before this is compiled, <code>do</code> notation is converted to use <code>&gt;&gt;=</code>, so Haskell doesn’t know or care which you use<label for="marginnote-87" class="margin-toggle">⊕</label> <input type="checkbox" id="marginnote-87" class="margin-toggle"/> <span class="marginnote">Lots of beginners think <code>do</code> is magic that lets you use <code>IO</code> functions, but it’s not. And it actually works on much more than just IO! We’ll cover that a bit later.</span>. Anything you can do with <code>do</code> you can do with <code>&gt;&gt;=</code>.</p>
<div class="sourceCode" id="cb272"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb272-1" data-line-number="1">spongebob <span class="fu">=</span></a>
<a class="sourceLine" id="cb272-2" data-line-number="2">    putStrLn <span class="st">&quot;Are you ready, kids?&quot;</span> <span class="fu">&gt;&gt;=</span> \_ <span class="ot">-&gt;</span></a>
<a class="sourceLine" id="cb272-3" data-line-number="3">    getLine                         <span class="fu">&gt;&gt;=</span> \_ <span class="ot">-&gt;</span></a>
<a class="sourceLine" id="cb272-4" data-line-number="4">    putStrLn <span class="st">&quot;I can&#39;t hear you!&quot;</span>    <span class="fu">&gt;&gt;=</span> \_ <span class="ot">-&gt;</span></a>
<a class="sourceLine" id="cb272-5" data-line-number="5">    getLine                         <span class="fu">&gt;&gt;=</span> \_ <span class="ot">-&gt;</span></a>
<a class="sourceLine" id="cb272-6" data-line-number="6">    putStrLn <span class="st">&quot;Ohhhhh!&quot;</span></a></code></pre></div>
<p><strong><code>do</code> does not do anything magic, it’s just shorthand for long chains of <code>&gt;&gt;=</code></strong>. However, our program is kind of boring, because we never use the results of previous operations in our next ones. This is how we might do that, using <code>&gt;&gt;=</code>.</p>
<div class="sourceCode" id="cb273"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb273-1" data-line-number="1"><span class="co">-- spongebobResults.hs</span></a>
<a class="sourceLine" id="cb273-2" data-line-number="2">spongebob <span class="fu">=</span></a>
<a class="sourceLine" id="cb273-3" data-line-number="3">    putStrLn <span class="st">&quot;Are you ready, kids?&quot;</span> <span class="fu">&gt;&gt;=</span> \_ <span class="ot">-&gt;</span></a>
<a class="sourceLine" id="cb273-4" data-line-number="4">    getLine                         <span class="fu">&gt;&gt;=</span> \first <span class="ot">-&gt;</span></a>
<a class="sourceLine" id="cb273-5" data-line-number="5">    putStrLn <span class="st">&quot;I can&#39;t hear you!&quot;</span>    <span class="fu">&gt;&gt;=</span> \_ <span class="ot">-&gt;</span></a>
<a class="sourceLine" id="cb273-6" data-line-number="6">    getLine                         <span class="fu">&gt;&gt;=</span> \second <span class="ot">-&gt;</span></a>
<a class="sourceLine" id="cb273-7" data-line-number="7">    putStrLn <span class="st">&quot;Ohhhhh!&quot;</span>              <span class="fu">&gt;&gt;=</span> \_ <span class="ot">-&gt;</span></a>
<a class="sourceLine" id="cb273-8" data-line-number="8">    putStrLn (<span class="st">&quot;Results: You said &#39;&quot;</span> <span class="fu">++</span> first <span class="fu">++</span> <span class="st">&quot;&#39; the first time, and &#39;&quot;</span> <span class="fu">++</span> second <span class="fu">++</span> <span class="st">&quot;&#39; the second time&quot;</span>)</a></code></pre></div>
<p>Let’s try it out!</p>
<div class="sourceCode" id="cb274"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb274-1" data-line-number="1"><span class="dt">Prelude</span><span class="fu">&gt;</span> <span class="fu">:</span>l spongebobResults<span class="fu">.</span>hs</a>
<a class="sourceLine" id="cb274-2" data-line-number="2">[<span class="dv">1</span> <span class="kw">of</span> <span class="dv">1</span>] <span class="dt">Compiling</span> <span class="dt">Main</span> ( spongebobResults<span class="fu">.</span>hs, interpreted )</a>
<a class="sourceLine" id="cb274-3" data-line-number="3"><span class="dt">Ok</span>, one <span class="kw">module</span> loaded<span class="fu">.</span></a>
<a class="sourceLine" id="cb274-4" data-line-number="4"><span class="fu">*</span><span class="dt">Main</span><span class="fu">&gt;</span> spongebob</a>
<a class="sourceLine" id="cb274-5" data-line-number="5"><span class="dt">Are</span> you ready, kids<span class="fu">?</span></a>
<a class="sourceLine" id="cb274-6" data-line-number="6">aye aye, captain</a>
<a class="sourceLine" id="cb274-7" data-line-number="7"><span class="dt">I</span> can&#39;t hear you<span class="fu">!</span></a>
<a class="sourceLine" id="cb274-8" data-line-number="8">aye aye, captain<span class="fu">!</span></a>
<a class="sourceLine" id="cb274-9" data-line-number="9"><span class="dt">Ohhhhh</span><span class="fu">!</span></a>
<a class="sourceLine" id="cb274-10" data-line-number="10"><span class="dt">Results</span><span class="fu">:</span> <span class="dt">You</span> said &#39;aye aye, captain&#39; the first time, and &#39;aye aye, captain<span class="fu">!</span>&#39; the second time</a></code></pre></div>
<p>To do this using <code>do</code>, there’s an extra piece of notation we need. It looks like a backwards arrow: <code>&lt;-</code><label for="marginnote-88" class="margin-toggle">⊕</label> <input type="checkbox" id="marginnote-88" class="margin-toggle"/> <span class="marginnote">It’s totally unrelated to the forward arrow in a lambda (<code>\x -&gt;</code>).</span>.git c</p>
<div class="sourceCode" id="cb275"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb275-1" data-line-number="1"><span class="co">--- spongebobResultsDo.hs</span></a>
<a class="sourceLine" id="cb275-2" data-line-number="2">spongebob <span class="fu">=</span> <span class="kw">do</span></a>
<a class="sourceLine" id="cb275-3" data-line-number="3">    putStrLn <span class="st">&quot;Are you ready, kids?&quot;</span></a>
<a class="sourceLine" id="cb275-4" data-line-number="4">    first <span class="ot">&lt;-</span> getLine</a>
<a class="sourceLine" id="cb275-5" data-line-number="5">    putStrLn <span class="st">&quot;I can&#39;t hear you!&quot;</span></a>
<a class="sourceLine" id="cb275-6" data-line-number="6">    second <span class="ot">&lt;-</span> getLine</a>
<a class="sourceLine" id="cb275-7" data-line-number="7">    putStrLn <span class="st">&quot;Ohhhhh!&quot;</span></a>
<a class="sourceLine" id="cb275-8" data-line-number="8">    putStrLn (<span class="st">&quot;Results: You said &#39;&quot;</span> <span class="fu">++</span> first <span class="fu">++</span> <span class="st">&quot;&#39; the first time, and &#39;&quot;</span> <span class="fu">++</span> second <span class="fu">++</span> <span class="st">&quot;&#39; the second time&quot;</span>)</a></code></pre></div>
<p>This is cool! With <code>first &lt;-</code> and <code>second &lt;-</code>, when Haskell is converting our <code>do</code> syntax to regular <code>&gt;&gt;= \_ -&gt;</code> syntax, it knows to change the <code>_</code> to <code>first</code> or <code>second</code>, depending. For clarity, we could just always use <code>&lt;-</code>, like this.</p>
<div class="sourceCode" id="cb276"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb276-1" data-line-number="1">spongebob <span class="fu">=</span> <span class="kw">do</span></a>
<a class="sourceLine" id="cb276-2" data-line-number="2">    _      <span class="ot">&lt;-</span> putStrLn <span class="st">&quot;Are you ready, kids?&quot;</span></a>
<a class="sourceLine" id="cb276-3" data-line-number="3">    first  <span class="ot">&lt;-</span> getLine</a>
<a class="sourceLine" id="cb276-4" data-line-number="4">    _      <span class="ot">&lt;-</span> putStrLn <span class="st">&quot;I can&#39;t hear you!&quot;</span></a>
<a class="sourceLine" id="cb276-5" data-line-number="5">    second <span class="ot">&lt;-</span> getLine</a>
<a class="sourceLine" id="cb276-6" data-line-number="6">    _      <span class="ot">&lt;-</span> putStrLn <span class="st">&quot;Ohhhhh!&quot;</span></a>
<a class="sourceLine" id="cb276-7" data-line-number="7">    putStrLn (<span class="st">&quot;Results: You said &#39;&quot;</span> <span class="fu">++</span> first <span class="fu">++</span> <span class="st">&quot;&#39; the first time, and &#39;&quot;</span> <span class="fu">++</span> second <span class="fu">++</span> <span class="st">&quot;&#39; the second time&quot;</span>)</a></code></pre></div>
<p>We can’t bind the last one to anything, for two reasons. For one, there would be no point, it’s at the end so there would be nowhere to use it<label for="marginnote-89" class="margin-toggle">⊕</label> <input type="checkbox" id="marginnote-89" class="margin-toggle"/> <span class="marginnote">when you make a binding in a <code>do</code> expression, it can only be used later in that expression.</span>. And for two, scroll up and look at <code>spongebobResults.hs</code>. There’s no lambda that comes after the last <code>putStrLn</code>, so there’s nowhere to bind the value<label for="marginnote-90" class="margin-toggle">⊕</label> <input type="checkbox" id="marginnote-90" class="margin-toggle"/> <span class="marginnote">It’s edge cases like these when it comes in handy to know that <code>do</code> is just a prettier version of <code>&gt;&gt;=</code>.</span>.</p>
<p>Note that when using do notation, if the first element is type <code>IO a</code>, every other element has to be some other <code>IO</code> type. This would not be allowed:</p>
<div class="sourceCode" id="cb277"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb277-1" data-line-number="1"><span class="co">-- badDo.hs</span></a>
<a class="sourceLine" id="cb277-2" data-line-number="2">wontWork <span class="fu">=</span> <span class="kw">do</span></a>
<a class="sourceLine" id="cb277-3" data-line-number="3">    putStrLn <span class="st">&quot;hello&quot;</span></a>
<a class="sourceLine" id="cb277-4" data-line-number="4">    two <span class="ot">&lt;-</span> (<span class="dv">1</span> <span class="fu">+</span> <span class="dv">1</span>)<span class="ot"> ::</span> <span class="dt">Int</span> <span class="co">-- error! &quot;Couldn&#39;t match expected type `IO a0&#39; with actual type `Int&#39;&quot;&quot;</span></a>
<a class="sourceLine" id="cb277-5" data-line-number="5">    putStrLn <span class="fu">.</span> show <span class="fu">$</span> two</a></code></pre></div>
<p><code>(1 + 1) :: Int</code> is, obviously, an <code>Int</code>. And since the first thing that was encountered in the <code>do</code> expression was <code>putStrLn &quot;hello&quot;</code> (which is an <code>IO</code> type), it wants everything that follows to be an <code>IO</code> type<label for="marginnote-91" class="margin-toggle">⊕</label> <input type="checkbox" id="marginnote-91" class="margin-toggle"/> <span class="marginnote">Yes, that implies <code>do</code> works with things other than <code>IO</code> - it does! We’ll cover that later.</span>.</p>
<p>If you want to bind <code>(1 + 1)</code> to a name inside a <code>do</code> expression, you need to turn it into an <code>IO</code> action. For that, we have the <code>pure</code> function, which takes a value and makes it an <code>IO</code> type. Observe:</p>
<div class="sourceCode" id="cb278"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb278-1" data-line-number="1"><span class="co">-- goodDo.hs</span></a>
<a class="sourceLine" id="cb278-2" data-line-number="2">willWork <span class="fu">=</span> <span class="kw">do</span></a>
<a class="sourceLine" id="cb278-3" data-line-number="3">    putStrLn <span class="st">&quot;hello&quot;</span></a>
<a class="sourceLine" id="cb278-4" data-line-number="4">    two <span class="ot">&lt;-</span> pure ((<span class="dv">1</span> <span class="fu">+</span> <span class="dv">1</span>)<span class="ot"> ::</span> <span class="dt">Int</span>) <span class="co">-- error! &quot;Couldn&#39;t match expected type `IO a0&#39; with actual type `Int&#39;&quot;&quot;</span></a>
<a class="sourceLine" id="cb278-5" data-line-number="5">    putStrLn <span class="fu">.</span> show <span class="fu">$</span> two</a></code></pre></div>
<p>The <code>pure</code> function takes a value, in our case an <code>Int</code>, then puts it into an <code>IO</code> value. So it turns an <code>Int</code> into an <code>IO Int</code>. Then the <code>&lt;-</code> extracts the <code>Int</code> out of the <code>IO Int</code>, leaving <code>two</code> equal to <code>2</code><label for="marginnote-92" class="margin-toggle">⊕</label> <input type="checkbox" id="marginnote-92" class="margin-toggle"/> <span class="marginnote">There’s another function, <code>return</code>, which does the same thing as <code>pure</code> but I don’t recommend using it. <code>pure</code> will work in cases <code>return</code> won’t.</span>. This may seem convoluted, but that’s how it’s got to be done. In practice it doesn’t come up that much because you can always use <code>let</code> and <code>where</code>:</p>
<div class="sourceCode" id="cb279"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb279-1" data-line-number="1"><span class="co">-- goodDo2.hs</span></a>
<a class="sourceLine" id="cb279-2" data-line-number="2">willWork <span class="fu">=</span> <span class="kw">let</span> two <span class="fu">=</span> (<span class="dv">1</span> <span class="fu">+</span> <span class="dv">1</span>) <span class="kw">in</span> <span class="kw">do</span></a>
<a class="sourceLine" id="cb279-3" data-line-number="3">    putStrLn <span class="st">&quot;hello&quot;</span></a>
<a class="sourceLine" id="cb279-4" data-line-number="4">    putStrLn <span class="fu">.</span> show <span class="fu">$</span> two</a></code></pre></div>
<p>Now that you understand how to effectively use <code>IO</code> functions, you need to learn what they are.</p>
<h2 id="useful-io-functions">Useful IO Functions</h2>
<ol type="1">
<li><p><code>putStrLn :: String -&gt; IO ()</code></p>
<p>This function takes a <code>String</code> and returns an IO action that will print it to the terminal, with a newline at the end.</p></li>
<li><p><code>putStr :: String -&gt; IO ()</code></p>
<p>This function takes a <code>String</code> and returns an IO action that will print it to the terminal, without a newline at the end.</p></li>
<li><p><code>putChar :: Char -&gt; IO ()</code></p>
<p>Like <code>putStr</code>, but takes a single character instead of a string.</p></li>
<li><p><code>print :: Show a =&gt; a -&gt; IO ()</code></p>
<p>Equivalent to <code>putStrLn . show</code>. Takes a value <code>x</code> and returns an IO action that’ll print <code>show x</code>.</p></li>
<li><p><code>getLine :: IO String</code></p>
<p>Returns an IO action that will allow the user to type some text into the terminal, then returns that text.</p></li>
<li><p><code>openFile :: FilePath -&gt; IOMode -&gt; IO Handle</code></p>
<p>This is part of the <code>System.IO</code> package, which means that in order to use it, you have to write <code>import System.IO</code> at the top of every file that uses it. What it does is take a path to a file (which is just a <code>String</code>) and an <code>IOMode</code> (which is either <code>ReadMode</code>, <code>WriteMode</code>, <code>AppendMode</code>, or <code>ReadWriteMode</code>), and return a “file handle” which is basically a reference to a file. If you opened the file in <code>ReadMode</code> or <code>ReadWriteMode</code> you can get the contents with the <code>hGetContents</code> function. When you’re done with the file, run <code>hClose</code> on the handle to tell the computer you don’t need it anymore. Let’s how to read a file.</p>
<div class="sourceCode" id="cb280"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb280-1" data-line-number="1"><span class="kw">import</span> <span class="dt">System.IO</span>  </a>
<a class="sourceLine" id="cb280-2" data-line-number="2"></a>
<a class="sourceLine" id="cb280-3" data-line-number="3">main <span class="fu">=</span> <span class="kw">do</span>  </a>
<a class="sourceLine" id="cb280-4" data-line-number="4">    handle <span class="ot">&lt;-</span> openFile <span class="st">&quot;myFile.txt&quot;</span> <span class="dt">ReadMode</span>  </a>
<a class="sourceLine" id="cb280-5" data-line-number="5">    contents <span class="ot">&lt;-</span> hGetContents handle  </a>
<a class="sourceLine" id="cb280-6" data-line-number="6">    putStr contents  </a>
<a class="sourceLine" id="cb280-7" data-line-number="7">    hClose handle  </a></code></pre></div>
<p>Writing a file is more complicated due to Haskell’s laziness, and I recommend using either the <a href="http://hackage.haskell.org/package/pipes">Pipes</a> or <a href="http://hackage.haskell.org/package/conduit">Conduit</a> library for it. I discuss how to use Pipes in a later chapter.</p></li>
<li><p><code>sequence</code></p>
<p>This is an interesting function<label for="marginnote-93" class="margin-toggle">⊕</label> <input type="checkbox" id="marginnote-93" class="margin-toggle"/> <span class="marginnote">I don’t display <code>sequence</code>’s type signature because it’s a little complicated/</span>, what it does is take a list of <code>IO</code> actions and return an IO action that executes all of them.</p>
<div class="sourceCode" id="cb281"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb281-1" data-line-number="1"><span class="dt">Prelude</span><span class="fu">&gt;</span> sequence [print <span class="st">&quot;hello&quot;</span>, print <span class="dv">3</span>, putStrLn <span class="st">&quot;bonjour&quot;</span>]</a>
<a class="sourceLine" id="cb281-2" data-line-number="2"><span class="st">&quot;hello&quot;</span></a>
<a class="sourceLine" id="cb281-3" data-line-number="3"><span class="dv">3</span></a>
<a class="sourceLine" id="cb281-4" data-line-number="4">bonjour</a>
<a class="sourceLine" id="cb281-5" data-line-number="5">[(),(),()]</a></code></pre></div>
<p>Note that it’s return type is not <code>IO ()</code>, it’s <code>IO [a]</code>, so GHCi will attempt to print its output. That’s what <code>[(),(),()]</code> is at the bottom. It’s output is the output of all the IO actions in the list.</p></li>
</ol>
<h2 id="project-1---a-text-adventure-game">Project 1 - A Text Adventure Game</h2>
<p><span class="newthought">This is</span> a project we’re going to use to test some of the skills we’ve learned so far! We’re going to make a type of game called a text adventure game. Here’s how it’ll look when we’re finished:</p>
<div class="sourceCode" id="cb282"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb282-1" data-line-number="1"><span class="dt">You</span> awaken <span class="kw">in</span> a dark cavern, only the dimmest light illuminating your surroundings<span class="fu">.</span></a>
<a class="sourceLine" id="cb282-2" data-line-number="2"><span class="dt">You</span> try to remember how you got there, but you realize you can&#39;t remember anything <span class="fu">-</span> not even your own name<span class="fu">.</span></a>
<a class="sourceLine" id="cb282-3" data-line-number="3"><span class="dt">You</span> look around, and see two pinpricks <span class="kw">of</span> light <span class="kw">in</span> the distance, one to your left and one to your right<span class="fu">.</span></a>
<a class="sourceLine" id="cb282-4" data-line-number="4"><span class="dt">Could</span> they be exits<span class="fu">?</span></a>
<a class="sourceLine" id="cb282-5" data-line-number="5">  <span class="dv">1</span><span class="fu">:</span> <span class="dt">Probably</span> not, better to sit here and wait for someone to find me<span class="fu">.</span></a>
<a class="sourceLine" id="cb282-6" data-line-number="6">  <span class="dv">2</span><span class="fu">:</span> <span class="fu">Hmm...</span> <span class="dt">I&#39;ll</span> go explore the possible exit on my right<span class="fu">.</span></a>
<a class="sourceLine" id="cb282-7" data-line-number="7">  <span class="dv">3</span><span class="fu">:</span> <span class="dt">I</span> have a good feeling about the light to my left</a>
<a class="sourceLine" id="cb282-8" data-line-number="8"><span class="dt">Choice</span><span class="fu">:</span> <span class="dv">1</span></a>
<a class="sourceLine" id="cb282-9" data-line-number="9"><span class="dt">Story</span> over<span class="fu">!</span></a></code></pre></div>
<p>The first thing to do is to make a new project - I’ll call it <code>textAdventure</code>, but you’re free to call it whatever you like. This is the command you’d run to start a project<label for="marginnote-94" class="margin-toggle">⊕</label> <input type="checkbox" id="marginnote-94" class="margin-toggle"/> <span class="marginnote">you may want to change the name, of course.</span>:</p>
<div class="sourceCode" id="cb283"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb283-1" data-line-number="1">stack new textAdventure simple <span class="fu">-</span>p <span class="st">&quot;author-name:Andre Popovitch&quot;</span></a></code></pre></div>
<p>Then, navigate into the <code>textAdventure</code> directory and run <code>stack ghci</code> to open an environment where we can run our program. Also, open a text editor and view <code>src/Main.hs</code> - this is the only file we need for doing our work<label for="marginnote-95" class="margin-toggle">⊕</label> <input type="checkbox" id="marginnote-95" class="margin-toggle"/> <span class="marginnote">In general, you’ll spend most of your time editing files in the <code>src</code> directory.</span>.</p>
<p>The first thing to do is think about what we want. We need to be able to show some text, like our <code>You awaken in a dark cavern ...</code>. Let’s make a data type that will hold a piece of text to display to the user, we’ll call it <code>Message</code> because it’s a message to the user. If the text is to represent someone talking, we’ll store his or her name separately from what they say. Add this to <code>Main.hs</code></p>
<div class="sourceCode" id="cb284"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb284-1" data-line-number="1"><span class="kw">data</span> <span class="dt">Message</span> <span class="fu">=</span> <span class="dt">Speaking</span> {<span class="ot">texts ::</span> [<span class="dt">String</span>],<span class="ot"> speaker ::</span> <span class="dt">String</span>}  <span class="fu">|</span> <span class="dt">Info</span> {<span class="ot">texts ::</span> [<span class="dt">String</span>]}  </a></code></pre></div>
<p>We’re using record syntax here - reread [#Creating New Data Types] if you’ve forgotten how this works.</p>
<p>We also want to be able to display choices to the user. Let’s make a data type to store a single choice.</p>
<div class="sourceCode" id="cb285"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb285-1" data-line-number="1"><span class="kw">data</span> <span class="dt">Choice</span> <span class="fu">=</span> <span class="dt">Choice</span> {<span class="ot">choice ::</span> <span class="dt">String</span>,<span class="ot"> result ::</span> <span class="dt">Adventure</span>}</a></code></pre></div>
<p>Now you might be wondering, what the heck is an <code>Adventure</code>? Well, <code>Adventure</code> is a data type which we haven’t written yet (remember, the order of declarations in Haskell doesn’t matter). And it’s not just any data type, it’s recursive<label for="marginnote-96" class="margin-toggle">⊕</label> <input type="checkbox" id="marginnote-96" class="margin-toggle"/> <span class="marginnote">A recursive data type is a data type for values that may contain other values of the same type. Haskell lists are actually defined recursively, so you’ve already used recursive data types.</span>! Let’s write it now.</p>
<div class="sourceCode" id="cb286"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb286-1" data-line-number="1"><span class="kw">data</span> <span class="dt">Adventure</span> <span class="fu">=</span> <span class="dt">StoryEnd</span> <span class="fu">|</span> <span class="dt">StoryMessage</span> <span class="dt">Message</span> <span class="dt">Adventure</span> <span class="fu">|</span> <span class="dt">StoryChoice</span> [<span class="dt">Choice</span>]</a></code></pre></div>
<p>That’s right, in Haskell, it’s fully allowed to have a data type which can contain values of its own type. <code>Choice</code> can contain a value of type <code>Adventure</code>, and <code>Adventure</code> can contain a value of type <code>Choice</code>. What we’re going to do is use this to have our game basically be a stack of nested <code>Adventure</code>s.</p>
<p><span class="newthought">Let’s write</span> an <code>IO</code> function, <code>tellStory</code>, which will take an <code>Adventure</code> and recursively<label for="marginnote-97" class="margin-toggle">⊕</label> <input type="checkbox" id="marginnote-97" class="margin-toggle"/> <span class="marginnote">Recursive data types often demand recursive functions.</span> present it to to the user.</p>
<div class="sourceCode" id="cb287"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb287-1" data-line-number="1"><span class="ot">tellAdventure ::</span> <span class="dt">Adventure</span> <span class="ot">-&gt;</span> <span class="dt">IO</span> ()</a></code></pre></div>
<p>Let’s think of the three cases our <code>tellStory</code> function will have to handle. Whatever <code>Adventure</code> we pass it, it’s either going to be a <code>StoryEnd</code>, a <code>StoryMessage Message Adventure</code>, or a <code>StoryChoice [Choice]</code>. If it’s a <code>StoryEnd</code>, that’s it for our story, so we can just write that the story is over and be done.</p>
<div class="sourceCode" id="cb288"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb288-1" data-line-number="1">tellAdventure <span class="dt">StoryEnd</span> <span class="fu">=</span> </a>
<a class="sourceLine" id="cb288-2" data-line-number="2">  putStrLn <span class="st">&quot;Story over!&quot;</span></a></code></pre></div>
<p>That’s the easy one. <code>StoryEnd</code> represents the end of our story<label for="marginnote-98" class="margin-toggle">⊕</label> <input type="checkbox" id="marginnote-98" class="margin-toggle"/> <span class="marginnote"><code>StoryEnd</code> is the base case for our recursive function.</span>, so there isn’t much to do.</p>
<p>Now, if the <code>Adventure</code> our function gets is a <code>StoryMessage Message Adventure</code>, we want to print out the messages, and then continue on with the nested <code>Adventure</code>.</p>
<div class="sourceCode" id="cb289"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb289-1" data-line-number="1">tellAdventure (<span class="dt">StoryMessage</span> message adventure) <span class="fu">=</span> <span class="kw">do</span></a>
<a class="sourceLine" id="cb289-2" data-line-number="2">  sequence <span class="fu">.</span> map putStrLn <span class="fu">.</span> texts <span class="fu">$</span> message <span class="co">-- sequence is a function I haven&#39;t introduced before.</span></a>
<a class="sourceLine" id="cb289-3" data-line-number="3">  tellAdventure adventure</a></code></pre></div>
<p>This uses a big chain of function composition, plus a new function. I love function composition but it can be confusing if you’re not used to it<label for="marginnote-99" class="margin-toggle">⊕</label> <input type="checkbox" id="marginnote-99" class="margin-toggle"/> <span class="marginnote">Since the order of execution with function composition goes ⬅️this way⬅️, we’re going to go over the expression backwards.</span>. Let’s break it down:</p>
<div class="sourceCode" id="cb290"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb290-1" data-line-number="1">  sequence <span class="fu">.</span> map putStrLn <span class="fu">.</span> texts <span class="fu">$</span> message</a>
<a class="sourceLine" id="cb290-2" data-line-number="2"><span class="co">--  [4]         [3]          [2]     [1]</span></a></code></pre></div>
<ol type="1">
<li><p><code>message</code> - This is the message that was passed to our function to be printed.</p></li>
<li><p><code>texts</code> - This is a function we got for free from defining <code>Message</code> with record syntax. It takes a <code>Message</code> and returns the List of <code>String</code>s inside.</p></li>
<li><p><code>map putStrLn</code> - If you recall, <code>map</code> is a function that takes a function and a List, and returns a new List where the function has been applied to every member of the old List. And <code>putStrLn</code> is a function that takes a <code>String</code> and returns an IO action that prints that string. So <code>map putStrLn</code> will take a List of <code>String</code>s, and return a List of IO actions that prints those strings.</p></li>
<li><p><code>sequence</code> - This is a function that takes a List of IO actions, and returns an IO action that executes all of them, one after another.</p></li>
</ol>
<p>So <code>message</code> gets passed to <code>texts</code>, which returns the <code>[String]</code> inside. That gets passed to <code>map putStrLn</code>, which makes a List of <code>IO</code> actions, each of which will print a line from the List of messages. That gets passed to <code>sequence</code>, which turns a List of IO actions to an IO action which, when executed, will execute every item in the List. The result of this is that every text item in <code>message</code> will get printed to the screen.</p>
<p>So that’s 2/3 done, the last thing we need is to do is to show the users a List of choices, allow them to choose one, and then continue with the adventure that’s contained within that choice. We’ll do this by numbering the choices, use <code>getLine</code> to let the user enter a number, and continue with the adventure in the corresponding <code>Choice</code><label for="marginnote-100" class="margin-toggle">⊕</label> <input type="checkbox" id="marginnote-100" class="margin-toggle"/> <span class="marginnote">Remember, each <code>Choice</code> contains an <code>Adventure</code>.</span>.</p>
<div class="sourceCode" id="cb291"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb291-1" data-line-number="1">tellAdventure (<span class="dt">StoryChoice</span> choices) <span class="fu">=</span> <span class="kw">do</span></a>
<a class="sourceLine" id="cb291-2" data-line-number="2">  sequence <span class="fu">.</span> map putStrLn <span class="fu">.</span> map (\x <span class="ot">-&gt;</span> <span class="st">&quot;  &quot;</span> <span class="fu">++</span> (show <span class="fu">.</span> fst <span class="fu">$</span> x) <span class="fu">++</span> <span class="st">&quot;: &quot;</span> <span class="fu">++</span> (choice <span class="fu">.</span> snd <span class="fu">$</span> x)) <span class="fu">$</span> indexedChoices</a>
<a class="sourceLine" id="cb291-3" data-line-number="3">  putStr <span class="st">&quot;Choice: &quot;</span></a>
<a class="sourceLine" id="cb291-4" data-line-number="4">  userChoiceIndex <span class="ot">&lt;-</span> getLine</a>
<a class="sourceLine" id="cb291-5" data-line-number="5">  tellAdventure <span class="fu">.</span> result <span class="fu">.</span> ((choices <span class="fu">-</span> <span class="dv">1</span>) <span class="fu">!!</span>) <span class="fu">.</span> read <span class="fu">$</span> userChoiceIndex</a>
<a class="sourceLine" id="cb291-6" data-line-number="6">  <span class="kw">where</span> indexedChoices <span class="fu">=</span> zip [<span class="dv">1</span><span class="fu">..</span>] choices </a></code></pre></div>
<p>You may think that the first line is a bit intimidating<label for="marginnote-101" class="margin-toggle">⊕</label> <input type="checkbox" id="marginnote-101" class="margin-toggle"/> <span class="marginnote">It’s actually really not so bad when you see it only composes four functions.</span>. But I’m only writing it like this because lots of Haskell code is a big mess of function composition, and you have to learn to work through it. You’ll also notice that we use the <code>zip</code> function which I spoke about in an earlier chapter but never actually explained. Let’s break this all down.</p>
<div class="sourceCode" id="cb292"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb292-1" data-line-number="1">   sequence <span class="fu">.</span> map putStrLn <span class="fu">.</span> map (\x <span class="ot">-&gt;</span> <span class="st">&quot;  &quot;</span> <span class="fu">++</span> (show <span class="fu">.</span> fst <span class="fu">$</span> x) <span class="fu">++</span> <span class="st">&quot;: &quot;</span> <span class="fu">++</span> (choice <span class="fu">.</span> snd <span class="fu">$</span> x)) <span class="fu">$</span> indexedChoices </a>
<a class="sourceLine" id="cb292-2" data-line-number="2"><span class="co">--  [5]           [4]                                            [3]                                  [2]</span></a>
<a class="sourceLine" id="cb292-3" data-line-number="3"></a>
<a class="sourceLine" id="cb292-4" data-line-number="4">   <span class="kw">where</span> indexedChoices <span class="fu">=</span> zip [<span class="dv">1</span><span class="fu">..</span>] choices </a>
<a class="sourceLine" id="cb292-5" data-line-number="5"><span class="co">--                             [1] </span></a></code></pre></div>
<p>Remember, what we want here is to go from a List of <code>Choice</code>s to an IO action which will print all the choices, with their index.</p>
<ol type="1">
<li><p><code>zip [1..] choices</code> - <code>zip</code> is a function that takes two lists, of possibly different types, and returns a List of 2-tuples. The first 2-tuple is the first element of the first List, and the first element of the second List, the second 2-tuple is the second element of the first List, and the second element of the second List, and so on.</p>
<p>For example, if you run <code>zip [1,2,3] ['a', 'b', 'c']</code>, the result will be <code>[(1,'a'), (2,'b'), (3,'c')]</code>. If one List is longer than the other, then the zipped List is chopped at the shorter List. This means that <code>zip [1..] choices</code> will return a List of tuples, where the first element is <code>(1, &lt;the first choice&gt;)</code>, the second element is <code>(2, &lt;the second choice&gt;)</code>, etc.</p>
<p>We do this because we want to show the indices of each choice when we’re printing them, so the user can just type the index of the choice they’d like. The result of this is a List of <code>(Integer, Choice)</code>s.</p></li>
<li><p><code>indexedChoices</code> - This is the List of 2-tuples that represent the choice and the index of that choice<label for="marginnote-102" class="margin-toggle">⊕</label> <input type="checkbox" id="marginnote-102" class="margin-toggle"/> <span class="marginnote"><code>[(1, &lt;the first choice&gt;), (2, &lt;the second choice&gt;), ...]</code></span>. Remember it is a List of <code>(Integer, Choice)</code>s.</p></li>
<li><div class="sourceCode" id="cb293"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb293-1" data-line-number="1"> map (\x <span class="ot">-&gt;</span> <span class="st">&quot;  &quot;</span> <span class="fu">++</span> (show <span class="fu">.</span> fst <span class="fu">$</span> x) </a>
<a class="sourceLine" id="cb293-2" data-line-number="2">                 <span class="fu">++</span> <span class="st">&quot;: &quot;</span> </a>
<a class="sourceLine" id="cb293-3" data-line-number="3">                 <span class="fu">++</span> (choice <span class="fu">.</span> snd <span class="fu">$</span> x))</a></code></pre></div>
<p>It may seem intimidating, but what it does is very simple. It maps over the List of <code>(Integer, Choice)</code>s and returns a list of <code>String</code>s. This <code>String</code> will look like the</p>
<div class="sourceCode" id="cb294"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb294-1" data-line-number="1">  <span class="dv">3</span><span class="fu">:</span> <span class="dt">I</span> have a good feeling about the light to my left</a></code></pre></div>
<p>that we saw earlier.</p>
<p>We start out with <code>&quot;  &quot;</code>, to offset the text to the right which will differentiate it from the rest of the rest of the story<label for="marginnote-103" class="margin-toggle">⊕</label> <input type="checkbox" id="marginnote-103" class="margin-toggle"/> <span class="marginnote">Offsetting the choices to differentiate them isn’t necessary, it’s just good visual design.</span>.</p>
<p>We then want to add the index of the choice. We do this by adding <code>(show . fst $ x)</code>. Remember, <code>x</code> is a <code>(Integer, Choice)</code>, so <code>fst</code> will take out the <code>Integer</code>, and then <code>show</code> will turn it into a <code>String</code>, so it can be appended to <code>&quot;  &quot;</code>.</p>
<p>Next, we add <code>&quot;: &quot;</code>. So far what we have will look something like <code>3:</code>.</p>
<p>Now we just need to add the actual text of the question. We do that by adding <code>(choice . snd $ x)</code>. <code>snd</code> gets the <code>Choice</code> out of <code>(Integer, Choice)</code>. Then we extract the text of the <code>Choice</code> with the <code>choice</code> we got from record syntax.</p>
<p>The result of all this is a List of <code>String</code>s that look like:</p>
<div class="sourceCode" id="cb295"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb295-1" data-line-number="1">  <span class="dv">3</span><span class="fu">:</span> <span class="dt">I</span> have a good feeling about the light to my left</a></code></pre></div></li>
<li><p><code>map putStrLn</code> - This looks like something we’ve seen before! It turns the List of <code>String</code>s that we made previously into a List of <code>IO ()</code> actions which, when executed, will print the strings we made in the last function.</p></li>
<li><p><code>sequence</code> - This will take a List of IO actions and return an IO action that, when executed, will execute each action in the List.</p></li>
</ol>
<p>The result of this is we’ve gone from a List of <code>Choice</code>s to an IO action which will print all the choices, with their index.</p>
<p>The next thing this function does is run <code>putStr &quot;Choice: &quot;</code>. What this does is write <code>&quot;Choice: &quot;</code> to the terminal, <em>without</em> a newline at the end (If we wanted a newline, we’d use <code>putStrLn</code>).</p>
<p>Next, we run <code>userChoiceIndex &lt;- getLine</code> which allows the user to type a <code>String</code> to the terminal. The <code>String</code> is assigned to the name <code>userChoiceIndex</code>.</p>
<p>The last part of the function is the line:</p>
<div class="sourceCode" id="cb296"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb296-1" data-line-number="1">tellAdventure <span class="fu">.</span> result <span class="fu">.</span> ((choices <span class="fu">-</span> <span class="dv">1</span>) <span class="fu">!!</span>) <span class="fu">.</span> read <span class="fu">$</span> userChoiceIndex</a></code></pre></div>
<p>Again, this is a big mess of function composition. Let’s break it down.</p>
<div class="sourceCode" id="cb297"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb297-1" data-line-number="1">  tellAdventure <span class="fu">.</span> result <span class="fu">.</span> (choices <span class="fu">!!</span>) <span class="fu">.</span> (\x <span class="ot">-&gt;</span> x<span class="fu">-</span><span class="dv">1</span>) <span class="fu">.</span> read <span class="fu">$</span> userChoiceIndex</a>
<a class="sourceLine" id="cb297-2" data-line-number="2"><span class="co">--    [6]          [5]          [4]           [3]       [2]         [1]</span></a></code></pre></div>
<ol type="1">
<li><p><code>userChoiceIndex</code> - This is a <code>String</code> of what the user entered when prompted for a choice.</p></li>
<li><p><code>read</code> - This is a function that takes a <code>String</code>, and returns whatever type is necessary, in this case, <code>Integer</code>.</p></li>
<li><p><code>(\x -&gt; x-1)</code> - This is a function that will take a number, and return that number lowered by one. This is because Haskell List indices start at <code>0</code>, but the indices we showed at screen started at <code>1</code>. So if they entered <code>1</code>, we want <code>0</code>. This function takes an <code>Integer</code> and returns an <code>Integer</code>.</p></li>
<li><p><code>(choices !!)</code> - This is a function that takes a number, and returns whatever element of <code>choices</code> is at that index. Remember, that is what <code>!!</code> does, <code>&quot;abcde&quot; !! 3</code> will return <code>'d'</code>. <code>choices</code> is a List of <code>Choice</code>s, so this returns a <code>Choice</code>.</p></li>
<li><p><code>result</code> - This is a function we got from <code>Choice</code>’s record syntax. It takes a <code>Choice</code> and returns the <code>Adventure</code> contained within.</p></li>
<li><p><code>tellAdventure</code> - Finally, this recursively calls <code>tellAdventure</code> again with the <code>Adventure</code> returned by <code>result</code>.</p></li>
</ol>
<p>There! That’s the function that does all the work here. Quite a lot of explanation for an 11 line function, which you can take as a testimony to Haskell’s terseness. If you look at the whole function at once, it doesn’t seem so bad.</p>
<div class="sourceCode" id="cb298"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb298-1" data-line-number="1"><span class="ot">tellAdventure ::</span> <span class="dt">Adventure</span> <span class="ot">-&gt;</span> <span class="dt">IO</span> ()</a>
<a class="sourceLine" id="cb298-2" data-line-number="2">tellAdventure <span class="dt">StoryEnd</span> <span class="fu">=</span> </a>
<a class="sourceLine" id="cb298-3" data-line-number="3">  putStrLn <span class="st">&quot;Story over!&quot;</span></a>
<a class="sourceLine" id="cb298-4" data-line-number="4">  </a>
<a class="sourceLine" id="cb298-5" data-line-number="5">tellAdventure (<span class="dt">StoryMessage</span> message adventure) <span class="fu">=</span> <span class="kw">do</span></a>
<a class="sourceLine" id="cb298-6" data-line-number="6">  sequence <span class="fu">.</span> map putStrLn <span class="fu">.</span> texts <span class="fu">$</span> message</a>
<a class="sourceLine" id="cb298-7" data-line-number="7">  tellAdventure adventure</a>
<a class="sourceLine" id="cb298-8" data-line-number="8"></a>
<a class="sourceLine" id="cb298-9" data-line-number="9">tellAdventure (<span class="dt">StoryChoice</span> choices) <span class="fu">=</span> <span class="kw">do</span></a>
<a class="sourceLine" id="cb298-10" data-line-number="10">  sequence <span class="fu">.</span> map putStrLn <span class="fu">.</span> map (\x <span class="ot">-&gt;</span> <span class="st">&quot;  &quot;</span> <span class="fu">++</span> (show <span class="fu">.</span> fst <span class="fu">$</span> x) <span class="fu">++</span> <span class="st">&quot;: &quot;</span> <span class="fu">++</span> (choice <span class="fu">.</span> snd <span class="fu">$</span> x)) <span class="fu">$</span> indexedChoices</a>
<a class="sourceLine" id="cb298-11" data-line-number="11">  putStr <span class="st">&quot;Choice: &quot;</span></a>
<a class="sourceLine" id="cb298-12" data-line-number="12">  userChoiceIndex <span class="ot">&lt;-</span> getLine</a>
<a class="sourceLine" id="cb298-13" data-line-number="13">  tellAdventure <span class="fu">.</span> result <span class="fu">.</span> (choices <span class="fu">!!</span>) <span class="fu">.</span> (\x <span class="ot">-&gt;</span> x<span class="fu">-</span><span class="dv">1</span>) <span class="fu">.</span> read <span class="fu">$</span> userChoiceIndex</a>
<a class="sourceLine" id="cb298-14" data-line-number="14">  <span class="kw">where</span> indexedChoices <span class="fu">=</span> zip [<span class="dv">1</span><span class="fu">..</span>] choices</a></code></pre></div>
<p>Now, we just need to write the <code>Main</code> function and put it all together.</p>
<div class="sourceCode" id="cb299"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb299-1" data-line-number="1"><span class="ot">main ::</span> <span class="dt">IO</span> ()</a>
<a class="sourceLine" id="cb299-2" data-line-number="2">main <span class="fu">=</span> <span class="kw">do</span></a>
<a class="sourceLine" id="cb299-3" data-line-number="3">  tellAdventure story</a>
<a class="sourceLine" id="cb299-4" data-line-number="4">  <span class="kw">where</span> story <span class="fu">=</span> <span class="dt">StoryMessage</span> (<span class="dt">Info</span> [<span class="st">&quot;You awaken in a dark cavern, only the dimmest light illuminating your surroundings.&quot;</span>, </a>
<a class="sourceLine" id="cb299-5" data-line-number="5">                                    <span class="st">&quot;You try to remember how you got there, but you realize you can&#39;t remember anything - not even your own name.&quot;</span>,</a>
<a class="sourceLine" id="cb299-6" data-line-number="6">                                    <span class="st">&quot;You look around, and see two pinpricks of light in the distance, one to your left and one to your right.&quot;</span>,</a>
<a class="sourceLine" id="cb299-7" data-line-number="7">                                    <span class="st">&quot;Could they be exits?&quot;</span>]) </a>
<a class="sourceLine" id="cb299-8" data-line-number="8">                             (<span class="dt">StoryChoice</span> [<span class="dt">Choice</span> <span class="st">&quot;Probably not, better to sit here and wait for someone to find me.&quot;</span> <span class="dt">StoryEnd</span>, </a>
<a class="sourceLine" id="cb299-9" data-line-number="9">                                           <span class="dt">Choice</span> <span class="st">&quot;Hmm... I&#39;ll go explore the possible exit on my right.&quot;</span> <span class="dt">StoryEnd</span>, </a>
<a class="sourceLine" id="cb299-10" data-line-number="10">                                           <span class="dt">Choice</span> <span class="st">&quot;I have a good feeling about the light to my left&quot;</span> <span class="dt">StoryEnd</span>]) </a></code></pre></div>
<p>We define <code>story</code>, and then call <code>tellAdventure</code> on it. If you try and extend the definition of <code>story</code>, be careful to mind your indentation! Haskell can be picky<label for="marginnote-104" class="margin-toggle">⊕</label> <input type="checkbox" id="marginnote-104" class="margin-toggle"/> <span class="marginnote">Fortunately, this pickiness tends to make sure your programs are aesthetically pleasing.</span>. This story is very simple - it displays a message, then offers 3 choices, all of which end the story. If you want, you can change <code>StoryEnd</code> to some other value of type <code>Adventure</code>, like a <code>StoryMessage</code> or another <code>StoryChoice</code>.</p>
<h2 id="exceptions">Exceptions</h2>
<p><span class="newthought">Recall the</span> <code>head</code> function. It takes a List and withdraws the first element from that List. So <code>head [1,2,3]</code> will return <code>1</code>. But what happens if the List is empty? Open GHCi and try to use <code>head []</code> to get the first value of an empty List.</p>
<div class="sourceCode" id="cb300"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb300-1" data-line-number="1"><span class="dt">Prelude</span><span class="fu">&gt;</span> head []</a>
<a class="sourceLine" id="cb300-2" data-line-number="2"><span class="fu">***</span> <span class="dt">Exception</span><span class="fu">:</span> Prelude.head<span class="fu">:</span> empty <span class="dt">List</span></a></code></pre></div>
<p>This makes some sense - There’s no first element of an empty List, so Haskell has no idea what to do. Instead, it <em>throw an exception</em>. If you don’t take care, a thrown exception can crash your whole program. Since <code>head</code> works properly with some inputs and creates an exception with others, it’s called a <em>partial function</em>. Functions that never throw an exception, no matter the input, are called <em>total functions</em>.</p>
<p>One way of handling partial functions is to just structure our program so they will never be provided with an input that results in a crash. For example, if you have a function that you know will always return a List with some number of elements, it’s safe to call <code>head</code> on the result of that function. However, this is sometimes tricky. If your function has a bug and accidentally returns an empty List, Haskell’s type system will not warn you and your program will crash at runtime<label for="marginnote-105" class="margin-toggle">⊕</label> <input type="checkbox" id="marginnote-105" class="margin-toggle"/> <span class="marginnote">A goal of Haskell is to catch as many bugs at compile time as possible.</span>! Let’s see another approach.</p>
<div class="sourceCode" id="cb301"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb301-1" data-line-number="1"><span class="co">-- headMaybe.hs</span></a>
<a class="sourceLine" id="cb301-2" data-line-number="2"><span class="ot">headMaybe ::</span> [a] <span class="ot">-&gt;</span> <span class="dt">Maybe</span> a</a>
<a class="sourceLine" id="cb301-3" data-line-number="3">headMaybe [] <span class="fu">=</span> <span class="dt">Nothing</span></a>
<a class="sourceLine" id="cb301-4" data-line-number="4">headMaybe xs <span class="fu">=</span> <span class="dt">Just</span> (head xs)</a></code></pre></div>
<p>So what does this do? If you try to pass <code>headMaybe</code> an empty List, it will return <code>Nothing</code>. But if you pass it any List that is not empty, it will return <code>Just &lt;first element of the List&gt;</code>.<label for="marginnote-106" class="margin-toggle">⊕</label> <input type="checkbox" id="marginnote-106" class="margin-toggle"/> <span class="marginnote">If you’re confused by <code>Maybe</code>, re-read the section on <a href="Parameterized%20Types">parameterized types</a></span>. So this function is total even though it uses the partial function <code>head</code>, because it only uses <code>head</code> in situations where it has no chance of throwing an exception. Let’s see it in action.</p>
<div class="sourceCode" id="cb302"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb302-1" data-line-number="1"><span class="dt">Prelude</span><span class="fu">&gt;</span> <span class="fu">:</span>l headMaybe<span class="fu">.</span>hs</a>
<a class="sourceLine" id="cb302-2" data-line-number="2">[<span class="dv">1</span> <span class="kw">of</span> <span class="dv">1</span>] <span class="dt">Compiling</span> <span class="dt">Main</span> ( headMaybe<span class="fu">.</span>hs, interpreted )</a>
<a class="sourceLine" id="cb302-3" data-line-number="3"><span class="dt">Ok</span>, one <span class="kw">module</span> loaded<span class="fu">.</span></a>
<a class="sourceLine" id="cb302-4" data-line-number="4"><span class="fu">*</span><span class="dt">Main</span><span class="fu">&gt;</span> headMaybe []</a>
<a class="sourceLine" id="cb302-5" data-line-number="5"><span class="dt">Nothing</span></a>
<a class="sourceLine" id="cb302-6" data-line-number="6"><span class="fu">*</span><span class="dt">Main</span><span class="fu">&gt;</span> headMaybe [<span class="dv">1</span>,<span class="dv">2</span>,<span class="dv">3</span>]</a>
<a class="sourceLine" id="cb302-7" data-line-number="7"><span class="dt">Just</span> <span class="dv">1</span></a></code></pre></div>
<p>Looks good to me. Do you remember our text adventure project? It had a small issue in it. If the user entered something other than a number when asked for their choice, when we call <code>read</code> on that value the program will crash because <code>read</code> can’t convert it. Luckily for us, there’s another useful function inside the <code>Data.Text</code> module called <code>readMaybe</code>. <code>readMaybe</code> is the same as read, except wrapped up in a <code>Maybe</code> so it can return <code>Nothing</code> if the value couldn’t be converted.<label for="marginnote-107" class="margin-toggle">⊕</label> <input type="checkbox" id="marginnote-107" class="margin-toggle"/> <span class="marginnote">If you remember, a module is a collection of related code. Not all of this code is made available at the start of your program due to <em>name collisions</em>, a concept that will be explained shortly.</span></p>
<p>To use a module, you have to <em>import</em> it with the <code>import</code> keyword at the start of your program. Here’s a demonstration. If you recall, in the last section we made this file:</p>
<div class="sourceCode" id="cb303"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb303-1" data-line-number="1"><span class="kw">module</span> <span class="dt">Main</span> <span class="kw">where</span></a>
<a class="sourceLine" id="cb303-2" data-line-number="2"></a>
<a class="sourceLine" id="cb303-3" data-line-number="3"><span class="kw">data</span> <span class="dt">Message</span> <span class="fu">=</span> <span class="dt">Speaking</span> {<span class="ot">texts ::</span> [<span class="dt">String</span>],<span class="ot"> speaker ::</span> <span class="dt">String</span>}  <span class="fu">|</span> <span class="dt">Info</span> {<span class="ot">texts ::</span> [<span class="dt">String</span>]}  </a>
<a class="sourceLine" id="cb303-4" data-line-number="4"></a>
<a class="sourceLine" id="cb303-5" data-line-number="5"><span class="kw">data</span> <span class="dt">Choice</span> <span class="fu">=</span> <span class="dt">Choice</span> {<span class="ot">choice ::</span> <span class="dt">String</span>,<span class="ot"> result ::</span> <span class="dt">Adventure</span>}</a>
<a class="sourceLine" id="cb303-6" data-line-number="6"></a>
<a class="sourceLine" id="cb303-7" data-line-number="7"><span class="kw">data</span> <span class="dt">Adventure</span> <span class="fu">=</span> <span class="dt">StoryEnd</span> <span class="fu">|</span> <span class="dt">StoryMessage</span> <span class="dt">Message</span> <span class="dt">Adventure</span> <span class="fu">|</span> <span class="dt">StoryChoice</span> [<span class="dt">Choice</span>]</a>
<a class="sourceLine" id="cb303-8" data-line-number="8"></a>
<a class="sourceLine" id="cb303-9" data-line-number="9"><span class="ot">tellAdventure ::</span> <span class="dt">Adventure</span> <span class="ot">-&gt;</span> <span class="dt">IO</span> ()</a>
<a class="sourceLine" id="cb303-10" data-line-number="10">tellAdventure <span class="dt">StoryEnd</span> <span class="fu">=</span> </a>
<a class="sourceLine" id="cb303-11" data-line-number="11">  putStrLn <span class="st">&quot;Story over!&quot;</span></a>
<a class="sourceLine" id="cb303-12" data-line-number="12">  </a>
<a class="sourceLine" id="cb303-13" data-line-number="13">tellAdventure (<span class="dt">StoryMessage</span> message adventure) <span class="fu">=</span> <span class="kw">do</span></a>
<a class="sourceLine" id="cb303-14" data-line-number="14">  sequence <span class="fu">.</span> map putStrLn <span class="fu">.</span> texts <span class="fu">$</span> message</a>
<a class="sourceLine" id="cb303-15" data-line-number="15">  tellAdventure adventure</a>
<a class="sourceLine" id="cb303-16" data-line-number="16"></a>
<a class="sourceLine" id="cb303-17" data-line-number="17">tellAdventure (<span class="dt">StoryChoice</span> choices) <span class="fu">=</span> <span class="kw">do</span></a>
<a class="sourceLine" id="cb303-18" data-line-number="18">  sequence <span class="fu">.</span> map putStrLn <span class="fu">.</span> map (\x <span class="ot">-&gt;</span> <span class="st">&quot;  &quot;</span> <span class="fu">++</span> (show <span class="fu">.</span> fst <span class="fu">$</span> x) <span class="fu">++</span> <span class="st">&quot;: &quot;</span> <span class="fu">++</span> (choice <span class="fu">.</span> snd <span class="fu">$</span> x)) <span class="fu">$</span> indexedChoices</a>
<a class="sourceLine" id="cb303-19" data-line-number="19">  putStr <span class="st">&quot;Choice: &quot;</span></a>
<a class="sourceLine" id="cb303-20" data-line-number="20">  userChoiceIndex <span class="ot">&lt;-</span> getLine</a>
<a class="sourceLine" id="cb303-21" data-line-number="21">  tellAdventure <span class="fu">.</span> result <span class="fu">.</span> (choices <span class="fu">!!</span>) <span class="fu">.</span> (\x <span class="ot">-&gt;</span> x<span class="fu">-</span><span class="dv">1</span>) <span class="fu">.</span> read <span class="fu">$</span> userChoiceIndex</a>
<a class="sourceLine" id="cb303-22" data-line-number="22">  <span class="kw">where</span> indexedChoices <span class="fu">=</span> zip [<span class="dv">1</span><span class="fu">..</span>] choices</a>
<a class="sourceLine" id="cb303-23" data-line-number="23">  </a>
<a class="sourceLine" id="cb303-24" data-line-number="24"></a>
<a class="sourceLine" id="cb303-25" data-line-number="25"><span class="ot">main ::</span> <span class="dt">IO</span> ()</a>
<a class="sourceLine" id="cb303-26" data-line-number="26">main <span class="fu">=</span> <span class="kw">do</span></a>
<a class="sourceLine" id="cb303-27" data-line-number="27">  tellAdventure story</a>
<a class="sourceLine" id="cb303-28" data-line-number="28">  <span class="kw">where</span> story <span class="fu">=</span> <span class="dt">StoryMessage</span> (<span class="dt">Info</span> [<span class="st">&quot;You awaken in a dark cavern, only the dimmest light illuminating your surroundings.&quot;</span>, </a>
<a class="sourceLine" id="cb303-29" data-line-number="29">                                    <span class="st">&quot;You try to remember how you got there, but you realize you can&#39;t remember anything - not even your own name.&quot;</span>,</a>
<a class="sourceLine" id="cb303-30" data-line-number="30">                                    <span class="st">&quot;You look around, and see two pinpricks of light in the distance, one to your left and one to your right.&quot;</span>,</a>
<a class="sourceLine" id="cb303-31" data-line-number="31">                                    <span class="st">&quot;Could they be exits?&quot;</span>]) </a>
<a class="sourceLine" id="cb303-32" data-line-number="32">                             (<span class="dt">StoryChoice</span> [<span class="dt">Choice</span> <span class="st">&quot;Probably not, better to sit here and wait for someone to find me.&quot;</span> <span class="dt">StoryEnd</span>, </a>
<a class="sourceLine" id="cb303-33" data-line-number="33">                                           <span class="dt">Choice</span> <span class="st">&quot;Hmm... I&#39;ll go explore the possible exit on my right.&quot;</span> <span class="dt">StoryEnd</span>, </a>
<a class="sourceLine" id="cb303-34" data-line-number="34">                                           <span class="dt">Choice</span> <span class="st">&quot;I have a good feeling about light to my left&quot;</span> <span class="dt">StoryEnd</span>]) </a></code></pre></div>
<p>Look at the first line:</p>
<div class="sourceCode" id="cb304"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb304-1" data-line-number="1"><span class="kw">module</span> <span class="dt">Main</span> <span class="kw">where</span></a></code></pre></div>
<p>This says we’re creating a new module named <code>Main</code>. To import a module, we add an import statement beneath:</p>
<div class="sourceCode" id="cb305"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb305-1" data-line-number="1"><span class="kw">module</span> <span class="dt">Main</span> <span class="kw">where</span></a>
<a class="sourceLine" id="cb305-2" data-line-number="2"><span class="kw">import</span> <span class="dt">Text.Read</span></a></code></pre></div>
<p>This will let us use all the functions in the <code>Text.Read</code> module<label for="marginnote-108" class="margin-toggle">⊕</label> <input type="checkbox" id="marginnote-108" class="margin-toggle"/> <span class="marginnote">If you import a module in your code, then import your code into GHCi, you automatically get access to everything that module imports.</span>. But if we do this and try to compile the project with <code>stack ghci</code>, we will get the following error:</p>
<div class="sourceCode" id="cb306"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb306-1" data-line-number="1">    <span class="dt">Ambiguous</span> occurrence <span class="ot">`choice&#39;                                                                                                                                         </span></a>
<a class="sourceLine" id="cb306-2" data-line-number="2"><span class="ot">    It could refer to either `</span>Text.Read.choice&#39;,                                                                                                                          </a>
<a class="sourceLine" id="cb306-3" data-line-number="3">                             imported from <span class="ot">`Text.Read&#39; at [...]\textAdventure\src\Main.hs:2:1-16</span></a>
<a class="sourceLine" id="cb306-4" data-line-number="4"><span class="ot">                             (and originally defined in `</span><span class="dt">Text.ParserCombinators.ReadPrec&#39;</span>)                                                                                </a>
<a class="sourceLine" id="cb306-5" data-line-number="5">                          or <span class="ot">`Main.choice&#39;,                                                                                                                               </span></a>
<a class="sourceLine" id="cb306-6" data-line-number="6"><span class="ot">                             defined at [...]\textAdventure\src\Main.hs:6:23                    </span></a>
<a class="sourceLine" id="cb306-7" data-line-number="7"><span class="ot">   |                                                                                                                                                                      </span></a>
<a class="sourceLine" id="cb306-8" data-line-number="8"><span class="ot">19 |   sequence . map putStrLn . map (\x -&gt; &quot;  &quot; ++ (show . fst $ x) ++ &quot;: &quot; ++ (choice . snd $ x)) $ indexedChoices                                                      </span></a>
<a class="sourceLine" id="cb306-9" data-line-number="9"><span class="ot">   |                                                                             ^^^^^^                                                                                   </span></a></code></pre></div>
<p>Can you figure out the issue? <code>Text.Read</code> has a function called <code>choice</code>, and we have a function called <code>choice</code>, and Haskell doesn’t know which to use! You can’t have two functions with the same name, because that’s confusing to you and confusing to the compiler. What we need to do is not import the <code>choice</code> function from <code>Text.Read</code><label for="marginnote-109" class="margin-toggle">⊕</label> <input type="checkbox" id="marginnote-109" class="margin-toggle"/> <span class="marginnote">We could also rename our <code>choice</code> function, but that’s annoying to have to do.</span>. We can do that with the <code>hiding</code> keyword, like this:</p>
<div class="sourceCode" id="cb307"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb307-1" data-line-number="1"><span class="kw">module</span> <span class="dt">Main</span> <span class="kw">where</span></a>
<a class="sourceLine" id="cb307-2" data-line-number="2"><span class="kw">import</span> <span class="dt">Text.Read</span> <span class="kw">hiding</span> (choice)</a></code></pre></div>
<p>This will tell Haskell to not import the <code>choice</code> function from <code>Text.Read</code>. Since we didn’t import it, Haskell won’t be tripped up by the value named <code>choice</code> we use later. But this isn’t ideal. We only want the <code>readMaybe</code> function, not all the functions except <code>choice</code>. We want to only import what we need<label for="marginnote-110" class="margin-toggle">⊕</label> <input type="checkbox" id="marginnote-110" class="margin-toggle"/> <span class="marginnote">This is so we won’t accidentally bump into a name collision again. Importing only what you need is usually a good idea.</span>. Here’s the syntax for that.</p>
<div class="sourceCode" id="cb308"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb308-1" data-line-number="1"><span class="kw">module</span> <span class="dt">Main</span> <span class="kw">where</span></a>
<a class="sourceLine" id="cb308-2" data-line-number="2"><span class="kw">import</span> <span class="dt">Text.Read</span> (readMaybe)</a></code></pre></div>
<p>If we wanted to import multiple functions, we can just separate them by commas, like <code>(function1, function2, etc)</code>. Here’s the type of <code>readMaybe</code>.</p>
<div class="sourceCode" id="cb309"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb309-1" data-line-number="1"><span class="dt">Prelude</span><span class="fu">&gt;</span> <span class="fu">:</span>t readMaybe</a>
<a class="sourceLine" id="cb309-2" data-line-number="2"><span class="ot">readMaybe ::</span> <span class="dt">Read</span> a <span class="ot">=&gt;</span> <span class="dt">String</span> <span class="ot">-&gt;</span> <span class="dt">Maybe</span> a</a></code></pre></div>
<p><span class="newthought">Let’s write</span> a function which will ask the user for a choice, and return an <code>(Integral a, Read a) =&gt; IO a</code> with the type the user entered. It needs to be a <code>Read</code> type because this function only makes sense for types that can be read from <code>String</code>s. It needs to be <code>Integral</code> because it wouldn’t make sense for the user to enter, say <code>3.5</code>. <code>Integral</code> is a typeclass for numbers with nothing after the decimal point.</p>
<div class="sourceCode" id="cb310"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb310-1" data-line-number="1"><span class="ot">getChoice ::</span> (<span class="dt">Integral</span> a, <span class="dt">Read</span> a) <span class="ot">=&gt;</span> <span class="dt">IO</span> a</a>
<a class="sourceLine" id="cb310-2" data-line-number="2">getChoice <span class="fu">=</span> <span class="kw">do</span></a>
<a class="sourceLine" id="cb310-3" data-line-number="3">    putStr <span class="st">&quot;Choice: &quot;</span></a>
<a class="sourceLine" id="cb310-4" data-line-number="4">    userChoiceIndex <span class="ot">&lt;-</span> getLine</a>
<a class="sourceLine" id="cb310-5" data-line-number="5">    maybeIndex <span class="ot">&lt;-</span> pure <span class="fu">.</span> readMaybeInt <span class="fu">$</span> userChoiceIndex </a>
<a class="sourceLine" id="cb310-6" data-line-number="6">    <span class="kw">case</span> maybeIndex <span class="kw">of</span> <span class="dt">Nothing</span> <span class="ot">-&gt;</span> getChoice</a>
<a class="sourceLine" id="cb310-7" data-line-number="7">                       <span class="dt">Just</span> index <span class="ot">-&gt;</span> pure index </a>
<a class="sourceLine" id="cb310-8" data-line-number="8">  <span class="kw">where</span></a>
<a class="sourceLine" id="cb310-9" data-line-number="9"><span class="ot">    readMaybeInt ::</span> (<span class="dt">Integral</span> a, <span class="dt">Read</span> a) <span class="ot">=&gt;</span> <span class="dt">String</span> <span class="ot">-&gt;</span> <span class="dt">Maybe</span> a</a>
<a class="sourceLine" id="cb310-10" data-line-number="10">    readMaybeInt <span class="fu">=</span> readMaybe</a></code></pre></div>
<p>Here’s how this function works. In the <code>where</code> block in the bottom, we define a function called <code>readMaybeInt</code>. It does the same thing as <code>readMaybe</code>, except we’ve added another type restriction on the output, specifically whatever it returns needs to be in the <code>Integral</code> typeclass as well as in the <code>Read</code> typeclass. <code>readMaybe</code> on it’s own would happily work on <code>3</code>, but it would also work on <code>3.5</code> or <code>True</code> or all sorts of other things we don’t want.</p>
<p>Now, let’s tackle the <code>do</code> expression. First we do <code>putStr &quot;Choice: &quot;</code>. This should hopefully be familiar at this point, it prints the text <code>Choice:</code> to the terminal without a newline at the end.</p>
<p>Then, we do <code>userChoiceIndex &lt;- getLine</code>. This lets the user enter some text, and binds that text to the name <code>userChoiceIndex</code>.</p>
<p>Then, we do:</p>
<div class="sourceCode" id="cb311"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb311-1" data-line-number="1">maybeIndex <span class="ot">&lt;-</span> pure <span class="fu">.</span> readMaybeInt <span class="fu">$</span> userChoiceIndex</a></code></pre></div>
<p>This calls <code>readMaybeInt</code> on <code>userChoiceIndex</code>. It then uses the <code>pure</code> function, which turns the <code>Maybe a</code> returned by <code>readMaybeInt</code> into an <code>IO Maybe a</code>. <code>pure</code> just takes a value of any type, and returns that value inside an <code>IO</code> type. In this case, its type signature is <code>return :: a -&gt; IO a</code>. We do this because every line in our <code>do</code> block has to be an <code>IO</code> type, but <code>readMaybeInt</code> returns a <code>Maybe a</code>, so the <code>pure</code> makes it a <code>IO Maybe a</code>. However, we bind it to <code>maybeIndex</code> with <code>&lt;-</code> which removes the <code>IO</code> wrapping, so <code>maybeIndex</code> is back to being a <code>Maybe a</code>. The <code>&lt;-</code> basically undoes all the work done by <code>pure</code>!media(Luckily GHC is smart enough to simplify this and not actually do anything.).</p>
<p>The last part of our function is a <code>case</code> expression. In case you forgot, <code>case</code> expressions allow us to do pattern matching inside a function. If <code>maybeIndex</code> is <code>Nothing</code>, the <code>case</code> expression evaluates to a recursive call of <code>getChoice</code>, starting the whole function over. Otherwise, the value is <code>Just index</code>, and we use <code>return index</code> to wrap index into an <code>IO</code>. Remember, the last expression of a <code>do</code> expression is what the whole thing returns, so this function will return an <code>IO</code> type that wraps up the index the user entered.</p>
<p>Put this function somewhere in <code>Main.hs</code> of <code>textAdventure</code>, and load it into GHCi with <code>stack ghci</code>. Lets test this function out:</p>
<div class="sourceCode" id="cb312"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb312-1" data-line-number="1"><span class="fu">*</span><span class="dt">Main</span><span class="fu">&gt;</span> getChoice</a>
<a class="sourceLine" id="cb312-2" data-line-number="2"><span class="dt">Choice</span><span class="fu">:</span> <span class="fl">3.5</span></a>
<a class="sourceLine" id="cb312-3" data-line-number="3"><span class="dt">Choice</span><span class="fu">:</span> <span class="dt">True</span></a>
<a class="sourceLine" id="cb312-4" data-line-number="4"><span class="dt">Choice</span><span class="fu">:</span> <span class="dv">3</span></a>
<a class="sourceLine" id="cb312-5" data-line-number="5"><span class="dv">3</span></a></code></pre></div>
<p>You can see that this <code>getChoice</code> will continually prompt us for choices until we enter a valid number, and then will return that number. Let’s modify <code>tellAdventure (StoryChoice choices)</code> to use <code>getChoice</code>. Here’s how it is now:</p>
<div class="sourceCode" id="cb313"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb313-1" data-line-number="1">tellAdventure (<span class="dt">StoryChoice</span> choices) <span class="fu">=</span> <span class="kw">do</span></a>
<a class="sourceLine" id="cb313-2" data-line-number="2">  sequence <span class="fu">.</span> map putStrLn <span class="fu">.</span> map (\x <span class="ot">-&gt;</span> <span class="st">&quot;  &quot;</span> <span class="fu">++</span> (show <span class="fu">.</span> fst <span class="fu">$</span> x) <span class="fu">++</span> <span class="st">&quot;: &quot;</span> <span class="fu">++</span> (choice <span class="fu">.</span> snd <span class="fu">$</span> x)) <span class="fu">$</span> indexedChoices</a>
<a class="sourceLine" id="cb313-3" data-line-number="3">  putStr <span class="st">&quot;Choice: &quot;</span></a>
<a class="sourceLine" id="cb313-4" data-line-number="4">  userChoiceIndex <span class="ot">&lt;-</span> getLine</a>
<a class="sourceLine" id="cb313-5" data-line-number="5">  tellAdventure <span class="fu">.</span> result <span class="fu">.</span> (choices <span class="fu">!!</span>) <span class="fu">.</span> (\x <span class="ot">-&gt;</span> x<span class="fu">-</span><span class="dv">1</span>) <span class="fu">.</span> read <span class="fu">$</span> userChoiceIndex</a>
<a class="sourceLine" id="cb313-6" data-line-number="6">  <span class="kw">where</span> indexedChoices <span class="fu">=</span> zip [<span class="dv">1</span><span class="fu">..</span>] choices</a></code></pre></div>
<p>All we have to do is remove line 3, change <code>getLine</code> to <code>getChoice</code> on line 4, and remove <code>. read</code> on line 5.</p>
<div class="sourceCode" id="cb314"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb314-1" data-line-number="1">tellAdventure (<span class="dt">StoryChoice</span> choices) <span class="fu">=</span> <span class="kw">do</span></a>
<a class="sourceLine" id="cb314-2" data-line-number="2">  sequence <span class="fu">.</span> map putStrLn <span class="fu">.</span> map (\x <span class="ot">-&gt;</span> <span class="st">&quot;  &quot;</span> <span class="fu">++</span> (show <span class="fu">.</span> fst <span class="fu">$</span> x) <span class="fu">++</span> <span class="st">&quot;: &quot;</span> <span class="fu">++</span> (choice <span class="fu">.</span> snd <span class="fu">$</span> x)) <span class="fu">$</span> indexedChoices</a>
<a class="sourceLine" id="cb314-3" data-line-number="3">  userChoiceIndex <span class="ot">&lt;-</span> getChoice</a>
<a class="sourceLine" id="cb314-4" data-line-number="4">  tellAdventure <span class="fu">.</span> result <span class="fu">.</span> (choices <span class="fu">!!</span>) <span class="fu">.</span> (\x <span class="ot">-&gt;</span> x<span class="fu">-</span><span class="dv">1</span>) <span class="fu">$</span> userChoiceIndex</a>
<a class="sourceLine" id="cb314-5" data-line-number="5">  <span class="kw">where</span> indexedChoices <span class="fu">=</span> zip [<span class="dv">1</span><span class="fu">..</span>] choices</a></code></pre></div>
<p>Type <code>:r</code><label for="marginnote-111" class="margin-toggle">⊕</label> <input type="checkbox" id="marginnote-111" class="margin-toggle"/> <span class="marginnote"><code>:r</code> is short for <code>:reload</code>.</span> in GHCi to reload the project, and then type <code>main</code> to test it out! Now our program won’t crash when you enter something that isn’t a number. However, we still have one issue. You can enter any number, but if you enter <code>-5</code> or <code>23839</code> the program will crash. Let’s modify <code>getChoice</code> so it takes a number which will serve as the maximum number it will allow. We’ll also disallow numbers less than zero.</p>
<div class="sourceCode" id="cb315"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb315-1" data-line-number="1"><span class="ot">getChoice ::</span> (<span class="dt">Integral</span> a, <span class="dt">Read</span> a) <span class="ot">=&gt;</span> a <span class="ot">-&gt;</span> <span class="dt">IO</span> a    <span class="co">-- Our function now takes an argument.</span></a>
<a class="sourceLine" id="cb315-2" data-line-number="2">getChoice numberOfOptions <span class="fu">=</span> <span class="kw">do</span></a>
<a class="sourceLine" id="cb315-3" data-line-number="3">    putStr <span class="st">&quot;Choice: &quot;</span></a>
<a class="sourceLine" id="cb315-4" data-line-number="4">    userChoiceIndex <span class="ot">&lt;-</span> getLine</a>
<a class="sourceLine" id="cb315-5" data-line-number="5">    maybeIndex <span class="ot">&lt;-</span> pure <span class="fu">.</span> readMaybeInt <span class="fu">$</span> userChoiceIndex</a>
<a class="sourceLine" id="cb315-6" data-line-number="6">    <span class="kw">case</span> maybeIndex <span class="kw">of</span> <span class="dt">Nothing</span> <span class="ot">-&gt;</span> getChoice numberOfOptions                   <span class="co">-- When calling getChoice recursively, we have to pass the input.</span></a>
<a class="sourceLine" id="cb315-7" data-line-number="7">                       <span class="dt">Just</span> index <span class="ot">-&gt;</span> <span class="kw">if</span> index <span class="fu">&lt;=</span> numberOfOptions <span class="fu">&amp;&amp;</span> index <span class="fu">&gt;</span> <span class="dv">0</span> <span class="co">-- We check if index is inside the range of allowed numbers.</span></a>
<a class="sourceLine" id="cb315-8" data-line-number="8">                                       <span class="kw">then</span> pure index                        <span class="co">-- If it is, return it.</span></a>
<a class="sourceLine" id="cb315-9" data-line-number="9">                                       <span class="kw">else</span> getChoice numberOfOptions         <span class="co">-- Otherwise, recurse.</span></a>
<a class="sourceLine" id="cb315-10" data-line-number="10">  <span class="kw">where</span></a>
<a class="sourceLine" id="cb315-11" data-line-number="11"><span class="ot">    readMaybeInt ::</span> (<span class="dt">Integral</span> a, <span class="dt">Read</span> a) <span class="ot">=&gt;</span> <span class="dt">String</span> <span class="ot">-&gt;</span> <span class="dt">Maybe</span> a</a>
<a class="sourceLine" id="cb315-12" data-line-number="12">    readMaybeInt <span class="fu">=</span> readMaybe</a></code></pre></div>
<p>Then, we just modify the third line of the <code>tellAdventure</code> function that matches the <code>(StoryChoice choices)</code> pattern to pass the length of the List to <code>getChoice</code>.</p>
<div class="sourceCode" id="cb316"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb316-1" data-line-number="1">tellAdventure (<span class="dt">StoryChoice</span> choices) <span class="fu">=</span> <span class="kw">do</span></a>
<a class="sourceLine" id="cb316-2" data-line-number="2">  sequence <span class="fu">.</span> map putStrLn <span class="fu">.</span> map (\x <span class="ot">-&gt;</span> <span class="st">&quot;  &quot;</span> <span class="fu">++</span> (show <span class="fu">.</span> fst <span class="fu">$</span> x) <span class="fu">++</span> <span class="st">&quot;: &quot;</span> <span class="fu">++</span> (choice <span class="fu">.</span> snd <span class="fu">$</span> x)) <span class="fu">$</span> indexedChoices</a>
<a class="sourceLine" id="cb316-3" data-line-number="3">  userChoiceIndex <span class="ot">&lt;-</span> getChoice (length choices)                 <span class="co">-- call getChoice with the length of the List </span></a>
<a class="sourceLine" id="cb316-4" data-line-number="4">  tellAdventure <span class="fu">.</span> result <span class="fu">.</span> (choices <span class="fu">!!</span>) <span class="fu">.</span> (\x <span class="ot">-&gt;</span> x<span class="fu">-</span><span class="dv">1</span>) <span class="fu">$</span> userChoiceIndex</a>
<a class="sourceLine" id="cb316-5" data-line-number="5">  <span class="kw">where</span> indexedChoices <span class="fu">=</span> zip [<span class="dv">1</span><span class="fu">..</span>] choices</a></code></pre></div>
<p>And voilà! We have now removed the two biggest bugs in our program. But it’s not very user friendly. If the user enters <code>one</code> when they meant <code>1</code>, we just show <code>Choice:</code> again. It doesn’t give any instruction for what the user should do. Let’s make one final change to the <code>getChoice</code> function. Remember, <code>do</code> is just syntax sugar for an expression, so we can use it in the <code>where</code> block<label for="marginnote-112" class="margin-toggle">⊕</label> <input type="checkbox" id="marginnote-112" class="margin-toggle"/> <span class="marginnote">We can even use <code>do</code> expressions inside <code>do</code> expressions!</span>.</p>
<div class="sourceCode" id="cb317"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb317-1" data-line-number="1"><span class="ot">getChoice ::</span> (<span class="dt">Integral</span> a, <span class="dt">Read</span> a, <span class="dt">Show</span> a) <span class="ot">=&gt;</span> a <span class="ot">-&gt;</span> <span class="dt">IO</span> a   <span class="co">-- We need to call show on the input, so a needs to be a member of the show typeclass.</span></a>
<a class="sourceLine" id="cb317-2" data-line-number="2">getChoice numberOfOptions <span class="fu">=</span> <span class="kw">do</span></a>
<a class="sourceLine" id="cb317-3" data-line-number="3">    putStr <span class="st">&quot;Choice: &quot;</span></a>
<a class="sourceLine" id="cb317-4" data-line-number="4">    userChoiceIndex <span class="ot">&lt;-</span> getLine</a>
<a class="sourceLine" id="cb317-5" data-line-number="5">    maybeIndex <span class="ot">&lt;-</span> pure <span class="fu">.</span> readMaybeInt <span class="fu">$</span> userChoiceIndex </a>
<a class="sourceLine" id="cb317-6" data-line-number="6">    <span class="kw">case</span> maybeIndex <span class="kw">of</span> <span class="dt">Nothing</span> <span class="ot">-&gt;</span> displayErrorAndRetry             <span class="co">-- Use the new displayErrorAndRetry function.</span></a>
<a class="sourceLine" id="cb317-7" data-line-number="7">                       <span class="dt">Just</span> index <span class="ot">-&gt;</span> <span class="kw">if</span> index <span class="fu">&lt;=</span> numberOfOptions <span class="fu">&amp;&amp;</span> index <span class="fu">&gt;</span> <span class="dv">0</span></a>
<a class="sourceLine" id="cb317-8" data-line-number="8">                                       <span class="kw">then</span> pure index</a>
<a class="sourceLine" id="cb317-9" data-line-number="9">                                       <span class="kw">else</span> displayErrorAndRetry   <span class="co">-- Use the new displayErrorAndRetry function.</span></a>
<a class="sourceLine" id="cb317-10" data-line-number="10">  <span class="kw">where</span></a>
<a class="sourceLine" id="cb317-11" data-line-number="11"><span class="ot">    readMaybeInt ::</span> (<span class="dt">Integral</span> a, <span class="dt">Read</span> a) <span class="ot">=&gt;</span> <span class="dt">String</span> <span class="ot">-&gt;</span> <span class="dt">Maybe</span> a</a>
<a class="sourceLine" id="cb317-12" data-line-number="12">    readMaybeInt <span class="fu">=</span> readMaybe</a>
<a class="sourceLine" id="cb317-13" data-line-number="13">    displayErrorAndRetry <span class="fu">=</span> <span class="kw">do</span>             <span class="co">-- Define a function that prints an error then returns getChoice numberOfOptions.</span></a>
<a class="sourceLine" id="cb317-14" data-line-number="14">      putStrLn <span class="fu">$</span> <span class="st">&quot;Please enter a number 1 through &quot;</span> <span class="fu">++</span> (show numberOfOptions) <span class="fu">++</span> <span class="st">&quot;.&quot;</span></a>
<a class="sourceLine" id="cb317-15" data-line-number="15">      getChoice numberOfOptions</a></code></pre></div>
<p>Now if you reload GHCi with <code>:r</code> and then run <code>main</code>, you’ll find a friendly error message when you enter an invalid value.</p>
<div class="sourceCode" id="cb318"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb318-1" data-line-number="1"><span class="fu">*</span><span class="dt">Main</span><span class="fu">&gt;</span> main</a>
<a class="sourceLine" id="cb318-2" data-line-number="2"><span class="dt">You</span> awaken <span class="kw">in</span> a dark cavern, only the dimmest light illuminating your surroundings<span class="fu">.</span></a>
<a class="sourceLine" id="cb318-3" data-line-number="3"><span class="dt">You</span> try to remember how you got there, but you realize you can&#39;t remember anything <span class="fu">-</span> not even your own name<span class="fu">.</span></a>
<a class="sourceLine" id="cb318-4" data-line-number="4"><span class="dt">You</span> look around, and see two pinpricks <span class="kw">of</span> light <span class="kw">in</span> the distance, one to your left and one to your right<span class="fu">.</span></a>
<a class="sourceLine" id="cb318-5" data-line-number="5"><span class="dt">Could</span> they be exits<span class="fu">?</span></a>
<a class="sourceLine" id="cb318-6" data-line-number="6">  <span class="dv">1</span><span class="fu">:</span> <span class="dt">Probably</span> not, better to sit here and wait for someone to find me<span class="fu">.</span></a>
<a class="sourceLine" id="cb318-7" data-line-number="7">  <span class="dv">2</span><span class="fu">:</span> <span class="fu">Hmm...</span> <span class="dt">I&#39;ll</span> go explore the possible exit on my right<span class="fu">.</span></a>
<a class="sourceLine" id="cb318-8" data-line-number="8">  <span class="dv">3</span><span class="fu">:</span> <span class="dt">I</span> have a good feeling about light to my left</a>
<a class="sourceLine" id="cb318-9" data-line-number="9"><span class="dt">Choice</span><span class="fu">:</span> <span class="dv">5</span></a>
<a class="sourceLine" id="cb318-10" data-line-number="10"><span class="dt">Please</span> enter a number <span class="dv">1</span> through <span class="dv">3</span><span class="fu">.</span></a>
<a class="sourceLine" id="cb318-11" data-line-number="11"><span class="dt">Choice</span><span class="fu">:</span> <span class="dv">2</span></a>
<a class="sourceLine" id="cb318-12" data-line-number="12"><span class="dt">Story</span> over<span class="fu">!</span></a></code></pre></div>
<p>There, that’s very nice. You can have a <code>do</code> expression anywhere Haskell expects an expression<label for="marginnote-113" class="margin-toggle">⊕</label> <input type="checkbox" id="marginnote-113" class="margin-toggle"/> <span class="marginnote">Of course, your program must typecheck. The type of a <code>do</code> expression is the type of the last line.</span>. That’s one of the things that makes them so powerful. <code>do</code> expressions have lots of uses besides IO, but IO is what it was originally designed for, so I thought it was fitting to introduce them that way. If you’ve been following along, here’s the whole project up to this point.</p>
<div class="sourceCode" id="cb319"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb319-1" data-line-number="1"><span class="kw">module</span> <span class="dt">Main</span> <span class="kw">where</span></a>
<a class="sourceLine" id="cb319-2" data-line-number="2"><span class="kw">import</span> <span class="dt">Text.Read</span> (readMaybe)</a>
<a class="sourceLine" id="cb319-3" data-line-number="3"></a>
<a class="sourceLine" id="cb319-4" data-line-number="4"><span class="kw">data</span> <span class="dt">Message</span> <span class="fu">=</span> <span class="dt">Speaking</span> {<span class="ot">texts ::</span> [<span class="dt">String</span>],<span class="ot"> speaker ::</span> <span class="dt">String</span>}  <span class="fu">|</span> <span class="dt">Info</span> {<span class="ot">texts ::</span> [<span class="dt">String</span>]}  </a>
<a class="sourceLine" id="cb319-5" data-line-number="5"></a>
<a class="sourceLine" id="cb319-6" data-line-number="6"><span class="kw">data</span> <span class="dt">Choice</span> <span class="fu">=</span> <span class="dt">Choice</span> {<span class="ot">choice ::</span> <span class="dt">String</span>,<span class="ot"> result ::</span> <span class="dt">Adventure</span>}</a>
<a class="sourceLine" id="cb319-7" data-line-number="7"></a>
<a class="sourceLine" id="cb319-8" data-line-number="8"><span class="kw">data</span> <span class="dt">Adventure</span> <span class="fu">=</span> <span class="dt">StoryEnd</span> <span class="fu">|</span> <span class="dt">StoryMessage</span> <span class="dt">Message</span> <span class="dt">Adventure</span> <span class="fu">|</span> <span class="dt">StoryChoice</span> [<span class="dt">Choice</span>]</a>
<a class="sourceLine" id="cb319-9" data-line-number="9"></a>
<a class="sourceLine" id="cb319-10" data-line-number="10"><span class="ot">getChoice ::</span> (<span class="dt">Integral</span> a, <span class="dt">Read</span> a, <span class="dt">Show</span> a) <span class="ot">=&gt;</span> a <span class="ot">-&gt;</span> <span class="dt">IO</span> a   <span class="co">-- we need to call show on the input, so a needs to be a member of the show typeclass  </span></a>
<a class="sourceLine" id="cb319-11" data-line-number="11">getChoice numberOfOptions <span class="fu">=</span> <span class="kw">do</span></a>
<a class="sourceLine" id="cb319-12" data-line-number="12">    putStr <span class="st">&quot;Choice: &quot;</span></a>
<a class="sourceLine" id="cb319-13" data-line-number="13">    userChoiceIndex <span class="ot">&lt;-</span> getLine</a>
<a class="sourceLine" id="cb319-14" data-line-number="14">    maybeIndex <span class="ot">&lt;-</span> pure <span class="fu">.</span> readMaybeInt <span class="fu">$</span> userChoiceIndex </a>
<a class="sourceLine" id="cb319-15" data-line-number="15">    <span class="kw">case</span> maybeIndex <span class="kw">of</span> <span class="dt">Nothing</span> <span class="ot">-&gt;</span> displayErrorAndRetry               <span class="co">-- note the change</span></a>
<a class="sourceLine" id="cb319-16" data-line-number="16">                       <span class="dt">Just</span> index <span class="ot">-&gt;</span> <span class="kw">if</span> index <span class="fu">&lt;=</span> numberOfOptions <span class="fu">&amp;&amp;</span> index <span class="fu">&gt;</span> <span class="dv">0</span></a>
<a class="sourceLine" id="cb319-17" data-line-number="17">                                       <span class="kw">then</span> pure index</a>
<a class="sourceLine" id="cb319-18" data-line-number="18">                                       <span class="kw">else</span> displayErrorAndRetry     <span class="co">-- note the change</span></a>
<a class="sourceLine" id="cb319-19" data-line-number="19">  <span class="kw">where</span></a>
<a class="sourceLine" id="cb319-20" data-line-number="20"><span class="ot">    readMaybeInt ::</span> (<span class="dt">Integral</span> a, <span class="dt">Read</span> a) <span class="ot">=&gt;</span> <span class="dt">String</span> <span class="ot">-&gt;</span> <span class="dt">Maybe</span> a</a>
<a class="sourceLine" id="cb319-21" data-line-number="21">    readMaybeInt <span class="fu">=</span> readMaybe</a>
<a class="sourceLine" id="cb319-22" data-line-number="22">    displayErrorAndRetry <span class="fu">=</span> <span class="kw">do</span>             <span class="co">-- define a function that prints an error then returns getChoice numberOfOptions </span></a>
<a class="sourceLine" id="cb319-23" data-line-number="23">      putStrLn <span class="fu">$</span> <span class="st">&quot;Please enter a number 1 through &quot;</span> <span class="fu">++</span> (show numberOfOptions) <span class="fu">++</span> <span class="st">&quot;.&quot;</span></a>
<a class="sourceLine" id="cb319-24" data-line-number="24">      getChoice numberOfOptions</a>
<a class="sourceLine" id="cb319-25" data-line-number="25"></a>
<a class="sourceLine" id="cb319-26" data-line-number="26"></a>
<a class="sourceLine" id="cb319-27" data-line-number="27"><span class="ot">tellAdventure ::</span> <span class="dt">Adventure</span> <span class="ot">-&gt;</span> <span class="dt">IO</span> ()</a>
<a class="sourceLine" id="cb319-28" data-line-number="28">tellAdventure <span class="dt">StoryEnd</span> <span class="fu">=</span> </a>
<a class="sourceLine" id="cb319-29" data-line-number="29">  putStrLn <span class="st">&quot;Story over!&quot;</span></a>
<a class="sourceLine" id="cb319-30" data-line-number="30">  </a>
<a class="sourceLine" id="cb319-31" data-line-number="31">tellAdventure (<span class="dt">StoryMessage</span> message adventure) <span class="fu">=</span> <span class="kw">do</span></a>
<a class="sourceLine" id="cb319-32" data-line-number="32">  sequence <span class="fu">.</span> map putStrLn <span class="fu">.</span> texts <span class="fu">$</span> message</a>
<a class="sourceLine" id="cb319-33" data-line-number="33">  tellAdventure adventure</a>
<a class="sourceLine" id="cb319-34" data-line-number="34"></a>
<a class="sourceLine" id="cb319-35" data-line-number="35">tellAdventure (<span class="dt">StoryChoice</span> choices) <span class="fu">=</span> <span class="kw">do</span></a>
<a class="sourceLine" id="cb319-36" data-line-number="36">  sequence <span class="fu">.</span> map putStrLn <span class="fu">.</span> map (\x <span class="ot">-&gt;</span> <span class="st">&quot;  &quot;</span> <span class="fu">++</span> (show <span class="fu">.</span> fst <span class="fu">$</span> x) <span class="fu">++</span> <span class="st">&quot;: &quot;</span> <span class="fu">++</span> (choice <span class="fu">.</span> snd <span class="fu">$</span> x)) <span class="fu">$</span> indexedChoices</a>
<a class="sourceLine" id="cb319-37" data-line-number="37">  userChoiceIndex <span class="ot">&lt;-</span> getChoice (length choices)</a>
<a class="sourceLine" id="cb319-38" data-line-number="38">  tellAdventure <span class="fu">.</span> result <span class="fu">.</span> (choices <span class="fu">!!</span>) <span class="fu">.</span> (\x <span class="ot">-&gt;</span> x<span class="fu">-</span><span class="dv">1</span>) <span class="fu">$</span> userChoiceIndex</a>
<a class="sourceLine" id="cb319-39" data-line-number="39">  <span class="kw">where</span> indexedChoices <span class="fu">=</span> zip [<span class="dv">1</span><span class="fu">..</span>] choices</a>
<a class="sourceLine" id="cb319-40" data-line-number="40">  </a>
<a class="sourceLine" id="cb319-41" data-line-number="41"></a>
<a class="sourceLine" id="cb319-42" data-line-number="42"><span class="ot">main ::</span> <span class="dt">IO</span> ()</a>
<a class="sourceLine" id="cb319-43" data-line-number="43">main <span class="fu">=</span> <span class="kw">do</span></a>
<a class="sourceLine" id="cb319-44" data-line-number="44">  tellAdventure story</a>
<a class="sourceLine" id="cb319-45" data-line-number="45">  <span class="kw">where</span> story <span class="fu">=</span> <span class="dt">StoryMessage</span> (<span class="dt">Info</span> [<span class="st">&quot;You awaken in a dark cavern, only the dimmest light illuminating your surroundings.&quot;</span>, </a>
<a class="sourceLine" id="cb319-46" data-line-number="46">                                    <span class="st">&quot;You try to remember how you got there, but you realize you can&#39;t remember anything - not even your own name.&quot;</span>,</a>
<a class="sourceLine" id="cb319-47" data-line-number="47">                                    <span class="st">&quot;You look around, and see two pinpricks of light in the distance, one to your left and one to your right.&quot;</span>,</a>
<a class="sourceLine" id="cb319-48" data-line-number="48">                                    <span class="st">&quot;Could they be exits?&quot;</span>]) </a>
<a class="sourceLine" id="cb319-49" data-line-number="49">                             (<span class="dt">StoryChoice</span> [<span class="dt">Choice</span> <span class="st">&quot;Probably not, better to sit here and wait for someone to find me.&quot;</span> <span class="dt">StoryEnd</span>, </a>
<a class="sourceLine" id="cb319-50" data-line-number="50">                                           <span class="dt">Choice</span> <span class="st">&quot;Hmm... I&#39;ll go explore the possible exit on my right.&quot;</span> <span class="dt">StoryEnd</span>, </a>
<a class="sourceLine" id="cb319-51" data-line-number="51">                                           <span class="dt">Choice</span> <span class="st">&quot;I have a good feeling about light to my left&quot;</span> <span class="dt">StoryEnd</span>]) </a></code></pre></div>
<h2 id="building-projects-for-distribution">Building Projects for Distribution</h2>
<p>Often you’d like to send a <code>.exe</code> file (or similar) to someone, so they can enjoy and experience it themselves. To do that, we need to <em>build</em> our project. To do that, run <code>stack build</code> while in the <code>textAdventure/</code> directory. In the terminal, you should see some text that says <code>Installing executable textAdventure in &lt;directory&gt;</code>. Go to that directory, and you should see a nice little standalone file you can share with all your friends!</p>
<h1 id="more-helpful-typeclasses">More Helpful Typeclasses</h1>
<h2 id="functors">Functors</h2>
<p><span class="newthought">In Haskell</span>, whenever there’s a container of some arbitrary “stuff” that can be mapped over, it’s a good candidate for the <code>Functor</code> typeclass<label for="marginnote-114" class="margin-toggle">⊕</label> <input type="checkbox" id="marginnote-114" class="margin-toggle"/> <span class="marginnote">Something in the <code>Functor</code> typeclass is called a <em>functor</em>, <em>endofunctor</em>, or sometimes a <em>covariant endofunctor</em>. But you’d only ever call it anything but “functor” if you were trying to show off your category theory chops.</span>. The most common example is Lists. There’s only one function inside the <code>Functor</code> typeclass, and that’s <code>fmap</code>, which is just like <code>map</code>.</p>
<div class="sourceCode" id="cb320"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb320-1" data-line-number="1"><span class="kw">instance</span> <span class="dt">Functor</span> [] <span class="kw">where</span>  </a>
<a class="sourceLine" id="cb320-2" data-line-number="2">    fmap <span class="fu">=</span> map  </a></code></pre></div>
<p>In general, <code>fmap</code> takes a function and a functor, and applies that function to the elements inside the functor. Let’s refresh our memory of how it works on lists.</p>
<div class="sourceCode" id="cb321"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb321-1" data-line-number="1"><span class="dt">Prelude</span><span class="fu">&gt;</span> fmap (<span class="fu">+</span><span class="dv">1</span>) [<span class="dv">1</span>,<span class="dv">2</span>,<span class="dv">3</span>,<span class="dv">4</span>,<span class="dv">5</span>]</a>
<a class="sourceLine" id="cb321-2" data-line-number="2">[<span class="dv">2</span>,<span class="dv">3</span>,<span class="dv">4</span>,<span class="dv">5</span>,<span class="dv">6</span>]</a></code></pre></div>
<p><code>Maybe</code> is also a functor. This is how it works:</p>
<div class="sourceCode" id="cb322"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb322-1" data-line-number="1"><span class="dt">Prelude</span><span class="fu">&gt;</span> fmap (<span class="fu">+</span><span class="dv">1</span>) (<span class="dt">Just</span> <span class="dv">3</span>)</a>
<a class="sourceLine" id="cb322-2" data-line-number="2"><span class="dt">Just</span> <span class="dv">4</span></a>
<a class="sourceLine" id="cb322-3" data-line-number="3"><span class="dt">Prelude</span><span class="fu">&gt;</span> fmap (<span class="fu">+</span><span class="dv">1</span>) <span class="dt">Nothing</span></a>
<a class="sourceLine" id="cb322-4" data-line-number="4"><span class="dt">Nothing</span></a></code></pre></div>
<p>And here’s how it’s defined:</p>
<div class="sourceCode" id="cb323"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb323-1" data-line-number="1"><span class="kw">instance</span> <span class="dt">Functor</span> <span class="dt">Maybe</span> <span class="kw">where</span>  </a>
<a class="sourceLine" id="cb323-2" data-line-number="2">    fmap f (<span class="dt">Just</span> x) <span class="fu">=</span> <span class="dt">Just</span> (f x)  </a>
<a class="sourceLine" id="cb323-3" data-line-number="3">    fmap f <span class="dt">Nothing</span> <span class="fu">=</span> <span class="dt">Nothing</span>  </a></code></pre></div>
<p>If you pass it a <code>Just &lt;something&gt;</code>, it will apply the function to the <code>&lt;something&gt;</code> inside. If you pass it <code>Nothing</code>, it will return <code>Nothing</code>. This is nice because it makes it easy for us to change the inside of a <code>Maybe</code>, but won’t crash on us if the result is <code>Nothing</code>.</p>
<p><code>fmap</code> also works on 2-tuples. What they do is surprising - they only operate on the second element of the tuple. Here’s a demonstration.</p>
<div class="sourceCode" id="cb324"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb324-1" data-line-number="1"><span class="dt">Prelude</span><span class="fu">&gt;</span> fmap (<span class="fu">+</span><span class="dv">1</span>) (<span class="st">&quot;Hello&quot;</span>, <span class="dv">4</span>)</a>
<a class="sourceLine" id="cb324-2" data-line-number="2">(<span class="st">&quot;Hello&quot;</span>,<span class="dv">5</span>)</a></code></pre></div>
<p>Functors have some rules, called <em>the functor laws</em>. There’s a function called <code>id</code>, which is special because it does absolutely nothing. Here’s how it’s defined.</p>
<div class="sourceCode" id="cb325"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb325-1" data-line-number="1">id<span class="ot"> ::</span> a <span class="ot">-&gt;</span> a</a>
<a class="sourceLine" id="cb325-2" data-line-number="2">id x <span class="fu">=</span> x </a></code></pre></div>
<p><code>id</code> takes one argument, and returns that argument unchanged. The first functor law is that if you evaluate <code>fmap id &lt;something&gt;</code>, the result should be <code>&lt;something&gt;</code>. Whatever you pass to <code>fmap id</code> should be returned unchanged.</p>
<p>The second functor law is that <code>fmap (f . g) = fmap f . fmap g</code>. Applying <code>fmap g</code>, and then applying <code>fmap f</code>, should be the same as if you just applied <code>fmap (f . g)</code>. This is convenient because these two laws mean that <code>fmap</code> probably won’t be doing anything other than just mapping over your function. Note that the functor laws aren’t enforced by Haskell - it’s up to the programmer to ensure they’re true. If you make a data type an instance of <code>Functor</code>, you should make absolutely sure that it doesn’t break any of the laws.</p>
<h2 id="monoids">Monoids</h2>
<p><span class="newthought">A <em>monoid</em></span> is very simple. It’s a function (or operator) <em>f</em> which takes two arguments<label for="marginnote-115" class="margin-toggle">⊕</label> <input type="checkbox" id="marginnote-115" class="margin-toggle"/> <span class="marginnote">A function (or operator) which takes two parameters is also called a binary function.</span>, and has a value that can be used as an <em>identity</em>, and is <em>associative</em>. We have two new words here, associative and identity. Let’s discuss what they mean with three famous monoids, addition (<code>+</code>), multiplication (<code>*</code>), and string concatenation (<code>++</code>).</p>
<p>Let’s look at addition.</p>
<ol type="1">
<li><p>Does it take two arguments? Yes.</p>
<div class="sourceCode" id="cb326"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb326-1" data-line-number="1"><span class="dt">Prelude</span><span class="fu">&gt;</span> <span class="dv">2</span> <span class="fu">+</span> <span class="dv">5</span></a>
<a class="sourceLine" id="cb326-2" data-line-number="2"><span class="dv">7</span></a></code></pre></div></li>
<li><p>Is it associative? That means parentheses don’t matter when evaluating it!(To rearrange the parentheses in an expression is to <em>reassociate</em> it. The technical definition of “associative” is that you can reassociate any way you want without changing the meaning of the expression. ).</p>
<div class="sourceCode" id="cb327"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb327-1" data-line-number="1"><span class="dt">Prelude</span><span class="fu">&gt;</span> <span class="dv">2</span> <span class="fu">+</span> <span class="dv">5</span> <span class="fu">+</span> <span class="dv">7</span> <span class="fu">+</span> <span class="dv">8</span></a>
<a class="sourceLine" id="cb327-2" data-line-number="2"><span class="dv">22</span></a>
<a class="sourceLine" id="cb327-3" data-line-number="3"><span class="dt">Prelude</span><span class="fu">&gt;</span> (<span class="dv">2</span> <span class="fu">+</span> <span class="dv">5</span>) <span class="fu">+</span> (<span class="dv">7</span> <span class="fu">+</span> <span class="dv">8</span>)</a>
<a class="sourceLine" id="cb327-4" data-line-number="4"><span class="dv">22</span></a>
<a class="sourceLine" id="cb327-5" data-line-number="5"><span class="dt">Prelude</span><span class="fu">&gt;</span> (<span class="dv">2</span> <span class="fu">+</span> (<span class="dv">5</span> <span class="fu">+</span> <span class="dv">7</span> <span class="fu">+</span> <span class="dv">8</span>))</a>
<a class="sourceLine" id="cb327-6" data-line-number="6"><span class="dv">22</span></a></code></pre></div>
<p>Seems that way!</p></li>
<li><p>Does it have an identity? For addition, that means “is there a value you can add to any number, and leave that number unchanged”. There is, <code>0</code>.</p>
<div class="sourceCode" id="cb328"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb328-1" data-line-number="1"><span class="dt">Prelude</span><span class="fu">&gt;</span> <span class="dv">16</span> <span class="fu">+</span> <span class="dv">0</span></a>
<a class="sourceLine" id="cb328-2" data-line-number="2"><span class="dv">16</span></a></code></pre></div></li>
</ol>
<p>Let’s look at multiplication.</p>
<ol type="1">
<li><p>Does it take two arguments? Yes.</p>
<div class="sourceCode" id="cb329"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb329-1" data-line-number="1"><span class="dt">Prelude</span><span class="fu">&gt;</span> <span class="dv">2</span> <span class="fu">*</span> <span class="dv">5</span></a>
<a class="sourceLine" id="cb329-2" data-line-number="2"><span class="dv">10</span></a></code></pre></div></li>
<li><p>Is it associative? That means parentheses don’t matter when evaluating it.</p>
<div class="sourceCode" id="cb330"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb330-1" data-line-number="1"><span class="dt">Prelude</span><span class="fu">&gt;</span> <span class="dv">2</span> <span class="fu">*</span> <span class="dv">5</span> <span class="fu">*</span> <span class="dv">7</span> <span class="fu">*</span> <span class="dv">8</span></a>
<a class="sourceLine" id="cb330-2" data-line-number="2"><span class="dv">560</span></a>
<a class="sourceLine" id="cb330-3" data-line-number="3"><span class="dt">Prelude</span><span class="fu">&gt;</span> (<span class="dv">2</span> <span class="fu">*</span> <span class="dv">5</span>) <span class="fu">*</span> (<span class="dv">7</span> <span class="fu">*</span> <span class="dv">8</span>)</a>
<a class="sourceLine" id="cb330-4" data-line-number="4"><span class="dv">560</span></a>
<a class="sourceLine" id="cb330-5" data-line-number="5"><span class="dt">Prelude</span><span class="fu">&gt;</span> (<span class="dv">2</span> <span class="fu">*</span> (<span class="dv">5</span> <span class="fu">*</span> <span class="dv">7</span> <span class="fu">*</span> <span class="dv">8</span>))</a>
<a class="sourceLine" id="cb330-6" data-line-number="6"><span class="dv">560</span></a></code></pre></div>
<p>Seems that way!</p></li>
<li><p>Does it have an identity? For multiplication, that means “is there a value you can multiply by any number, and leave that number unchanged”. There is, <code>1</code>.</p>
<div class="sourceCode" id="cb331"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb331-1" data-line-number="1"><span class="dt">Prelude</span><span class="fu">&gt;</span> <span class="dv">16</span> <span class="fu">*</span> <span class="dv">1</span></a>
<a class="sourceLine" id="cb331-2" data-line-number="2"><span class="dv">16</span></a></code></pre></div></li>
</ol>
<p>Now, let’s look at string concatenation.</p>
<ol type="1">
<li><p>Does it take two arguments? Yes.</p>
<div class="sourceCode" id="cb332"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb332-1" data-line-number="1"><span class="dt">Prelude</span><span class="fu">&gt;</span> <span class="st">&quot;Hello, &quot;</span>  <span class="fu">++</span> <span class="st">&quot;World!&quot;</span></a>
<a class="sourceLine" id="cb332-2" data-line-number="2"><span class="st">&quot;Hello, World!&quot;</span></a></code></pre></div></li>
<li><p>Is it associative? That means parentheses don’t matter when evaluating it.</p>
<div class="sourceCode" id="cb333"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb333-1" data-line-number="1"><span class="dt">Prelude</span><span class="fu">&gt;</span> <span class="st">&quot;Good morning, &quot;</span> <span class="fu">++</span> <span class="st">&quot;good afternoon, &quot;</span> <span class="fu">++</span> <span class="st">&quot;good evening, &quot;</span> <span class="fu">++</span> <span class="st">&quot;and good night!&quot;</span></a>
<a class="sourceLine" id="cb333-2" data-line-number="2"><span class="st">&quot;Good morning, good afternoon, good evening, and good night!&quot;</span></a>
<a class="sourceLine" id="cb333-3" data-line-number="3"><span class="dt">Prelude</span><span class="fu">&gt;</span> (<span class="st">&quot;Good morning, &quot;</span> <span class="fu">++</span>  <span class="st">&quot;good afternoon, &quot;</span>) <span class="fu">++</span> (<span class="st">&quot;good evening, &quot;</span> <span class="fu">++</span> <span class="st">&quot;and good night!&quot;</span>)</a>
<a class="sourceLine" id="cb333-4" data-line-number="4"><span class="st">&quot;Good morning, good afternoon, good evening, and good night!&quot;</span></a>
<a class="sourceLine" id="cb333-5" data-line-number="5"><span class="dt">Prelude</span><span class="fu">&gt;</span> (<span class="st">&quot;Good morning, &quot;</span> <span class="fu">++</span> (<span class="st">&quot;good afternoon, &quot;</span> <span class="fu">++</span> <span class="st">&quot;good evening, &quot;</span> <span class="fu">++</span> <span class="st">&quot;and good night!&quot;</span>))</a>
<a class="sourceLine" id="cb333-6" data-line-number="6"><span class="st">&quot;Good morning, good afternoon, good evening, and good night!&quot;</span></a></code></pre></div>
<p>Seems that way!</p></li>
<li><p>Does it have an identity? For string concatenation that means &quot;is there a value you can concatenate to any string, and leave that string unchanged. There is, <code>&quot;&quot;</code>.</p>
<div class="sourceCode" id="cb334"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb334-1" data-line-number="1"><span class="dt">Prelude</span><span class="fu">&gt;</span> <span class="st">&quot;Monoids!&quot;</span> <span class="fu">++</span> <span class="st">&quot;&quot;</span></a>
<a class="sourceLine" id="cb334-2" data-line-number="2"><span class="st">&quot;Monoids!&quot;</span></a></code></pre></div></li>
</ol>
<p>Hopefully, this should give you an intuition for monoids. Since we’re in a chapter about typeclasses, you might be confused. Being a monoid seems to be a property about operators, what does this have to do with types? Well, I mislead you somewhat. What we should have said was, <code>String</code>s form a monoid under <code>++</code>. It’s the type that’s the monoid, not the operator. Of course, one type can be a monoid under multiple operations, but in Haskell, we usually single out one operation to be “the” operation for that monoid. For example, <code>String</code>s have <code>++</code>, so <code>String</code> is a monoid.</p>
<p>Here’s how the <code>Monoid</code> typeclass is defined:</p>
<div class="sourceCode" id="cb335"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb335-1" data-line-number="1"><span class="kw">class</span> <span class="dt">Monoid</span> m <span class="kw">where</span></a>
<a class="sourceLine" id="cb335-2" data-line-number="2"><span class="ot">    mempty ::</span> m</a>
<a class="sourceLine" id="cb335-3" data-line-number="3"><span class="ot">    mappend ::</span> m <span class="ot">-&gt;</span> m <span class="ot">-&gt;</span> m</a>
<a class="sourceLine" id="cb335-4" data-line-number="4"><span class="ot">    mconcat ::</span> [m] <span class="ot">-&gt;</span> m</a>
<a class="sourceLine" id="cb335-5" data-line-number="5">    mconcat <span class="fu">=</span> foldr mappend mempty</a></code></pre></div>
<p>Let’s look at what each of these means.</p>
<p><code>mempty</code> is a function that returns the identity value for whatever monoid is in question. It’s short for “monoid empty”.</p>
<div class="sourceCode" id="cb336"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb336-1" data-line-number="1"><span class="dt">Prelude</span><span class="fu">&gt;</span><span class="ot"> mempty ::</span> <span class="dt">String</span></a>
<a class="sourceLine" id="cb336-2" data-line-number="2"><span class="st">&quot;&quot;</span></a>
<a class="sourceLine" id="cb336-3" data-line-number="3"><span class="dt">Prelude</span><span class="fu">&gt;</span> mempty <span class="fu">++</span> <span class="st">&quot;hello&quot;</span></a>
<a class="sourceLine" id="cb336-4" data-line-number="4"><span class="st">&quot;hello&quot;</span></a></code></pre></div>
<p>There’s <code>mappend</code>, which takes two <code>Monoid</code>s and does whatever our monoid operation is on them.</p>
<div class="sourceCode" id="cb337"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb337-1" data-line-number="1"><span class="dt">Prelude</span><span class="fu">&gt;</span> <span class="st">&quot;a&quot;</span> <span class="ot">`mappend`</span> <span class="st">&quot;b&quot;</span></a>
<a class="sourceLine" id="cb337-2" data-line-number="2"><span class="st">&quot;ab&quot;</span></a></code></pre></div>
<p>Lastly, there’s <code>mconcat</code>, which takes a List of monoids and <code>mappend</code>s them all.</p>
<div class="sourceCode" id="cb338"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb338-1" data-line-number="1"><span class="dt">Prelude</span><span class="fu">&gt;</span> mconcat [<span class="st">&quot;1&quot;</span>, <span class="st">&quot;2&quot;</span>, <span class="st">&quot;3&quot;</span>, <span class="st">&quot;4&quot;</span>]</a>
<a class="sourceLine" id="cb338-2" data-line-number="2"><span class="st">&quot;1234&quot;</span></a></code></pre></div>
<p>You may have noticed there are two operations under which numbers are monoids, <code>+</code> and <code>*</code>. Because of this, most number types aren’t in the <code>Monoid</code> typeclass, since they couldn’t pick one operation to be <em>the</em> operation for numbers. It does, however, have the types <code>Product</code> and <code>Sum</code> in the <code>Data.Monoid</code> module.</p>
<div class="sourceCode" id="cb339"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb339-1" data-line-number="1"><span class="dt">Prelude</span><span class="fu">&gt;</span> <span class="kw">import</span> <span class="dt">Data.Monoid</span></a>
<a class="sourceLine" id="cb339-2" data-line-number="2"><span class="dt">Prelude</span><span class="fu">&gt;</span> <span class="dt">Product</span> <span class="dv">3</span></a>
<a class="sourceLine" id="cb339-3" data-line-number="3"><span class="dt">Product</span> {getProduct <span class="fu">=</span> <span class="dv">3</span>}</a>
<a class="sourceLine" id="cb339-4" data-line-number="4"><span class="dt">Prelude</span><span class="fu">&gt;</span> (<span class="dt">Product</span> <span class="dv">3</span>) <span class="ot">`mappend`</span> mempty</a>
<a class="sourceLine" id="cb339-5" data-line-number="5"><span class="dt">Product</span> {getProduct <span class="fu">=</span> <span class="dv">3</span>}</a></code></pre></div>
<p>You may be wondering, what exactly is this <code>Product {getProduct = 3}</code> mess? It’s because <code>Product</code> is a type which acts as a wrapper around a number, so it can be in different typeclasses. <code>getProduct</code> is the function we can use to get the actual number.</p>
<div class="sourceCode" id="cb340"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb340-1" data-line-number="1"><span class="dt">Prelude</span><span class="fu">&gt;</span> threeProduct <span class="fu">=</span> <span class="dt">Product</span> <span class="dv">3</span></a>
<a class="sourceLine" id="cb340-2" data-line-number="2"><span class="dt">Prelude</span><span class="fu">&gt;</span> threeProduct</a>
<a class="sourceLine" id="cb340-3" data-line-number="3"><span class="dt">Product</span> {getProduct <span class="fu">=</span> <span class="dv">3</span>}</a>
<a class="sourceLine" id="cb340-4" data-line-number="4"><span class="dt">Prelude</span><span class="fu">&gt;</span> getProduct threeProduct</a>
<a class="sourceLine" id="cb340-5" data-line-number="5"><span class="dv">3</span></a></code></pre></div>
<p>Of course, there’s also Sum, which works the same way except its monoidal operation is <code>+</code> instead of <code>*</code>, and you extract the original number with <code>getSum</code>.</p>
<div class="sourceCode" id="cb341"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb341-1" data-line-number="1"><span class="dt">Prelude</span><span class="fu">&gt;</span> a <span class="fu">=</span> <span class="dt">Sum</span> <span class="dv">3</span></a>
<a class="sourceLine" id="cb341-2" data-line-number="2"><span class="dt">Prelude</span><span class="fu">&gt;</span> b <span class="fu">=</span> <span class="dt">Sum</span> <span class="dv">5</span></a>
<a class="sourceLine" id="cb341-3" data-line-number="3"><span class="dt">Prelude</span><span class="fu">&gt;</span> a <span class="ot">`mappend`</span> b</a>
<a class="sourceLine" id="cb341-4" data-line-number="4"><span class="dt">Sum</span> {getSum <span class="fu">=</span> <span class="dv">8</span>}</a>
<a class="sourceLine" id="cb341-5" data-line-number="5"><span class="dt">Prelude</span><span class="fu">&gt;</span> getSum a</a>
<a class="sourceLine" id="cb341-6" data-line-number="6"><span class="dv">3</span></a></code></pre></div>
<p>2-tuples can also be monoids, provided they contain monoids. The contents on the inside are just <code>mappend</code>ed to each other.</p>
<div class="sourceCode" id="cb342"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb342-1" data-line-number="1"><span class="dt">Prelude</span><span class="fu">&gt;</span> (<span class="st">&quot;Hello &quot;</span>, <span class="st">&quot;Goodbye &quot;</span>) <span class="ot">`mappend`</span> (<span class="st">&quot;world.&quot;</span>, <span class="st">&quot;planet.&quot;</span>)</a>
<a class="sourceLine" id="cb342-2" data-line-number="2">(<span class="st">&quot;Hello world.&quot;</span>,<span class="st">&quot;Goodbye planet.&quot;</span>)</a></code></pre></div>
<p>Let’s see how that works with the <code>Sum</code> an <code>Product</code> types.</p>
<div class="sourceCode" id="cb343"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb343-1" data-line-number="1"><span class="dt">Prelude</span><span class="fu">&gt;</span> <span class="kw">import</span> <span class="dt">Data.Monoid</span></a>
<a class="sourceLine" id="cb343-2" data-line-number="2"><span class="dt">Prelude</span><span class="fu">&gt;</span> (<span class="dt">Sum</span> <span class="dv">3</span>, <span class="dt">Product</span> <span class="dv">4</span>) <span class="ot">`mappend`</span> (<span class="dt">Sum</span> <span class="dv">10</span>, <span class="dt">Product</span> <span class="dv">2</span>)</a>
<a class="sourceLine" id="cb343-3" data-line-number="3">(<span class="dt">Sum</span> {getSum <span class="fu">=</span> <span class="dv">13</span>},<span class="dt">Product</span> {getProduct <span class="fu">=</span> <span class="dv">8</span>})</a></code></pre></div>
<p>So if you have two tuples of type <code>(a, b)</code>, and both <code>a</code> and <code>b</code> are <code>Monoid</code>s, then you can <code>mappend</code> the tuples and the contents will be <code>mappend</code>ed. Since regular numbers aren’t monoids, this won’t work.</p>
<div class="sourceCode" id="cb344"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb344-1" data-line-number="1"><span class="dt">Prelude</span><span class="fu">&gt;</span> (<span class="dv">1</span>,<span class="dv">2</span>) <span class="ot">`mappend`</span> (<span class="dv">2</span>,<span class="dv">3</span>)</a>
<a class="sourceLine" id="cb344-2" data-line-number="2"><span class="co">-- error!</span></a></code></pre></div>
<p><span class="newthought">Remember, if</span> you make one of your own types an instance of <code>Monoid</code>, it’s important that you <strong>make sure</strong> that your implementation follows the monoid laws of associativity and identity. If not, other programmers and yourself can get very confused!</p>
<h2 id="semigroups">Semigroups</h2>
<p><span class="newthought">*Semigroups are</span> very simple - they’re just monoids, but without the restriction that we must have an identity element. This means all monoids are semigroups. Any associative binary function forms a semigroup. Let’s see an example with the <code>max</code> function. The <code>max</code> function takes two values and returns whichever is greater.</p>
<div class="sourceCode" id="cb345"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb345-1" data-line-number="1"><span class="dt">Prelude</span><span class="fu">&gt;</span> max <span class="dv">3</span> <span class="dv">5</span></a>
<a class="sourceLine" id="cb345-2" data-line-number="2"><span class="dv">5</span></a>
<a class="sourceLine" id="cb345-3" data-line-number="3"><span class="dt">Prelude</span><span class="fu">&gt;</span> <span class="dv">3</span> <span class="ot">`max`</span> <span class="dv">5</span></a>
<a class="sourceLine" id="cb345-4" data-line-number="4"><span class="dv">5</span></a></code></pre></div>
<p>Is it associative? Let’s try.</p>
<div class="sourceCode" id="cb346"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb346-1" data-line-number="1"><span class="dt">Prelude</span><span class="fu">&gt;</span> <span class="dv">1</span> <span class="ot">`max`</span> <span class="dv">2</span> <span class="ot">`max`</span> <span class="dv">54</span> <span class="ot">`max`</span> <span class="dv">19</span> <span class="ot">`max`</span> (<span class="fu">-</span><span class="dv">1</span>)</a>
<a class="sourceLine" id="cb346-2" data-line-number="2"><span class="dv">54</span></a>
<a class="sourceLine" id="cb346-3" data-line-number="3"><span class="dt">Prelude</span><span class="fu">&gt;</span> <span class="dv">1</span> <span class="ot">`max`</span> (<span class="dv">2</span> <span class="ot">`max`</span> (<span class="dv">54</span> <span class="ot">`max`</span> <span class="dv">19</span>) <span class="ot">`max`</span> (<span class="fu">-</span><span class="dv">1</span>))</a>
<a class="sourceLine" id="cb346-4" data-line-number="4"><span class="dv">54</span></a>
<a class="sourceLine" id="cb346-5" data-line-number="5"><span class="dt">Prelude</span><span class="fu">&gt;</span> (<span class="dv">1</span> <span class="ot">`max`</span> <span class="dv">2</span> <span class="ot">`max`</span>) (<span class="dv">54</span> <span class="ot">`max`</span> <span class="dv">19</span>) <span class="ot">`max`</span> (<span class="fu">-</span><span class="dv">1</span>)</a>
<a class="sourceLine" id="cb346-6" data-line-number="6"><span class="dv">54</span></a></code></pre></div>
<p>Yes! A chain of <code>max</code>s will eventually output whichever value is highest, no matter where we put the parentheses. This means <code>max</code> is associative, so numbers form a semigroup under <code>max</code>.</p>
<p>Semigroup isn’t used very much, so I won’t belabor this too long.</p>
<h2 id="applicatives">Applicatives</h2>
<p><span class="newthought">An <em>applicative</em></span> is essentially a monoid mixed with a functor. Let me explain what that means.</p>
<p>As we’ve discussed before, Haskell functions are curried. This means that, while you can write <code>1+1</code> just fine, you can also just write <code>1+</code>, and then you get a function which will add one to whatever number you pass it. Let’s play with that.</p>
<div class="sourceCode" id="cb347"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb347-1" data-line-number="1"><span class="dt">Prelude</span><span class="fu">&gt;</span> <span class="fu">:</span>t fmap (<span class="fu">+</span>) (<span class="dt">Just</span> <span class="dv">3</span>)</a>
<a class="sourceLine" id="cb347-2" data-line-number="2">fmap (<span class="fu">+</span>) (<span class="dt">Just</span> <span class="dv">3</span>)<span class="ot"> ::</span> <span class="dt">Num</span> a <span class="ot">=&gt;</span> <span class="dt">Maybe</span> (a <span class="ot">-&gt;</span> a)</a>
<a class="sourceLine" id="cb347-3" data-line-number="3"><span class="dt">Prelude</span><span class="fu">&gt;</span> <span class="fu">:</span>t fmap (<span class="fu">+</span>) [<span class="dv">1</span>,<span class="dv">2</span>,<span class="dv">3</span>,<span class="dv">4</span>,<span class="dv">5</span>,<span class="dv">6</span>]</a>
<a class="sourceLine" id="cb347-4" data-line-number="4">fmap (<span class="fu">+</span>) [<span class="dv">1</span>,<span class="dv">2</span>,<span class="dv">3</span>,<span class="dv">4</span>,<span class="dv">5</span>,<span class="dv">6</span>]<span class="ot"> ::</span> <span class="dt">Num</span> a <span class="ot">=&gt;</span> [a <span class="ot">-&gt;</span> a]</a></code></pre></div>
<p><code>fmap (+) (Just 3)</code> returns a <code>Num a =&gt; Maybe (a -&gt; a)</code>, a <code>Maybe</code> that contains a function. <code>fmap (+) [1,2,3,4,5,6]</code> returns a List of functions.</p>
<p>But we have an issue. If we have a <code>Just (1+)</code>, it’d be nice to have an easy way to apply that to the inside of a <code>Just 4</code> to get <code>Just 5</code>. That’s where <code>Applicative</code> comes in.</p>
<div class="sourceCode" id="cb348"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb348-1" data-line-number="1"><span class="kw">class</span> (<span class="dt">Functor</span> f) <span class="ot">=&gt;</span> <span class="dt">Applicative</span> f <span class="kw">where</span>  </a>
<a class="sourceLine" id="cb348-2" data-line-number="2"><span class="ot">    pure ::</span> a <span class="ot">-&gt;</span> f a  </a>
<a class="sourceLine" id="cb348-3" data-line-number="3"><span class="ot">    (&lt;*&gt;) ::</span> f (a <span class="ot">-&gt;</span> b) <span class="ot">-&gt;</span> f a <span class="ot">-&gt;</span> f b  </a></code></pre></div>
<p>You can see that for <code>f</code> to be an <code>Applicative</code>, it must first be a <code>Functor</code>. That’s because <code>Applicative</code>s are just functors with extra features. It contains the <code>pure</code> function, which takes a value and wraps it up inside the applicative.</p>
<div class="sourceCode" id="cb349"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb349-1" data-line-number="1"><span class="dt">Prelude</span><span class="fu">&gt;</span> pure <span class="dv">4</span><span class="ot"> ::</span> <span class="dt">Maybe</span> <span class="dt">Int</span></a>
<a class="sourceLine" id="cb349-2" data-line-number="2"><span class="dt">Just</span> <span class="dv">4</span></a>
<a class="sourceLine" id="cb349-3" data-line-number="3"><span class="dt">Prelude</span><span class="fu">&gt;</span> pure <span class="dv">4</span><span class="ot"> ::</span> [<span class="dt">Int</span>]</a>
<a class="sourceLine" id="cb349-4" data-line-number="4">[<span class="dv">4</span>]</a></code></pre></div>
<p>The intelligence of Haskell’s type analysis allows it to select the correct <code>pure</code> function to call, based on the types it thinks we want. Here we use <code>::</code> to manually tell Haskell the type we want, just like we sometimes have to do for <code>read</code>. <code>pure</code> takes a value of any type and wraps it up inside an <code>Applicative</code>. If it seems familiar, it should! It’s the same function we used to wrap values up into IO values earlier!</p>
<p>The other function all <code>Applicative</code>s have is <code>&lt;*&gt;</code>. Compare its type to the type of <code>fmap</code>:</p>
<div class="sourceCode" id="cb350"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb350-1" data-line-number="1">fmap<span class="ot">  ::</span>   (a <span class="ot">-&gt;</span> b) <span class="ot">-&gt;</span> f a <span class="ot">-&gt;</span> f b</a>
<a class="sourceLine" id="cb350-2" data-line-number="2"><span class="ot">(&lt;*&gt;) ::</span> f (a <span class="ot">-&gt;</span> b) <span class="ot">-&gt;</span> f a <span class="ot">-&gt;</span> f b</a></code></pre></div>
<p>Can you guess what <code>&lt;*&gt;</code> does? It’s just like <code>fmap</code>, but where <code>fmap</code> wanted a function and a value wrapped up in a functor, <code>&lt;*&gt;</code> wants a function and a value both wrapped up in an applicative. That’s a mouthful, let’s see it in action.</p>
<div class="sourceCode" id="cb351"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb351-1" data-line-number="1"><span class="dt">Prelude</span><span class="fu">&gt;</span> (<span class="fu">+</span><span class="dv">1</span>) <span class="ot">`fmap`</span> (<span class="dt">Just</span> <span class="dv">10</span>)</a>
<a class="sourceLine" id="cb351-2" data-line-number="2"><span class="dt">Just</span> <span class="dv">11</span></a>
<a class="sourceLine" id="cb351-3" data-line-number="3"><span class="dt">Prelude</span><span class="fu">&gt;</span> (<span class="dt">Just</span> (<span class="fu">+</span><span class="dv">1</span>))  <span class="fu">&lt;*&gt;</span>  (<span class="dt">Just</span> <span class="dv">10</span>)</a>
<a class="sourceLine" id="cb351-4" data-line-number="4"><span class="dt">Just</span> <span class="dv">11</span></a></code></pre></div>
<p>You could even chain it up even more.</p>
<div class="sourceCode" id="cb352"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb352-1" data-line-number="1"><span class="dt">Prelude</span><span class="fu">&gt;</span> (<span class="dt">Just</span> (<span class="fu">+</span>)) <span class="fu">&lt;*&gt;</span> (<span class="dt">Just</span> <span class="dv">1</span>) <span class="fu">&lt;*&gt;</span> (<span class="dt">Just</span> <span class="dv">10</span>)</a>
<a class="sourceLine" id="cb352-2" data-line-number="2"><span class="dt">Just</span> <span class="dv">11</span></a>
<a class="sourceLine" id="cb352-3" data-line-number="3"><span class="dt">Prelude</span><span class="fu">&gt;</span> <span class="dt">Nothing</span> <span class="fu">&lt;*&gt;</span> (<span class="dt">Just</span> (<span class="fu">+</span>))</a>
<a class="sourceLine" id="cb352-4" data-line-number="4"><span class="dt">Nothing</span></a></code></pre></div>
<p>Here’s how <code>Maybe</code> is made to be an instance of <code>Applicative</code></p>
<div class="sourceCode" id="cb353"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb353-1" data-line-number="1"><span class="kw">instance</span> <span class="dt">Applicative</span> <span class="dt">Maybe</span> <span class="kw">where</span>  </a>
<a class="sourceLine" id="cb353-2" data-line-number="2">    pure <span class="fu">=</span> <span class="dt">Just</span>  </a>
<a class="sourceLine" id="cb353-3" data-line-number="3">    <span class="dt">Nothing</span> <span class="fu">&lt;*&gt;</span> _ <span class="fu">=</span> <span class="dt">Nothing</span>  </a>
<a class="sourceLine" id="cb353-4" data-line-number="4">    (<span class="dt">Just</span> f) <span class="fu">&lt;*&gt;</span> x <span class="fu">=</span> fmap f x </a></code></pre></div>
<p>Unfortunately, we’re unable to mix and match <code>Applicative</code>s like we might wish we could.</p>
<div class="sourceCode" id="cb354"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb354-1" data-line-number="1"><span class="dt">Prelude</span><span class="fu">&gt;</span> (<span class="dt">Just</span> (<span class="fu">+</span>)) <span class="fu">&lt;*&gt;</span> [<span class="dv">1</span>,<span class="dv">2</span>,<span class="dv">3</span>,<span class="dv">4</span>]</a>
<a class="sourceLine" id="cb354-2" data-line-number="2"><span class="co">-- error!</span></a></code></pre></div>
<p>But since both sides have to be the same type of <code>Applicative</code>, this means Haskell can figure out what types we want from just one argument.</p>
<div class="sourceCode" id="cb355"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb355-1" data-line-number="1"><span class="dt">Prelude</span><span class="fu">&gt;</span> (<span class="dt">Just</span> (<span class="fu">+</span><span class="dv">5</span>)) <span class="fu">&lt;*&gt;</span> (pure <span class="dv">5</span>)</a>
<a class="sourceLine" id="cb355-2" data-line-number="2"><span class="dt">Just</span> <span class="dv">10</span></a></code></pre></div>
<p>And it can also be chained, like this<label for="marginnote-116" class="margin-toggle">⊕</label> <input type="checkbox" id="marginnote-116" class="margin-toggle"/> <span class="marginnote">Recall the <code>take</code> function, for which <code>take 3 [1..]</code> evaluates to <code>[1,2,3]</code>. It take a list and truncates it.</span>!</p>
<div class="sourceCode" id="cb356"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb356-1" data-line-number="1"><span class="dt">Prelude</span><span class="fu">&gt;</span> (<span class="dt">Just</span> take) <span class="fu">&lt;*&gt;</span> (<span class="dt">Just</span> <span class="dv">3</span>) <span class="fu">&lt;*&gt;</span> (<span class="dt">Just</span> [<span class="dv">1</span>,<span class="dv">2</span>,<span class="dv">3</span>,<span class="dv">4</span>])</a>
<a class="sourceLine" id="cb356-2" data-line-number="2"><span class="dt">Just</span> [<span class="dv">1</span>,<span class="dv">2</span>,<span class="dv">3</span>]</a></code></pre></div>
<p>There’s also <code>&lt;$&gt;</code>, equivalent to <code>fmap</code> but an operator, which allows us to use it in infix notation.</p>
<div class="sourceCode" id="cb357"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb357-1" data-line-number="1"><span class="dt">Prelude</span><span class="fu">&gt;</span> fmap (<span class="fu">+</span><span class="dv">1</span>) [<span class="dv">1</span>,<span class="dv">2</span>,<span class="dv">3</span>]</a>
<a class="sourceLine" id="cb357-2" data-line-number="2">[<span class="dv">2</span>,<span class="dv">3</span>,<span class="dv">4</span>]</a>
<a class="sourceLine" id="cb357-3" data-line-number="3"><span class="dt">Prelude</span><span class="fu">&gt;</span> (<span class="fu">+</span><span class="dv">1</span>) <span class="fu">&lt;$&gt;</span> [<span class="dv">1</span>,<span class="dv">2</span>,<span class="dv">3</span>]</a>
<a class="sourceLine" id="cb357-4" data-line-number="4">[<span class="dv">2</span>,<span class="dv">3</span>,<span class="dv">4</span>]</a></code></pre></div>
<p>It’s really useful because it combines well with <code>&lt;*&gt;</code>.</p>
<div class="sourceCode" id="cb358"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb358-1" data-line-number="1"><span class="dt">Prelude</span><span class="fu">&gt;</span> (<span class="fu">++</span>) <span class="st">&quot;Haskell&quot;</span> <span class="st">&quot;!&quot;</span></a>
<a class="sourceLine" id="cb358-2" data-line-number="2"><span class="st">&quot;Haskell!&quot;</span></a>
<a class="sourceLine" id="cb358-3" data-line-number="3"><span class="dt">Prelude</span><span class="fu">&gt;</span> (<span class="fu">++</span>) <span class="fu">&lt;$&gt;</span> <span class="dt">Just</span> <span class="st">&quot;Haskell&quot;</span> <span class="fu">&lt;*&gt;</span> (pure <span class="st">&quot;!&quot;</span>)</a>
<a class="sourceLine" id="cb358-4" data-line-number="4"><span class="dt">Just</span> <span class="st">&quot;Haskell!&quot;</span></a>
<a class="sourceLine" id="cb358-5" data-line-number="5"></a>
<a class="sourceLine" id="cb358-6" data-line-number="6"><span class="dt">Prelude</span><span class="fu">&gt;</span> take <span class="dv">5</span> [<span class="dv">1</span>,<span class="dv">2</span>,<span class="dv">3</span>,<span class="dv">4</span>,<span class="dv">5</span>,<span class="dv">6</span>,<span class="dv">7</span>,<span class="dv">8</span>,<span class="dv">9</span>,<span class="dv">10</span>]</a>
<a class="sourceLine" id="cb358-7" data-line-number="7">[<span class="dv">1</span>,<span class="dv">2</span>,<span class="dv">3</span>,<span class="dv">4</span>,<span class="dv">5</span>]</a>
<a class="sourceLine" id="cb358-8" data-line-number="8"><span class="dt">Prelude</span><span class="fu">&gt;</span> take <span class="fu">&lt;$&gt;</span> <span class="dt">Just</span> <span class="dv">5</span> <span class="fu">&lt;*&gt;</span> <span class="dt">Just</span> [<span class="dv">1</span>,<span class="dv">2</span>,<span class="dv">3</span>,<span class="dv">4</span>,<span class="dv">5</span>,<span class="dv">6</span>,<span class="dv">7</span>,<span class="dv">8</span>,<span class="dv">9</span>,<span class="dv">10</span>]</a>
<a class="sourceLine" id="cb358-9" data-line-number="9"><span class="dt">Just</span> [<span class="dv">1</span>,<span class="dv">2</span>,<span class="dv">3</span>,<span class="dv">4</span>,<span class="dv">5</span>]</a></code></pre></div>
<p>Notice how we use <code>&lt;$&gt;</code> first, to apply <code>fmap</code> from <code>(++)</code> to <code>Just &quot;Haskell&quot;</code> to get <code>Just (&quot;Haskell&quot;++)</code>. We then use <code>&lt;*&gt;</code> on <code>Just &quot;!&quot;</code> to apply <code>(&quot;Haskell&quot;++)</code> to <code>&quot;!&quot;</code>. So if you want to use a normal function on values wrapped up in <code>Applicative</code>s (also called <em>applicative functors</em>), you can just use <code>&lt;$&gt;</code> and <code>&lt;*&gt;</code> as required. Don’t worry if this seems confusing, try looking at the second example (with <code>take</code>) and try and work through it.</p>
<hr />
<p><strong><strong><em>Exercises</em></strong></strong>:</p>
<ol type="1">
<li><p>Rewrite</p>
<div class="sourceCode" id="cb359"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb359-1" data-line-number="1">take <span class="fu">&lt;$&gt;</span> <span class="dt">Just</span> <span class="dv">5</span> <span class="fu">&lt;*&gt;</span> <span class="dt">Just</span> [<span class="dv">1</span>,<span class="dv">2</span>,<span class="dv">3</span>,<span class="dv">4</span>,<span class="dv">5</span>,<span class="dv">6</span>,<span class="dv">7</span>,<span class="dv">8</span>,<span class="dv">9</span>,<span class="dv">10</span>]<span class="ot">`</span></a></code></pre></div>
<p>so it uses <code>fmap</code> instead of <code>&lt;$&gt;</code></p></li>
<li><p>Use <code>&lt;$&gt;</code> and <code>&lt;*&gt;</code> to apply <code>rem</code> to <code>Just 16</code> and <code>Just 4</code>. The result should be <code>Just 0</code>.</p></li>
</ol>
<hr />
<p><span class="newthought">To see</span> how applicatives work on lists, let’s use <code>&lt;*&gt;</code> and <code>&lt;$&gt;</code> to generate some usernames.</p>
<div class="sourceCode" id="cb360"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb360-1" data-line-number="1"><span class="dt">Prelude</span><span class="fu">&gt;</span> superlatives <span class="fu">=</span> [<span class="st">&quot;Smelliest&quot;</span>, <span class="st">&quot;Steamiest&quot;</span>, <span class="st">&quot;Spiciest&quot;</span>]</a>
<a class="sourceLine" id="cb360-2" data-line-number="2"><span class="dt">Prelude</span><span class="fu">&gt;</span> nouns <span class="fu">=</span> [<span class="st">&quot;Malt&quot;</span>, <span class="st">&quot;Mold&quot;</span>, <span class="st">&quot;Meat&quot;</span>]</a>
<a class="sourceLine" id="cb360-3" data-line-number="3"><span class="dt">Prelude</span><span class="fu">&gt;</span> (<span class="fu">++</span>) <span class="fu">&lt;$&gt;</span> superlatives <span class="fu">&lt;*&gt;</span> nouns</a>
<a class="sourceLine" id="cb360-4" data-line-number="4">[<span class="st">&quot;SmelliestMalt&quot;</span>,<span class="st">&quot;SmelliestMold&quot;</span>,<span class="st">&quot;SmelliestMeat&quot;</span>,<span class="st">&quot;SteamiestMalt&quot;</span>,<span class="st">&quot;SteamiestMold&quot;</span>,<span class="st">&quot;SteamiestMeat&quot;</span>,<span class="st">&quot;SpiciestMalt&quot;</span>,<span class="st">&quot;SpiciestMold&quot;</span>,<span class="st">&quot;SpiciestMeat&quot;</span>]</a></code></pre></div>
<p>What’s happened here is <code>&lt;*&gt;</code> has applied every function in the List in the left-hand argument to every value in the List of the right-hand argument. We make these functions from <code>(++) &lt;$&gt; superlatives</code>, which turns all our superlatives into functions that prepend that superlative to another string. The result: A List of usernames that you’re free to use next time you need to create an account for something.</p>
<p><span class="newthought">Now, you</span> might be wondering what this all has to do with monoids? Remember at the beginning of the section I said that applicatives were monoidal functors. Well, first, notice this similarity:</p>
<div class="sourceCode" id="cb361"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb361-1" data-line-number="1"><span class="ot">($)   ::</span>   (a <span class="ot">-&gt;</span> b) <span class="ot">-&gt;</span>   a <span class="ot">-&gt;</span>   b</a>
<a class="sourceLine" id="cb361-2" data-line-number="2"><span class="ot">(&lt;$&gt;) ::</span>   (a <span class="ot">-&gt;</span> b) <span class="ot">-&gt;</span> f a <span class="ot">-&gt;</span> f b</a>
<a class="sourceLine" id="cb361-3" data-line-number="3"><span class="ot">(&lt;*&gt;) ::</span> f (a <span class="ot">-&gt;</span> b) <span class="ot">-&gt;</span> f a <span class="ot">-&gt;</span> f b</a></code></pre></div>
<p>Remember, <code>$</code> is function application. So <code>f $ x</code> is equivalent to <code>f x</code>. It takes a function and a value and applies that function to that value.</p>
<p><code>&lt;$&gt;</code> is <code>fmap</code>. To use <code>Maybe</code> as an example, <code>f &lt;$&gt; (Just x)</code> is the same as <code>Just (f x)</code>. It take s a function and a functor, and applies that function to the contents of the functor,</p>
<p><code>&lt;*&gt;</code> is <code>fmap</code>, only it works on applicatives and the function you pass it is also wrapped up. So <code>(Just f) &lt;*&gt; (Just x)</code> is equivalent to <code>Just (f x)</code>.</p>
<p>So, what exactly does <code>Applicative</code> have to do with <code>Monoid</code>? The technical term is it’s a <em>monoidal functor</em>. The trick is, you see those <code>f</code>s that wrap up the values in <code>&lt;*&gt;</code>?</p>
<div class="sourceCode" id="cb362"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb362-1" data-line-number="1"><span class="ot">(&lt;*&gt;) ::</span> f (a <span class="ot">-&gt;</span> b) <span class="ot">-&gt;</span> f a <span class="ot">-&gt;</span> f b </a></code></pre></div>
<p>Look at the <code>Maybe</code> type in particular.</p>
<div class="sourceCode" id="cb363"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb363-1" data-line-number="1"><span class="ot">(&lt;*&gt;) ::</span> <span class="dt">Maybe</span> (a <span class="ot">-&gt;</span> b) <span class="ot">-&gt;</span> <span class="dt">Maybe</span> a <span class="ot">-&gt;</span> <span class="dt">Maybe</span> b </a>
<a class="sourceLine" id="cb363-2" data-line-number="2"><span class="co">--       1st argument    2nd argument   output</span></a></code></pre></div>
<p><code>Maybe</code> can be <code>Just &lt;something&gt;</code> or <code>Nothing</code>. If the first argument is <code>Nothing</code>, or the second argument is <code>Nothing</code>, the output is <code>Nothing</code>. That can be thought of as an associative binary function! This is kind of vague for <code>Maybe</code> but for some types like <code>(String, a)</code> it’s much more clear.</p>
<div class="sourceCode" id="cb364"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb364-1" data-line-number="1"><span class="dt">Prelude</span><span class="fu">&gt;</span> (<span class="st">&quot;hello &quot;</span>, (<span class="dv">4</span><span class="fu">+</span>)) <span class="fu">&lt;*&gt;</span> (<span class="st">&quot;world&quot;</span>, <span class="dv">10</span>)</a>
<a class="sourceLine" id="cb364-2" data-line-number="2">(<span class="st">&quot;hello world&quot;</span>,<span class="dv">14</span>)</a></code></pre></div>
<p>What’s going on here is <code>&lt;*&gt;</code> is getting two 2tuples. The first one is of type <code>(String, Int -&gt; Int)</code> and the second one is of type <code>(String, Int)</code>. It combines the two <code>String</code>s using <code>mappend</code><label for="marginnote-117" class="margin-toggle">⊕</label> <input type="checkbox" id="marginnote-117" class="margin-toggle"/> <span class="marginnote"><code>mappend</code> for <code>String</code>s is just <code>++</code>.</span> and it applies the function in the first tuple to the value in the second tuple. This could be used for logging, for example:</p>
<div class="sourceCode" id="cb365"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb365-1" data-line-number="1"><span class="dt">Prelude</span><span class="fu">&gt;</span> (<span class="st">&quot;Multiplying by 10. &quot;</span>, (<span class="dv">10</span><span class="fu">*</span>)) <span class="fu">&lt;*&gt;</span> ((<span class="st">&quot;Adding 4. &quot;</span>, (<span class="dv">4</span><span class="fu">+</span>)) <span class="fu">&lt;*&gt;</span> (<span class="st">&quot;Original value 10. &quot;</span>, <span class="dv">10</span>))</a>
<a class="sourceLine" id="cb365-2" data-line-number="2">(<span class="st">&quot;Multiplying by 10. Adding 4. Original value 10. &quot;</span>,<span class="dv">140</span>)</a></code></pre></div>
<p>The <code>String</code>s are combined with <code>mappend</code>, and the values on the right are mapped. This makes any 2-tuple with a <code>Monoid</code> in the first position an <code>Applicative</code>.</p>
<h2 id="monads">Monads</h2>
<p><span class="newthought"><em>Monads</em> have</span> a reputation of being difficult to learn. James Iry was making a joke when he said “A monad is just a monoid in the category of endofunctors, what’s the problem?”, but he wasn’t totally right<label for="sidenote-61" class="margin-toggle sidenote-number"></label> <input type="checkbox" id="sidenote-61" class="margin-toggle"/> <span class="sidenote">That’d be a better description for an applicative, although you can argue it applies to monads</span>.</p>
<p>Monads are pretty simple. Just like you can imagine functors being applicatives with extra features, you can imagine a monad being an applicative with extra features. Indeed,Everything in the <code>Monad</code> typeclass is also in the <code>Applicative</code> typeclass. Since everything in the <code>Applicative</code> typeclass is also in the <code>Functor</code> typeclass, that means that all monads are applicatives and functors! But they’re far more powerful than either applicatives or functors, which is why you see them everywhere in Haskell, from lists to <code>IO</code> and even to the humble <code>Maybe</code>.</p>
<p>Here’s a reminder for all the terms we’ve introduced in this chapter.</p>
<ol type="1">
<li><p>A functor is something that can be mapped over (using <code>fmap</code> or <code>&lt;$&gt;</code> in Haskell). Examples include Lists and <code>Maybe</code>. <code>fmap</code> takes a function and a functor, and applies the function to the contents of the functor. So <code>fmap (+1) (Just 3)</code> evaluates to <code>Just 4</code>. A functor must</p></li>
<li><p>An applicative is a functor, so it still has <code>fmap</code>, but it also has two additional operations<label for="marginnote-118" class="margin-toggle">⊕</label> <input type="checkbox" id="marginnote-118" class="margin-toggle"/> <span class="marginnote">Most functors are applicatives these days.</span>.</p>
<ol type="1">
<li><p>It has <code>pure</code>, which takes a value and wraps it up in an applicative. So <code>pure 3 :: [Int]</code> evaluates to <code>[3]</code>, and <code>pure 3 :: Maybe Int</code></p></li>
<li><p>It has <code>&lt;*&gt;</code>, which is just like <code>fmap</code> except both the function being passed and the value to apply it to are both wrapped up in applicatives. So <code>Just &lt;*&gt; (Just 3)</code> evaluates to <code>Just 4</code> (Compare that to <code>(+1) &lt;$&gt; (Just 3)</code>, which also evaluates to <code>Just 4</code>).</p></li>
</ol></li>
</ol>
<p>To understand monads, many people find the use of analogies helpful. Monads usually provide <em>context</em> to a value, sometimes called <em>computational context</em>. They’re used like modifiers to other types. For example, you may have a <code>String</code>. If this <code>String</code> represents someone’s licence plate, it might not always exist, such as when that person does not have a car. So you might choose to represent this with a <code>Maybe String</code>, so my licence plate would be <code>Just &quot;ABCD123&quot;</code> and my friends who take the subway would be <code>Nothing</code>. <code>Maybe</code> has given us some context for the <code>String</code>, we’ve said it may not exist. But you may have noticed an issue here - what if someone has multiple cars! That would call for a different context, the context of <em>zero or more</em>. To represent that, we’d use a <code>[String]</code>. These are the monads we’re going to be spending most of our time discussing - <code>Maybe</code> and <code>[]</code>.</p>
<p>That should give you a little bit of an intuition for monads, so it’s time to get specific. To start us off, let’s look at the <code>Monad</code> typeclass definition.</p>
<div class="sourceCode" id="cb366"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb366-1" data-line-number="1"><span class="kw">class</span> <span class="dt">Applicative</span> m <span class="ot">=&gt;</span> <span class="dt">Monad</span> m <span class="kw">where</span></a>
<a class="sourceLine" id="cb366-2" data-line-number="2"><span class="ot">    (&gt;&gt;=) ::</span> m a <span class="ot">-&gt;</span> (a <span class="ot">-&gt;</span> m b) <span class="ot">-&gt;</span> m b</a>
<a class="sourceLine" id="cb366-3" data-line-number="3"><span class="ot">    (&gt;&gt;) ::</span> m a <span class="ot">-&gt;</span> m b <span class="ot">-&gt;</span> m b</a>
<a class="sourceLine" id="cb366-4" data-line-number="4"><span class="ot">    return ::</span> a <span class="ot">-&gt;</span> m a</a></code></pre></div>
<p>These functions should look pretty familiar. <code>return</code> is just <code>pure</code>, which you should recognize from <code>Applicative</code>s<label for="marginnote-119" class="margin-toggle">⊕</label> <input type="checkbox" id="marginnote-119" class="margin-toggle"/> <span class="marginnote"><code>return</code> is a relic of the time Haskell developers didn’t know about applicatives, it only still exists for backwards compatibility reasons. <code>pure</code> will work with any <code>Applicative</code> while <code>return</code> will only work with <code>Monad</code>s, so <code>pure</code> is strictly better.</span>. It takes a value and wraps it up in an <code>Applicative</code> (or in this case, not just any <code>Applicative</code>, but a <code>Monad</code>).</p>
<p>The other function monads provide us is <code>&gt;&gt;=</code> the bind operator. There’s also <code>&gt;&gt;</code>, but it’s just a simpler version of <code>&gt;&gt;=</code> so we’ll skip over it for now.</p>
<p>Look at the type signature for <code>&gt;&gt;=</code>:</p>
<div class="sourceCode" id="cb367"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb367-1" data-line-number="1"><span class="ot">(&gt;&gt;=) ::</span> m a <span class="ot">-&gt;</span> (a <span class="ot">-&gt;</span> m b) <span class="ot">-&gt;</span> m b</a></code></pre></div>
<p>It’s actually pretty simple. The goal of <code>&gt;&gt;=</code> is to take a value <code>m a</code>, and a function from <code>a</code> to <code>m b</code>, and apply that function to the value. How would we do that for <code>Maybe</code>? Here’s how!</p>
<div class="sourceCode" id="cb368"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb368-1" data-line-number="1"><span class="dt">Nothing</span> <span class="fu">&gt;&gt;=</span> f <span class="fu">=</span> <span class="dt">Nothing</span>  </a>
<a class="sourceLine" id="cb368-2" data-line-number="2"><span class="dt">Just</span> x <span class="fu">&gt;&gt;=</span> f  <span class="fu">=</span> f x</a></code></pre></div>
<p>Easy as pie! That’s all we need for the <code>Maybe</code> monad. Let’s put this to the test. Do you remember our function <code>maybeHead</code>?</p>
<div class="sourceCode" id="cb369"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb369-1" data-line-number="1"><span class="co">-- maybeHead.hs</span></a>
<a class="sourceLine" id="cb369-2" data-line-number="2"><span class="ot">maybeHead ::</span> [a] <span class="ot">-&gt;</span> <span class="dt">Maybe</span> a</a>
<a class="sourceLine" id="cb369-3" data-line-number="3">maybeHead (x<span class="fu">:</span>xs) <span class="fu">=</span> <span class="dt">Just</span> x</a>
<a class="sourceLine" id="cb369-4" data-line-number="4">maybeHead _ <span class="fu">=</span> <span class="dt">Nothing</span></a></code></pre></div>
<p>Here’s how it works, in case you forgot.</p>
<div class="sourceCode" id="cb370"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb370-1" data-line-number="1"><span class="dt">Prelude</span><span class="fu">&gt;</span> maybeHead [<span class="dv">1</span>,<span class="dv">2</span>,<span class="dv">3</span>]</a>
<a class="sourceLine" id="cb370-2" data-line-number="2"><span class="dt">Just</span> <span class="dv">1</span></a>
<a class="sourceLine" id="cb370-3" data-line-number="3"><span class="dt">Prelude</span><span class="fu">&gt;</span> maybeHead []</a>
<a class="sourceLine" id="cb370-4" data-line-number="4"><span class="dt">Nothing</span></a></code></pre></div>
<p>This takes a <code>[a]</code> and returns a <code>Maybe a</code>. But what if we wanted to pas it a <code>Maybe [a]</code>? We do this with <code>&gt;&gt;=</code><label for="marginnote-120" class="margin-toggle">⊕</label> <input type="checkbox" id="marginnote-120" class="margin-toggle"/> <span class="marginnote">Compare <code>a -&gt; m b</code> to <code>[a] -&gt; Maybe a</code>. <code>maybeHead</code> takes a parameter of a certain type (<code>[a]</code>), and returns a parameter of a different type (<code>a</code>) wrapped in a <code>Maybe</code>.</span>.</p>
<div class="sourceCode" id="cb371"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb371-1" data-line-number="1"><span class="dt">Prelude</span><span class="fu">&gt;</span> xs <span class="fu">=</span> <span class="dt">Just</span> [<span class="dv">1</span>,<span class="dv">2</span>,<span class="dv">3</span>]</a>
<a class="sourceLine" id="cb371-2" data-line-number="2"><span class="dt">Prelude</span><span class="fu">&gt;</span> xs <span class="fu">&gt;&gt;=</span> maybeHead</a>
<a class="sourceLine" id="cb371-3" data-line-number="3"><span class="dt">Just</span> <span class="dv">1</span></a></code></pre></div>
<p><code>&gt;&gt;=</code> unwrapped the <code>[a]</code> out of the <code>Maybe [a]</code> and passed it to <code>maybeHead</code>, which returned <code>Just 1</code>. But if our <code>Maybe [a]</code> was <code>Nothing</code>, this is what would have happened:</p>
<div class="sourceCode" id="cb372"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb372-1" data-line-number="1"><span class="dt">Prelude</span><span class="fu">&gt;</span> xs <span class="fu">=</span> <span class="dt">Nothing</span></a>
<a class="sourceLine" id="cb372-2" data-line-number="2"><span class="dt">Prelude</span><span class="fu">&gt;</span> xs <span class="fu">&gt;&gt;=</span> maybeHead</a>
<a class="sourceLine" id="cb372-3" data-line-number="3"><span class="dt">Nothing</span></a></code></pre></div>
<p>If the left hand of <code>&gt;&gt;=</code> is <code>Nothing</code>, that’s what the output will be. For proof of this, we can try it with <code>undefined</code>, a special value which we can pass to any function but that function isn’t allowed to look at or use:</p>
<div class="sourceCode" id="cb373"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb373-1" data-line-number="1"><span class="dt">Prelude</span><span class="fu">&gt;</span> <span class="dt">Nothing</span> <span class="fu">&gt;&gt;=</span> undefined</a>
<a class="sourceLine" id="cb373-2" data-line-number="2"><span class="dt">Nothing</span></a></code></pre></div>
<p>When you think about it, this is exactly what we want! <code>Maybe</code> means there’s a chance our value doesn’t exist. Once it’s <code>Nothing</code>, we don’t want to do anything with it anymore, we just want everything after it to be <code>Nothing</code>.</p>
<p>How can we use this? Remember our <code>maybeDivide</code> function?</p>
<div class="sourceCode" id="cb374"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb374-1" data-line-number="1"><span class="co">-- maybeDivide.hs</span></a>
<a class="sourceLine" id="cb374-2" data-line-number="2"><span class="ot">maybeDivide ::</span> <span class="dt">Double</span> <span class="ot">-&gt;</span> <span class="dt">Double</span> <span class="ot">-&gt;</span> <span class="dt">Maybe</span> <span class="dt">Double</span> <span class="co">-- Maybe Double is a type. </span></a>
<a class="sourceLine" id="cb374-3" data-line-number="3">                                                <span class="co">-- It&#39;s automatically made from the definition of Maybe a. </span></a>
<a class="sourceLine" id="cb374-4" data-line-number="4">                                                <span class="co">-- It can be Nothing or Just Double.</span></a>
<a class="sourceLine" id="cb374-5" data-line-number="5">maybeDivide _ <span class="dv">0</span> <span class="fu">=</span> <span class="dt">Nothing</span></a>
<a class="sourceLine" id="cb374-6" data-line-number="6">maybeDivide x y <span class="fu">=</span> <span class="dt">Just</span> (x <span class="fu">/</span> y)</a></code></pre></div>
<p>Here’s how it works, in case you’ve forgotten. It divides two numbers, and returns <code>Just &lt;result&gt;</code>. However, if the denominator is <code>0</code>, it will return <code>Nothing</code>.</p>
<div class="sourceCode" id="cb375"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb375-1" data-line-number="1"><span class="dt">Prelude</span><span class="fu">&gt;</span> maybeDivide <span class="dv">2</span> <span class="dv">4</span></a>
<a class="sourceLine" id="cb375-2" data-line-number="2"><span class="dt">Just</span> <span class="fl">0.5</span></a>
<a class="sourceLine" id="cb375-3" data-line-number="3"><span class="dt">Prelude</span><span class="fu">&gt;</span> maybeDivide <span class="dv">2</span> <span class="dv">0</span></a>
<a class="sourceLine" id="cb375-4" data-line-number="4"><span class="dt">Nothing</span></a></code></pre></div>
<p>Can we use this with <code>&gt;&gt;=</code>? Let’s see!</p>
<div class="sourceCode" id="cb376"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb376-1" data-line-number="1"><span class="dt">Prelude</span><span class="fu">&gt;</span> xs <span class="fu">=</span> <span class="dt">Just</span> [<span class="dv">2</span>,<span class="dv">3</span>,<span class="dv">4</span>]</a>
<a class="sourceLine" id="cb376-2" data-line-number="2"><span class="dt">Prelude</span><span class="fu">&gt;</span> xs <span class="fu">&gt;&gt;=</span> maybeHead <span class="fu">&gt;&gt;=</span> (maybeDivide <span class="dv">3</span>)</a>
<a class="sourceLine" id="cb376-3" data-line-number="3"><span class="dt">Just</span> <span class="fl">1.5</span></a></code></pre></div>
<p>This won’t crash, even if you have things that would normally cause issues, such as empty lists or division by <code>0</code>!</p>
<div class="sourceCode" id="cb377"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb377-1" data-line-number="1"><span class="dt">Prelude</span><span class="fu">&gt;</span> <span class="dt">Nothing</span> <span class="fu">&gt;&gt;=</span> maybeHead <span class="fu">&gt;&gt;=</span> (maybeDivide <span class="dv">3</span>)</a>
<a class="sourceLine" id="cb377-2" data-line-number="2"><span class="dt">Nothing</span></a>
<a class="sourceLine" id="cb377-3" data-line-number="3"><span class="dt">Prelude</span><span class="fu">&gt;</span> (<span class="dt">Just</span> []) <span class="fu">&gt;&gt;=</span> maybeHead <span class="fu">&gt;&gt;=</span> (maybeDivide <span class="dv">3</span>)</a>
<a class="sourceLine" id="cb377-4" data-line-number="4"><span class="dt">Nothing</span></a>
<a class="sourceLine" id="cb377-5" data-line-number="5"><span class="dt">Prelude</span><span class="fu">&gt;</span> (<span class="dt">Just</span> [<span class="dv">0</span>]) <span class="fu">&gt;&gt;=</span> maybeHead <span class="fu">&gt;&gt;=</span> (maybeDivide <span class="dv">3</span>)</a>
<a class="sourceLine" id="cb377-6" data-line-number="6"><span class="dt">Nothing</span></a></code></pre></div>
<p>If one of these functions outputs <code>Nothing</code> at any stage, the output will be <code>Nothing</code>. This is quite an elegant way to handle errors because we only have to check once, at the end. You can see how <code>&gt;&gt;=</code> makes working with <code>Maybe</code> much more convenient.</p>
<p>Let’s try some silly examples using lambdas<label for="marginnote-121" class="margin-toggle">⊕</label> <input type="checkbox" id="marginnote-121" class="margin-toggle"/> <span class="marginnote">A lambda is a function you can write in an expression, without giving it a name. Their format is <code>\parameter1 parameter2 -&gt; &lt;expression&gt;</code>. They’re very useful when working with functions like <code>&gt;&gt;=</code>, which expects a function of type <code>a -&gt; m b</code> for its right-hand argument.</span>.</p>
<div class="sourceCode" id="cb378"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb378-1" data-line-number="1"><span class="dt">Prelude</span><span class="fu">&gt;</span> (<span class="dt">Just</span> <span class="dv">0</span>) <span class="fu">&gt;&gt;=</span> (\x <span class="ot">-&gt;</span> <span class="dt">Just</span> (x <span class="fu">+</span> <span class="dv">1</span>)) <span class="fu">&gt;&gt;=</span> (\x <span class="ot">-&gt;</span> <span class="dt">Just</span> (x <span class="fu">*</span> <span class="dv">3</span>)) <span class="fu">&gt;&gt;=</span> (\x <span class="ot">-&gt;</span> <span class="dt">Just</span> (show x)) <span class="fu">&gt;&gt;=</span> (\x <span class="ot">-&gt;</span> <span class="dt">Just</span> (<span class="st">&quot;And the answer is &quot;</span> <span class="fu">++</span> x))</a>
<a class="sourceLine" id="cb378-2" data-line-number="2"><span class="dt">Just</span> <span class="st">&quot;And the answer is 3&quot;</span></a></code></pre></div>
<p>Each of these lambdas we’ve made takes a plain value and returns a <code>Maybe</code> value. <code>&gt;&gt;=</code> does all the work of extracting the value out of the <code>Maybe a</code> and passing it to our lambda. Here’s how we might do it if we were writing a program. Remember though that this example is silly, and is only to show off the fact that <code>&gt;&gt;=</code> is unwrapping our values for us.</p>
<div class="sourceCode" id="cb379"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb379-1" data-line-number="1"><span class="co">-- sillyMaybeBindTest.hs</span></a>
<a class="sourceLine" id="cb379-2" data-line-number="2">result <span class="fu">=</span> </a>
<a class="sourceLine" id="cb379-3" data-line-number="3">    <span class="dt">Just</span> <span class="dv">0</span>        <span class="fu">&gt;&gt;=</span> \x <span class="ot">-&gt;</span></a>
<a class="sourceLine" id="cb379-4" data-line-number="4">    <span class="dt">Just</span> (x <span class="fu">+</span> <span class="dv">1</span>)  <span class="fu">&gt;&gt;=</span> \x <span class="ot">-&gt;</span></a>
<a class="sourceLine" id="cb379-5" data-line-number="5">    <span class="dt">Just</span> (x <span class="fu">*</span> <span class="dv">3</span>)  <span class="fu">&gt;&gt;=</span> \x <span class="ot">-&gt;</span></a>
<a class="sourceLine" id="cb379-6" data-line-number="6">    <span class="dt">Just</span> (show x) <span class="fu">&gt;&gt;=</span> \x <span class="ot">-&gt;</span></a>
<a class="sourceLine" id="cb379-7" data-line-number="7">    <span class="dt">Just</span> (<span class="st">&quot;And the answer is &quot;</span> <span class="fu">++</span> x)</a></code></pre></div>
<p>If we really wanted to do all this though, we should do it with something called <code>do</code> expressions. All <code>do</code> notation does is take away the hard work of typing out all our lambdas by hand.</p>
<div class="sourceCode" id="cb380"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb380-1" data-line-number="1"><span class="co">-- sillyMaybeDoTest.hs</span></a>
<a class="sourceLine" id="cb380-2" data-line-number="2">result <span class="fu">=</span> <span class="kw">do</span> </a>
<a class="sourceLine" id="cb380-3" data-line-number="3">    x <span class="ot">&lt;-</span> <span class="dt">Just</span> <span class="dv">0</span></a>
<a class="sourceLine" id="cb380-4" data-line-number="4">    x <span class="ot">&lt;-</span> <span class="dt">Just</span> (x <span class="fu">+</span> <span class="dv">1</span>)</a>
<a class="sourceLine" id="cb380-5" data-line-number="5">    x <span class="ot">&lt;-</span> <span class="dt">Just</span> (x <span class="fu">*</span> <span class="dv">3</span>)</a>
<a class="sourceLine" id="cb380-6" data-line-number="6">    x <span class="ot">&lt;-</span> <span class="dt">Just</span> (show x)</a>
<a class="sourceLine" id="cb380-7" data-line-number="7">    <span class="dt">Just</span> (<span class="st">&quot;And the answer is &quot;</span> <span class="fu">++</span> x)</a></code></pre></div>
<p>Notice that we don’t use an <code>x &lt;-</code> for the last line<label for="marginnote-122" class="margin-toggle">⊕</label> <input type="checkbox" id="marginnote-122" class="margin-toggle"/> <span class="marginnote">You may notice that this looks like something you might expect from imperative programming languages. It’s this similarity that’s caused some to say “Haskell is the world’s finest imperative programming language” (That, in addition to Haskell’s impressive ability to abstract over imperative ideas, such as <code>while</code> and <code>for</code> loops). That said, it’s generally best to use an imperative programming language if you intend to mostly be using the imperative programming style.</span>. That’s because, like <code>&gt;&gt;=</code>, the result of <code>do</code> is the result of the last line. It doesn’t make sense to give a name to the output of the last line. You don’t need to have an <code>x &lt;-</code> for any of the lines, although you won’t be able to reference previous values if you don’t.</p>
<p>If we wanted to, we could use <code>pure</code> instead of <code>Just</code>. As long as we use <code>Just</code> at least once, Haskell will know we want the output of our <code>do</code> expression to be a <code>Maybe</code> value, so it will call the version of <code>pure</code> that returns a <code>Maybe</code>.</p>
<div class="sourceCode" id="cb381"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb381-1" data-line-number="1"><span class="co">-- sillyMaybeDoTestPure.hs</span></a>
<a class="sourceLine" id="cb381-2" data-line-number="2">result <span class="fu">=</span> <span class="kw">do</span> </a>
<a class="sourceLine" id="cb381-3" data-line-number="3">    x <span class="ot">&lt;-</span> pure <span class="dv">0</span></a>
<a class="sourceLine" id="cb381-4" data-line-number="4">    x <span class="ot">&lt;-</span> pure (x <span class="fu">+</span> <span class="dv">1</span>)</a>
<a class="sourceLine" id="cb381-5" data-line-number="5">    x <span class="ot">&lt;-</span> pure (x <span class="fu">*</span> <span class="dv">3</span>)</a>
<a class="sourceLine" id="cb381-6" data-line-number="6">    x <span class="ot">&lt;-</span> pure (show x)</a>
<a class="sourceLine" id="cb381-7" data-line-number="7">    <span class="dt">Just</span> (<span class="st">&quot;And the answer is &quot;</span> <span class="fu">++</span> x)</a></code></pre></div>
<p>Of course, the result of all these is the same:</p>
<div class="sourceCode" id="cb382"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb382-1" data-line-number="1"><span class="fu">*</span><span class="dt">Main</span><span class="fu">&gt;</span> result</a>
<a class="sourceLine" id="cb382-2" data-line-number="2"><span class="dt">Just</span> <span class="st">&quot;And the answer is 3&quot;</span></a></code></pre></div>
<p>By the way, reusing previous names in <code>do</code> expressions is called <em>shadowing</em> and it is generally considered bad practice. If you can’t think of good names, something like this is always an option<label for="marginnote-123" class="margin-toggle">⊕</label> <input type="checkbox" id="marginnote-123" class="margin-toggle"/> <span class="marginnote">My preferred way to type subscripts like <code>₁</code> is to use the Latex Input extension in VSCode, which allows me to simply type <code>\_1</code></span>:</p>
<div class="sourceCode" id="cb383"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb383-1" data-line-number="1"><span class="co">-- sillyMaybeDoTestSub.hs</span></a>
<a class="sourceLine" id="cb383-2" data-line-number="2">result <span class="fu">=</span> <span class="kw">do</span> </a>
<a class="sourceLine" id="cb383-3" data-line-number="3">    x₁ <span class="ot">&lt;-</span> <span class="dt">Just</span> <span class="dv">0</span></a>
<a class="sourceLine" id="cb383-4" data-line-number="4">    x₂ <span class="ot">&lt;-</span> <span class="dt">Just</span> (x₁ <span class="fu">+</span> <span class="dv">1</span>)</a>
<a class="sourceLine" id="cb383-5" data-line-number="5">    x₃ <span class="ot">&lt;-</span> <span class="dt">Just</span> (x₂ <span class="fu">*</span> <span class="dv">3</span>)</a>
<a class="sourceLine" id="cb383-6" data-line-number="6">    x₄ <span class="ot">&lt;-</span> <span class="dt">Just</span> (show x₃)</a>
<a class="sourceLine" id="cb383-7" data-line-number="7">    <span class="dt">Just</span> (<span class="st">&quot;And the answer is &quot;</span> <span class="fu">++</span> x₄)</a></code></pre></div>
<p>Note that if <em>any</em> of these evaluate to <code>Nothing</code>, the whole thing will evaluate to <code>Nothing</code>.</p>
<div class="sourceCode" id="cb384"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb384-1" data-line-number="1"><span class="co">-- sillyMaybeDoTestNothing.hs</span></a>
<a class="sourceLine" id="cb384-2" data-line-number="2">result <span class="fu">=</span> <span class="kw">do</span> </a>
<a class="sourceLine" id="cb384-3" data-line-number="3">    x₁ <span class="ot">&lt;-</span> pure <span class="dv">0</span></a>
<a class="sourceLine" id="cb384-4" data-line-number="4">    x₂ <span class="ot">&lt;-</span> pure (x₁ <span class="fu">+</span> <span class="dv">1</span>)</a>
<a class="sourceLine" id="cb384-5" data-line-number="5">    x₃ <span class="ot">&lt;-</span> pure (x₂ <span class="fu">*</span> <span class="dv">3</span>)</a>
<a class="sourceLine" id="cb384-6" data-line-number="6">    x₄ <span class="ot">&lt;-</span> pure (show x₃)</a>
<a class="sourceLine" id="cb384-7" data-line-number="7">    y₁ <span class="ot">&lt;-</span> <span class="dt">Nothing</span>         <span class="co">-- This will cause the whole result function to evaluate to Nothing.</span></a>
<a class="sourceLine" id="cb384-8" data-line-number="8">    <span class="dt">Just</span> (<span class="st">&quot;And the answer is &quot;</span> <span class="fu">++</span> x₄)</a></code></pre></div>
<div class="sourceCode" id="cb385"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb385-1" data-line-number="1"><span class="fu">*</span><span class="dt">Main</span><span class="fu">&gt;</span> result</a>
<a class="sourceLine" id="cb385-2" data-line-number="2"><span class="dt">Nothing</span></a></code></pre></div>
<p>You may think this is strange, since <code>y &lt;- Nothing</code> seems like it shouldn’t influence the result at all. But consider what would happen if you then tried to use <code>y</code>. When you write <code>x &lt;- Just 3</code>, <code>x</code> becomes <code>3</code> (Not <code>Just 3</code>). What would <code>y</code> be?</p>
<h2 id="monad-laws">Monad Laws</h2>
<p><span class="newthought">Like functors</span> and monoids, monads have laws that your <code>Monad</code> instances should obey.</p>
<p>The first law is that <code>pure x &gt;&gt;= f</code> should be equivalent to <code>f x</code>. Remember, <code>pure</code> just wraps a value up in some other type, like <code>Maybe</code>. Then <code>&gt;&gt;=</code> unwraps it and passes it to <code>f</code>. Together, they undo each other.</p>
<p>The second law is that <code>m &gt;&gt;= pure</code> should be equivalent to <code>m</code>. This is because <code>&gt;&gt;=</code> is responsible for unwrapping <code>m</code> and passing it to the function on the right (in this case <code>pure</code>). Then <code>pure</code> wraps it right back up. This means they should undo each other the other way, too.</p>
<p>The third law is that <code>(m &gt;&gt;= f) &gt;&gt;= g</code> should be equivalent to <code>m &gt;&gt;= (\x -&gt; f x &gt;&gt;= g)</code>. What it’s basically saying is that monads should be associative - the parentheses shouldn’t really matter<label for="marginnote-124" class="margin-toggle">⊕</label> <input type="checkbox" id="marginnote-124" class="margin-toggle"/> <span class="marginnote">This might remind you of monoids, and that’s because monads and monoids are closely related in category theory. If you’re interested in how exactly, I recommend reading <a href="https://bartoszmilewski.com/2014/10/28/category-theory-for-programmers-the-preface/">Category Theory for Programmers</a>.</span>.</p>
<h1 id="more-monads">More Monads</h1>
<h2 id="the-list-monad">The List Monad</h2>
<p><span class="newthought">In the</span> last chapter, we discussed the <code>Maybe</code> monad. But there are other monads as well, such as <code>[]</code>. Here’s its definition:</p>
<div class="sourceCode" id="cb386"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb386-1" data-line-number="1"><span class="kw">instance</span> <span class="dt">Monad</span> [] <span class="kw">where</span>  </a>
<a class="sourceLine" id="cb386-2" data-line-number="2">    xs <span class="fu">&gt;&gt;=</span> f <span class="fu">=</span> concat (fmap f xs)  </a></code></pre></div>
<p>So, you pass <code>&gt;&gt;=</code> a list <code>[a]</code> and a function <code>a -&gt; [b]</code>. It applies the function to every item in the list (creating a list of lists), then concatenates all the lists together. Here’s a demonstration:</p>
<div class="sourceCode" id="cb387"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb387-1" data-line-number="1"><span class="fu">*</span><span class="dt">Main</span><span class="fu">&gt;</span> [<span class="dv">1</span>,<span class="dv">2</span>,<span class="dv">3</span>] <span class="fu">&gt;&gt;=</span> \x <span class="ot">-&gt;</span> [x, x<span class="fu">*</span><span class="dv">1000</span>]</a>
<a class="sourceLine" id="cb387-2" data-line-number="2">[<span class="dv">1</span>,<span class="dv">1000</span>,<span class="dv">2</span>,<span class="dv">2000</span>,<span class="dv">3</span>,<span class="dv">3000</span>]</a></code></pre></div>
<p>The <code>1</code> in <code>[1,2,3]</code> is turned into <code>[1, 1000]</code>. The <code>2</code> is turned into <code>[2, 2000]</code> and the <code>3</code> is turned into <code>[3,3000]</code>. All these lists are concatenated together to get <code>[1,1000,2,2000,3,3000]</code>.</p>
<p>A natural way to think about this is functions that can return multiple values. Imagine a <code>sqrt</code> function. As you might be aware, <code>sqrt</code> has two values that would make sense to return - a positive and a negative. There’s a function in Haskell called <code>sqrt</code> that squares a number and returns the positive, let’s make <code>sqrt'</code> which does it right.</p>
<div class="sourceCode" id="cb388"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb388-1" data-line-number="1">sqrt&#39; x <span class="fu">=</span> <span class="kw">let</span> root <span class="fu">=</span> sqrt x </a>
<a class="sourceLine" id="cb388-2" data-line-number="2">          <span class="kw">in</span> [root, <span class="fu">-</span>root]</a></code></pre></div>
<p>Now, let’s test it out!</p>
<div class="sourceCode" id="cb389"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb389-1" data-line-number="1"><span class="dt">Prelude</span><span class="fu">&gt;</span> sqrt&#39; <span class="dv">4</span></a>
<a class="sourceLine" id="cb389-2" data-line-number="2">[<span class="fl">2.0</span>,<span class="fu">-</span><span class="fl">2.0</span>]</a></code></pre></div>
<p>Now, imagine we wanted to find every 4th root. We can just apply <code>sqrt'</code> twice!</p>
<div class="sourceCode" id="cb390"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb390-1" data-line-number="1"><span class="dt">Prelude</span> <span class="dt">Data.Complex</span><span class="fu">&gt;</span> sqrt&#39; <span class="dv">4</span> <span class="fu">&gt;&gt;=</span> sqrt&#39;</a>
<a class="sourceLine" id="cb390-2" data-line-number="2">[<span class="fl">1.4142135623730951</span>,<span class="fu">-</span><span class="fl">1.4142135623730951</span>,<span class="dt">NaN</span>,<span class="dt">NaN</span>]</a></code></pre></div>
<p>Well… that’s disappointing. When you run <code>sqrt</code> on a negative number, it returns <code>NaN</code><label for="marginnote-125" class="margin-toggle">⊕</label> <input type="checkbox" id="marginnote-125" class="margin-toggle"/> <span class="marginnote">If you run <code>sqrt</code> on a complex number it will return the correct result, not <code>Nan</code> (complex numbers are available in <code>Data.Complex</code> and made using the <code>:+</code> operator).</span>.</p>
<p>Anyway, I hope this communicates what the list monad is doing. Monads aren’t anything super complicated or hard - they’re just an additional context for a different value.</p>
<h1 id="important-information-for-using-haskell">Important Information For Using Haskell</h1>
<p><span class="newthought">This chapter</span> will tell you the last few things you still need to know to become a genuine Haskell dev. After this, you’ll have the skills you need to start being really productive! A project we’ll be making soon is going to be called <code>irc</code>, so go ahead and run <code>stack new irc</code> somewhere to generate it (notice we don’t use <code>stack new irc simple</code> - we’ll be using some features not in the <code>simple</code> template). We’ll actually be making a little IRC client! If you’re not familiar, IRC is an internet protocol for making online chat rooms. Anyone can host an <em>IRC server</em>, which can have multiple chat rooms inside it called <em>channels</em>.</p>
<h2 id="getting-3rd-party-code-with-stack">Getting 3rd-Party Code With Stack</h2>
<p><span class="newthought">You may</span> remember the tool we used earlier, Stack. Stack isn’t a package manager, it’s responsible for building your code, which occasionally involves downloading packages from the internet. It doesn’t try to manage the packages your program uses, it just builds what are called “targets” (and their dependencies). To build a target, you want to use <code>stack build &lt;target&gt;</code>. You very rarely want to use <code>stack install</code>. <code>stack install</code> is for installing Haskell <em>programs</em> to your computer, it’s totally different from <code>npm install</code> or <code>pip install</code>. You <strong>probably don’t want to use <code>stack install</code></strong> (It almost got removed entirely to eliminate this exact confusion).</p>
<p>To add a dependency, you write its name in the <code>package.yaml</code> file under the <code>dependencies</code> section. Let’s add one called <code>lens</code> (Lens is a library that has many useful things related to getting and setting values). We’ll also add one called <code>hspec</code> and <code>QuickCheck</code> for testing our project, and one called <code>network</code> which we’ll use to communicate to IRC servers.</p>
<p>Go to our <code>irc</code> folder and look at <code>package.yaml</code>. Change the <code>dependencies:</code> line (line 22) from</p>
<div class="sourceCode" id="cb391"><pre class="sourceCode yaml"><code class="sourceCode yaml"><a class="sourceLine" id="cb391-1" data-line-number="1"><span class="fu">dependencies:</span></a>
<a class="sourceLine" id="cb391-2" data-line-number="2"><span class="kw">-</span> base &gt;= 4.7 &amp;&amp; &lt; 5</a></code></pre></div>
<p>To</p>
<div class="sourceCode" id="cb392"><pre class="sourceCode yaml"><code class="sourceCode yaml"><a class="sourceLine" id="cb392-1" data-line-number="1"><span class="fu">dependencies:</span></a>
<a class="sourceLine" id="cb392-2" data-line-number="2"><span class="kw">-</span> base &gt;= 4.7 &amp;&amp; &lt; 5</a>
<a class="sourceLine" id="cb392-3" data-line-number="3"><span class="kw">-</span> hspec</a>
<a class="sourceLine" id="cb392-4" data-line-number="4"><span class="kw">-</span> QuickCheck</a>
<a class="sourceLine" id="cb392-5" data-line-number="5"><span class="kw">-</span> lens</a>
<a class="sourceLine" id="cb392-6" data-line-number="6"><span class="kw">-</span> network</a></code></pre></div>
<p>This change tells <code>stack</code> that our code depends on a library called <code>hspec</code>, a library called <code>lens</code>, and a library called <code>network</code>. <code>base</code> is the basic stuff all Haskell programs use, like numbers (the <code>&gt;=4.7 &amp;&amp; &lt; 5</code> tells cabal which versions of <code>base</code> it can expect our code to work for).</p>
<p>To test it out, run <code>stack ghci</code> while in the <code>irc</code> folder. This will build your project and open a new GHCi instance from which you can import libraries you’ve added to your project.</p>
<p>By default, our program just prints the text <code>somefunc</code>. Let’s test that out by typing <code>main</code> (remember, <code>main</code> is the function run by Haskell when you turn it into an .exe).</p>
<div class="sourceCode" id="cb393"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb393-1" data-line-number="1"><span class="fu">*</span><span class="dt">Main</span> <span class="dt">Lib</span><span class="fu">&gt;</span> main</a>
<a class="sourceLine" id="cb393-2" data-line-number="2">someFunc</a></code></pre></div>
<p>Also, we have access to the libraries we just imported. To test that out, import the Lens library with <code>import Control.Lens</code>. Then, I’ll show you how it’s useful for getting values from tuples.</p>
<div class="sourceCode" id="cb394"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb394-1" data-line-number="1"><span class="fu">*</span><span class="dt">Main</span> <span class="dt">Lib</span><span class="fu">&gt;</span> <span class="kw">import</span> <span class="dt">Control.Lens</span></a>
<a class="sourceLine" id="cb394-2" data-line-number="2"><span class="fu">*</span><span class="dt">Main</span> <span class="dt">Lib</span> <span class="dt">Control.Lens</span><span class="fu">&gt;</span> view _1 (<span class="st">&quot;hello&quot;</span>, <span class="st">&quot;goodbye&quot;</span>, <span class="st">&quot;how&quot;</span>)</a>
<a class="sourceLine" id="cb394-3" data-line-number="3"><span class="st">&quot;hello&quot;</span></a></code></pre></div>
<p>You’ll see that confusingly, Lens indices for tuples start at 1.</p>
<p>Let’s briefly discuss the structure of this project. The <code>main</code> function for our project is in <code>app/Main.hs</code>. It imports the <code>Lib</code> module which we define in <code>src/Lib.hs</code>. Inside <code>Lib.hs</code> we define a function called <code>someFunc</code>, so we’re able to call it inside <code>Main.hs</code>.</p>
<div class="sourceCode" id="cb395"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb395-1" data-line-number="1"><span class="co">-- app/Main.hs</span></a>
<a class="sourceLine" id="cb395-2" data-line-number="2"><span class="kw">module</span> <span class="dt">Main</span> <span class="kw">where</span></a>
<a class="sourceLine" id="cb395-3" data-line-number="3"></a>
<a class="sourceLine" id="cb395-4" data-line-number="4"><span class="kw">import</span> <span class="dt">Lib</span></a>
<a class="sourceLine" id="cb395-5" data-line-number="5"></a>
<a class="sourceLine" id="cb395-6" data-line-number="6"><span class="ot">main ::</span> <span class="dt">IO</span> ()</a>
<a class="sourceLine" id="cb395-7" data-line-number="7">main <span class="fu">=</span> someFunc</a></code></pre></div>
<div class="sourceCode" id="cb396"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb396-1" data-line-number="1"><span class="co">-- src/Lib.hs</span></a>
<a class="sourceLine" id="cb396-2" data-line-number="2"><span class="kw">module</span> <span class="dt">Lib</span></a>
<a class="sourceLine" id="cb396-3" data-line-number="3">    ( someFunc</a>
<a class="sourceLine" id="cb396-4" data-line-number="4">    ) <span class="kw">where</span></a>
<a class="sourceLine" id="cb396-5" data-line-number="5"></a>
<a class="sourceLine" id="cb396-6" data-line-number="6"><span class="ot">someFunc ::</span> <span class="dt">IO</span> ()</a>
<a class="sourceLine" id="cb396-7" data-line-number="7">someFunc <span class="fu">=</span> putStrLn <span class="st">&quot;someFunc&quot;</span></a></code></pre></div>
<p>The first couple lines in <code>src/Lib.hs</code> are new to us. They’re written like:</p>
<div class="sourceCode" id="cb397"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb397-1" data-line-number="1"><span class="kw">module</span> <span class="dt">Lib</span></a>
<a class="sourceLine" id="cb397-2" data-line-number="2">    ( someFunc</a>
<a class="sourceLine" id="cb397-3" data-line-number="3">    ) <span class="kw">where</span></a></code></pre></div>
<p>But that’s just for ease of input, they could have also written it like this:</p>
<div class="sourceCode" id="cb398"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb398-1" data-line-number="1"><span class="kw">module</span> <span class="dt">Lib</span> (someFunc) <span class="kw">where</span></a></code></pre></div>
<p>What this means is that <code>Lib</code> only <em>exports</em> the <code>someFunc</code> function (when you import a module, you only get what it exported). By default modules export everything, adding <code>(someFunc)</code> tells it to only export <code>someFunc</code>. Only exporting what you have to is considered good practice in Haskell.</p>
<p>The idea is that all of our little helper functions go in <code>Lib</code>, and then our actual code to run our app goes in <code>Main</code>. This is because any code in the <code>src</code> folder can be automatically tested, but code in the <code>app</code> folder cannot. We write our automatic tests in <code>Spec.hs</code>, and I’ll explain how tests work in a moment.</p>
<h2 id="how-to-test-our-code">How To Test Our Code</h2>
<p>You may be familiar with the Stack command <code>stack build</code>. It’s what we used to build our <code>textAdventure</code> project into an executable we could distribute to our friends and family. We could run this executable to test our project manually, but that’s a bit repetitive. A more modern Haskell-ey way is to <em>write our tests in code</em>, then have those run. The library we do that with is one called <code>hspec</code>, which we set up in the last chapter.</p>
<p>To run our tests, we just run <code>stack build --test</code> (or just <code>stack test</code> for short). This will build our code and then run the tests. <code>stack build</code> can be pretty slow because GHC spends a lot of time optimizing, so you can use <code>stack build --fast --test</code> instead. But you shouldn’t use <code>fast</code> to make a production build since it trades fast builds for slow code. If you run this, you should see:</p>
<div class="sourceCode" id="cb399"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb399-1" data-line-number="1"><span class="dt">Test</span> suite not yet implemented</a></code></pre></div>
<p>That’s because we haven’t added any tests yet! Let’s write our first function and then test it. As a reminder, we’re making a program that’ll let us talk in IRC chatrooms. We’ll let the user enter a <em>channel</em> (the IRC term for a chatroom) which our program will join and talk in. Channels in IRC must begin with a <code>#</code> and can’t contain a space. Let’s start writing a function that will take a <code>String</code> and return a <code>Bool</code> telling us whether it’s a valid name for a channel. We’ll do this in <code>src/Lib.hs</code>, so we can test it.</p>
<div class="sourceCode" id="cb400"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb400-1" data-line-number="1"><span class="co">-- src/Lib.hs</span></a>
<a class="sourceLine" id="cb400-2" data-line-number="2"><span class="kw">module</span> <span class="dt">Lib</span></a>
<a class="sourceLine" id="cb400-3" data-line-number="3">    ( someFunc,</a>
<a class="sourceLine" id="cb400-4" data-line-number="4">      isValidChannelName <span class="co">-- We also want to export isValidChannelName, so we add it here.</span></a>
<a class="sourceLine" id="cb400-5" data-line-number="5">    ) <span class="kw">where</span></a>
<a class="sourceLine" id="cb400-6" data-line-number="6"></a>
<a class="sourceLine" id="cb400-7" data-line-number="7"></a>
<a class="sourceLine" id="cb400-8" data-line-number="8"><span class="co">-- We&#39;ll just check if the first letter is &#39;#&#39;.</span></a>
<a class="sourceLine" id="cb400-9" data-line-number="9"><span class="ot">isValidChannelName ::</span> <span class="dt">String</span> <span class="ot">-&gt;</span> <span class="dt">Bool</span></a>
<a class="sourceLine" id="cb400-10" data-line-number="10">isValidChannelName s <span class="fu">=</span> (head s) <span class="fu">==</span> <span class="ch">&#39;#&#39;</span></a>
<a class="sourceLine" id="cb400-11" data-line-number="11"></a>
<a class="sourceLine" id="cb400-12" data-line-number="12"><span class="ot">someFunc ::</span> <span class="dt">IO</span> ()</a>
<a class="sourceLine" id="cb400-13" data-line-number="13">someFunc <span class="fu">=</span> putStrLn <span class="st">&quot;someFunc&quot;</span></a></code></pre></div>
<p>Now, let’s write a test for this! Go into <code>test/Spec.hs</code>.</p>
<div class="sourceCode" id="cb401"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb401-1" data-line-number="1"><span class="co">-- test/Spec.hs</span></a>
<a class="sourceLine" id="cb401-2" data-line-number="2"><span class="ot">main ::</span> <span class="dt">IO</span> ()</a>
<a class="sourceLine" id="cb401-3" data-line-number="3">main <span class="fu">=</span> putStrLn <span class="st">&quot;Test suite not yet implemented&quot;</span></a></code></pre></div>
<p>Not much to it. Add <code>import Test.Hspec</code> and <code>import Lib</code> to the top.</p>
<div class="sourceCode" id="cb402"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb402-1" data-line-number="1"><span class="co">-- test/Spec.hs</span></a>
<a class="sourceLine" id="cb402-2" data-line-number="2"><span class="kw">import</span> <span class="dt">Test.Hspec</span></a>
<a class="sourceLine" id="cb402-3" data-line-number="3"><span class="kw">import</span> <span class="dt">Lib</span></a>
<a class="sourceLine" id="cb402-4" data-line-number="4"></a>
<a class="sourceLine" id="cb402-5" data-line-number="5"><span class="ot">main ::</span> <span class="dt">IO</span> ()</a>
<a class="sourceLine" id="cb402-6" data-line-number="6">main <span class="fu">=</span> putStrLn <span class="st">&quot;Test suite not yet implemented&quot;</span></a></code></pre></div>
<p>This will give us access to the <code>hspec</code> functions, which we’ll use for testing the functions in <code>Lib</code>. Then, we’ll add a test. Tests are easy to understand once you’ve seen them.</p>
<div class="sourceCode" id="cb403"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb403-1" data-line-number="1"><span class="co">-- test/Spec.hs</span></a>
<a class="sourceLine" id="cb403-2" data-line-number="2"><span class="kw">import</span> <span class="dt">Test.Hspec</span></a>
<a class="sourceLine" id="cb403-3" data-line-number="3"><span class="kw">import</span> <span class="dt">Lib</span></a>
<a class="sourceLine" id="cb403-4" data-line-number="4"></a>
<a class="sourceLine" id="cb403-5" data-line-number="5"><span class="ot">main ::</span> <span class="dt">IO</span> ()</a>
<a class="sourceLine" id="cb403-6" data-line-number="6">main <span class="fu">=</span> hspec <span class="fu">$</span> <span class="kw">do</span></a>
<a class="sourceLine" id="cb403-7" data-line-number="7">    describe <span class="st">&quot;Lib.isValidChannelName&quot;</span> <span class="fu">$</span> <span class="kw">do</span></a>
<a class="sourceLine" id="cb403-8" data-line-number="8">      it <span class="st">&quot;allows channels with # in the first character&quot;</span> <span class="fu">$</span> <span class="kw">do</span></a>
<a class="sourceLine" id="cb403-9" data-line-number="9">        isValidChannelName <span class="st">&quot;#haskell&quot;</span> <span class="ot">`shouldBe`</span> (<span class="dt">True</span><span class="ot"> ::</span> <span class="dt">Bool</span>)</a>
<a class="sourceLine" id="cb403-10" data-line-number="10">        isValidChannelName <span class="st">&quot;#ghc&quot;</span> <span class="ot">`shouldBe`</span> (<span class="dt">True</span><span class="ot"> ::</span> <span class="dt">Bool</span>)</a></code></pre></div>
<p><code>hspec</code> uses a lot of nested <code>do</code>s. Let’s add another test to make sure we don’t just accept anything.</p>
<div class="sourceCode" id="cb404"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb404-1" data-line-number="1"><span class="co">-- test/Spec.hs</span></a>
<a class="sourceLine" id="cb404-2" data-line-number="2"><span class="co">-- [...]</span></a>
<a class="sourceLine" id="cb404-3" data-line-number="3"><span class="ot">main ::</span> <span class="dt">IO</span> ()</a>
<a class="sourceLine" id="cb404-4" data-line-number="4">main <span class="fu">=</span> hspec <span class="fu">$</span> <span class="kw">do</span></a>
<a class="sourceLine" id="cb404-5" data-line-number="5">    describe <span class="st">&quot;Lib.isValidChannelName&quot;</span> <span class="fu">$</span> <span class="kw">do</span></a>
<a class="sourceLine" id="cb404-6" data-line-number="6">      it <span class="st">&quot;allows a channel with # in the first character&quot;</span> <span class="fu">$</span> <span class="kw">do</span></a>
<a class="sourceLine" id="cb404-7" data-line-number="7">        isValidChannelName <span class="st">&quot;#haskell&quot;</span> <span class="ot">`shouldBe`</span> (<span class="dt">True</span><span class="ot"> ::</span> <span class="dt">Bool</span>)</a>
<a class="sourceLine" id="cb404-8" data-line-number="8">        isValidChannelName <span class="st">&quot;#ghc&quot;</span> <span class="ot">`shouldBe`</span> (<span class="dt">True</span><span class="ot"> ::</span> <span class="dt">Bool</span>)</a>
<a class="sourceLine" id="cb404-9" data-line-number="9"></a>
<a class="sourceLine" id="cb404-10" data-line-number="10">      it <span class="st">&quot;disallows channels without # in the first character&quot;</span> <span class="fu">$</span> <span class="kw">do</span></a>
<a class="sourceLine" id="cb404-11" data-line-number="11">        isValidChannelName <span class="st">&quot;haskell&quot;</span> <span class="ot">`shouldBe`</span> (<span class="dt">False</span><span class="ot"> ::</span> <span class="dt">Bool</span>)</a></code></pre></div>
<p>Now, run <code>stack build --fast --test</code> and see what it says! Both of our tests will pass. This kind of testing is known as <em>spec testing</em>, and is very useful. But it has some flaws: we have to write every test ourselves, which is time-consuming. Also, we might miss some edge case we didn’t think about! That’s where <em>property testing</em> comes in, with <code>QuickCheck</code> (which comes with <code>Hspec</code>). Import <code>Test.Quickcheck</code> at the top.</p>
<div class="sourceCode" id="cb405"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb405-1" data-line-number="1"><span class="co">-- test/Spec.hs</span></a>
<a class="sourceLine" id="cb405-2" data-line-number="2"><span class="kw">import</span> <span class="dt">Test.Hspec</span></a>
<a class="sourceLine" id="cb405-3" data-line-number="3"><span class="kw">import</span> <span class="dt">Test.QuickCheck</span></a>
<a class="sourceLine" id="cb405-4" data-line-number="4"><span class="kw">import</span> <span class="dt">Lib</span></a>
<a class="sourceLine" id="cb405-5" data-line-number="5"><span class="co">-- [...]</span></a></code></pre></div>
<p>The idea behind property testing is instead of giving specific tests, you give a function that does a test based off a random input. Here’s how it works:</p>
<div class="sourceCode" id="cb406"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb406-1" data-line-number="1"><span class="co">-- test/Spec.hs</span></a>
<a class="sourceLine" id="cb406-2" data-line-number="2"><span class="co">-- ...</span></a>
<a class="sourceLine" id="cb406-3" data-line-number="3"></a>
<a class="sourceLine" id="cb406-4" data-line-number="4"><span class="ot">main ::</span> <span class="dt">IO</span> ()</a>
<a class="sourceLine" id="cb406-5" data-line-number="5">main <span class="fu">=</span> hspec <span class="fu">$</span> <span class="kw">do</span></a>
<a class="sourceLine" id="cb406-6" data-line-number="6">    describe <span class="st">&quot;Lib.isValidChannelName&quot;</span> <span class="fu">$</span> <span class="kw">do</span></a>
<a class="sourceLine" id="cb406-7" data-line-number="7">      it <span class="st">&quot;allows a channel with # in the first character&quot;</span> <span class="fu">$</span> <span class="kw">do</span></a>
<a class="sourceLine" id="cb406-8" data-line-number="8">        isValidChannelName <span class="st">&quot;#haskell&quot;</span> <span class="ot">`shouldBe`</span> (<span class="dt">True</span><span class="ot"> ::</span> <span class="dt">Bool</span>)</a>
<a class="sourceLine" id="cb406-9" data-line-number="9">        isValidChannelName <span class="st">&quot;#ghc&quot;</span> <span class="ot">`shouldBe`</span> (<span class="dt">True</span><span class="ot"> ::</span> <span class="dt">Bool</span>)</a>
<a class="sourceLine" id="cb406-10" data-line-number="10"></a>
<a class="sourceLine" id="cb406-11" data-line-number="11">      it <span class="st">&quot;disallows channels without # in the first character&quot;</span> <span class="fu">$</span> <span class="kw">do</span></a>
<a class="sourceLine" id="cb406-12" data-line-number="12">        isValidChannelName <span class="st">&quot;haskell&quot;</span> <span class="ot">`shouldBe`</span> (<span class="dt">False</span><span class="ot"> ::</span> <span class="dt">Bool</span>)</a>
<a class="sourceLine" id="cb406-13" data-line-number="13">        </a>
<a class="sourceLine" id="cb406-14" data-line-number="14">      it <span class="st">&quot;allows channels should contain a &#39;#&#39;&quot;</span> <span class="fu">$</span> <span class="kw">do</span></a>
<a class="sourceLine" id="cb406-15" data-line-number="15">        property <span class="fu">$</span> \xs <span class="ot">-&gt;</span> <span class="kw">if</span> isValidChannelName xs</a>
<a class="sourceLine" id="cb406-16" data-line-number="16">                           <span class="kw">then</span> elem <span class="ch">&#39;#&#39;</span> (<span class="ot">xs ::</span> <span class="dt">String</span>)</a>
<a class="sourceLine" id="cb406-17" data-line-number="17">                           <span class="kw">else</span> <span class="dt">True</span></a></code></pre></div>
<p>instead of using <code>shouldBe</code>, we’ve made a property. The property is a function that should always return True if your function works correctly. The property I wrote down here tests that if our function says something is a valid channel name, that channel name should contain a <code>#</code>. QuickCheck will generate a load of random values<label for="marginnote-126" class="margin-toggle">⊕</label> <input type="checkbox" id="marginnote-126" class="margin-toggle"/> <span class="marginnote">By default, QuickCheck does around 100 tests.</span> and pass them to your function, and if your function ever returns <code>False</code> it’ll be counted as a test failure. It also tries edge cases, like very small numbers, very large numbers, empty lists, lists that only contain <code>0</code>, etc. Anyway, let’s run our tests with <code>stack build --fast --test</code>. Lo and behold, we find a bug!</p>
<div class="sourceCode" id="cb407"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb407-1" data-line-number="1"><span class="dt">Failures</span><span class="fu">:</span></a>
<a class="sourceLine" id="cb407-2" data-line-number="2"></a>
<a class="sourceLine" id="cb407-3" data-line-number="3">  test\Spec.hs<span class="fu">:</span><span class="dv">14</span><span class="fu">:</span><span class="dv">7</span><span class="fu">:</span></a>
<a class="sourceLine" id="cb407-4" data-line-number="4">  <span class="dv">1</span>) Lib.isValidChannelName <span class="dt">Allowed</span> channels should contain a <span class="ch">&#39;#&#39;</span></a>
<a class="sourceLine" id="cb407-5" data-line-number="5">       uncaught exception<span class="fu">:</span> <span class="dt">ErrorCall</span></a>
<a class="sourceLine" id="cb407-6" data-line-number="6">       Prelude.head<span class="fu">:</span> empty list</a>
<a class="sourceLine" id="cb407-7" data-line-number="7">       (after <span class="dv">1</span> test)</a>
<a class="sourceLine" id="cb407-8" data-line-number="8">         <span class="st">&quot;&quot;</span></a></code></pre></div>
<p>It says our function threw an <em>uncaught exception</em>, specifically, it throws an exception when we pass it an empty list! Let’s fix our function.</p>
<div class="sourceCode" id="cb408"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb408-1" data-line-number="1"><span class="co">-- src/Lib.hs</span></a>
<a class="sourceLine" id="cb408-2" data-line-number="2"></a>
<a class="sourceLine" id="cb408-3" data-line-number="3"><span class="ot">isValidChannelName ::</span> <span class="dt">String</span> <span class="ot">-&gt;</span> <span class="dt">Bool</span></a>
<a class="sourceLine" id="cb408-4" data-line-number="4"><span class="co">-- Use pattern matching to return False when passed an empty list.</span></a>
<a class="sourceLine" id="cb408-5" data-line-number="5">isValidChannelName [] <span class="fu">=</span> <span class="dt">False</span>          </a>
<a class="sourceLine" id="cb408-6" data-line-number="6">isValidChannelName s <span class="fu">=</span> (head s) <span class="fu">==</span> <span class="ch">&#39;#&#39;</span></a></code></pre></div>
<p>Now when running <code>stack build --fast --test</code>, we get <code>3 examples, 0 failures</code>! Property tests with QuickCheck can be a powerful tool to validate that your programs run properly, in addition to spec tests with Hspec. Any time you fix a bug in one of your functions, you should write a spec or property test to make sure it doesn’t pop up again. This is called regression testing, and it often comes easy, since if you think a function has a bug the first thing you should do is write some tests for it.</p>
<p>You can also see how much of your code you’ve tested by telling stack to run a <em>code coverage report</em>. You can do this with <code>stack build --fast --test --coverage</code>. This should generate something like:</p>
<div class="sourceCode" id="cb409"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb409-1" data-line-number="1">irc<span class="fu">-</span><span class="fl">0.1</span><span class="fu">.</span><span class="fl">0.0</span><span class="fu">:</span> <span class="dt">Test</span> suite irc<span class="fu">-</span>test passed</a>
<a class="sourceLine" id="cb409-2" data-line-number="2"><span class="dt">Generating</span> coverage report for irc&#39;s test<span class="fu">-</span>suite <span class="st">&quot;irc-test&quot;</span></a>
<a class="sourceLine" id="cb409-3" data-line-number="3"> <span class="dv">71</span><span class="fu">%</span> expressions used (<span class="dv">5</span><span class="fu">/</span><span class="dv">7</span>)</a>
<a class="sourceLine" id="cb409-4" data-line-number="4"><span class="dv">100</span><span class="fu">%</span> boolean coverage (<span class="dv">0</span><span class="fu">/</span><span class="dv">0</span>)</a>
<a class="sourceLine" id="cb409-5" data-line-number="5">     <span class="dv">100</span><span class="fu">%</span> guards (<span class="dv">0</span><span class="fu">/</span><span class="dv">0</span>)</a>
<a class="sourceLine" id="cb409-6" data-line-number="6">     <span class="dv">100</span><span class="fu">%</span> &#39;if&#39; conditions (<span class="dv">0</span><span class="fu">/</span><span class="dv">0</span>)</a>
<a class="sourceLine" id="cb409-7" data-line-number="7">     <span class="dv">100</span><span class="fu">%</span> qualifiers (<span class="dv">0</span><span class="fu">/</span><span class="dv">0</span>)</a>
<a class="sourceLine" id="cb409-8" data-line-number="8"><span class="dv">100</span><span class="fu">%</span> alternatives used (<span class="dv">2</span><span class="fu">/</span><span class="dv">2</span>)</a>
<a class="sourceLine" id="cb409-9" data-line-number="9"><span class="dv">100</span><span class="fu">%</span> local declarations used (<span class="dv">0</span><span class="fu">/</span><span class="dv">0</span>)</a>
<a class="sourceLine" id="cb409-10" data-line-number="10"> <span class="dv">50</span><span class="fu">%</span> top<span class="fu">-</span>level declarations used (<span class="dv">1</span><span class="fu">/</span><span class="dv">2</span>)</a></code></pre></div>
<p>The most important one is the last one - <code>50% top-level declarations used</code>. This essentially tests how many top-level functions (functions not inside another function) you’ve got at least one test for. Our <code>Lib</code> module has two, <code>someFunc</code> and <code>isValidChannelName</code>, and we’ve only tested the latter so that leaves us with 50% top-level declarations. We’ll be getting rid of <code>someFunc</code> soon so we won’t bother testing it.</p>
<p>Also, if you don’t feel like writing a test, you can just write <code>pending</code>, like this.</p>
<div class="sourceCode" id="cb410"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb410-1" data-line-number="1"><span class="ot">main ::</span> <span class="dt">IO</span> ()</a>
<a class="sourceLine" id="cb410-2" data-line-number="2">main <span class="fu">=</span> hspec <span class="fu">$</span> <span class="kw">do</span></a>
<a class="sourceLine" id="cb410-3" data-line-number="3">    describe <span class="st">&quot;Lib.isValidChannelName&quot;</span> <span class="fu">$</span> <span class="kw">do</span></a>
<a class="sourceLine" id="cb410-4" data-line-number="4">      it <span class="st">&quot;allows a channel with # in the first character&quot;</span> <span class="fu">$</span> <span class="kw">do</span></a>
<a class="sourceLine" id="cb410-5" data-line-number="5">        isValidChannelName <span class="st">&quot;#haskell&quot;</span> <span class="ot">`shouldBe`</span> (<span class="dt">True</span><span class="ot"> ::</span> <span class="dt">Bool</span>)</a>
<a class="sourceLine" id="cb410-6" data-line-number="6">        isValidChannelName <span class="st">&quot;#ghc&quot;</span> <span class="ot">`shouldBe`</span> (<span class="dt">True</span><span class="ot"> ::</span> <span class="dt">Bool</span>)</a>
<a class="sourceLine" id="cb410-7" data-line-number="7"></a>
<a class="sourceLine" id="cb410-8" data-line-number="8">      it <span class="st">&quot;disallows channels without # in the first character&quot;</span> <span class="fu">$</span></a>
<a class="sourceLine" id="cb410-9" data-line-number="9">        isValidChannelName <span class="st">&quot;haskell&quot;</span> <span class="ot">`shouldBe`</span> (<span class="dt">False</span><span class="ot"> ::</span> <span class="dt">Bool</span>)</a>
<a class="sourceLine" id="cb410-10" data-line-number="10">        </a>
<a class="sourceLine" id="cb410-11" data-line-number="11">      it <span class="st">&quot;allows channels should contain a &#39;#&#39;&quot;</span> <span class="fu">$</span> <span class="kw">do</span></a>
<a class="sourceLine" id="cb410-12" data-line-number="12">        property <span class="fu">$</span> \xs <span class="ot">-&gt;</span> <span class="kw">if</span> isValidChannelName xs</a>
<a class="sourceLine" id="cb410-13" data-line-number="13">                           <span class="kw">then</span> elem <span class="ch">&#39;#&#39;</span> (<span class="ot">xs ::</span> <span class="dt">String</span>)</a>
<a class="sourceLine" id="cb410-14" data-line-number="14">                           <span class="kw">else</span> <span class="dt">True</span></a>
<a class="sourceLine" id="cb410-15" data-line-number="15"></a>
<a class="sourceLine" id="cb410-16" data-line-number="16">      it <span class="st">&quot;disallows spaces&quot;</span> <span class="fu">$</span> <span class="kw">do</span></a>
<a class="sourceLine" id="cb410-17" data-line-number="17">        pending</a></code></pre></div>
<p>This is a helpful reminder that you still need to write that test (Stack will remind you when you run your tests). If there’s some reason you haven’t written the test besides laziness, you can use <code>pendingWith</code>.</p>
<div class="sourceCode" id="cb411"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb411-1" data-line-number="1">      it <span class="st">&quot;disallows spaces&quot;</span> <span class="fu">$</span> <span class="kw">do</span></a>
<a class="sourceLine" id="cb411-2" data-line-number="2">        pendingWith <span class="st">&quot;This is an exercise for you, the reader! \</span></a>
<a class="sourceLine" id="cb411-3" data-line-number="3"><span class="st">                    \Write a spec test to test if our function \</span></a>
<a class="sourceLine" id="cb411-4" data-line-number="4"><span class="st">                    \allows a channel name with a space.&quot;</span></a></code></pre></div>
<p>Yes, I’m serious! Replace this <code>pendingWith</code> with a spec test to see that our function won’t accept a channel with a space like <code>&quot;#haskell programming&quot;</code>. We haven’t implemented checking for spaces yet, so your test will fail until we do. It’s always a good idea to write a test for features you haven’t implemented yet, so you won’t forget. Also, you may have noticed the backslashes inside this string. That’s how you spread strings across multiple lines, which I like to do because I try to avoid any of my lines being more than 120 characters long.</p>
<hr />
<p><strong><strong><em>Exercises</em></strong></strong>:</p>
<ol type="1">
<li><p>Write a spec test that ensures that <code>isValidChannelName</code> returns <code>False</code> when passed an empty string.</p></li>
<li><p>Write a spec test that tests that <code>isValidChannelName</code> returns <code>False</code> when passed <code>&quot;#learn Haskell&quot;</code>. This test should fail.</p></li>
<li><p>Write a property test that takes a value <code>xs</code> and checks that <code>isValidChannelName (xs ++ &quot; &quot;)</code> is <code>False</code>.</p></li>
<li><p>In <code>Lib.hs</code>’s <code>isValidChannelName</code>, use <code>not (elem ' ' s)</code> to check that the input <code>String</code> does not contain a space. You can do this with the binary <code>&amp;&amp;</code> operator, <code>if/then/else</code> syntax, or <a href="#guards">Guards</a>.</p></li>
<li><p>After completing #4, rerun your tests. They should pass!</p></li>
</ol>
<hr />
<h2 id="reading-and-writing-documentation">Reading and Writing Documentation</h2>
<p>Often, we would like to explain what a certain function does, in a way that’s not easily represented in the function’s name. For example, maybe we would like to say that our <code>isValidChannelName</code> function will return <code>True</code> in cases where the first character is <code>#</code> and the <code>String</code> does not contain a space. This is called <em>documentation</em>. We can do this with a comment, but there’s a special way to annotate our comments so they can be made into a pretty website, using a tool called <em>Haddock</em>.</p>
<p>Here’s our <code>isValidChannelName</code> function, with a descriptive comment:</p>
<div class="sourceCode" id="cb412"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb412-1" data-line-number="1"><span class="co">-- |&#39;isValidChannelName&#39; takes a &#39;String&#39; and will return &#39;True&#39; if the &#39;String&#39; begins with a &#39;#&#39; and does not contain a space. </span></a>
<a class="sourceLine" id="cb412-2" data-line-number="2"><span class="ot">isValidChannelName ::</span> <span class="dt">String</span> <span class="ot">-&gt;</span> <span class="dt">Bool</span></a>
<a class="sourceLine" id="cb412-3" data-line-number="3">isValidChannelName [] <span class="fu">=</span> <span class="dt">False</span></a>
<a class="sourceLine" id="cb412-4" data-line-number="4">isValidChannelName s</a>
<a class="sourceLine" id="cb412-5" data-line-number="5">   <span class="fu">|</span> (head s) <span class="fu">/=</span> <span class="ch">&#39;#&#39;</span> <span class="fu">=</span> <span class="dt">False</span></a>
<a class="sourceLine" id="cb412-6" data-line-number="6">   <span class="fu">|</span> (elem <span class="ch">&#39; &#39;</span> s)    <span class="fu">=</span> <span class="dt">False</span></a>
<a class="sourceLine" id="cb412-7" data-line-number="7">   <span class="fu">|</span> otherwise       <span class="fu">=</span> <span class="dt">True</span></a></code></pre></div>
<p>The <code>-- |</code> is special syntax that informs GHC that this is Haddock documentation. It must be placed before the type signature. We can also spread it out across multiple lines, like this:</p>
<div class="sourceCode" id="cb413"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb413-1" data-line-number="1"><span class="co">-- |&#39;isValidChannelName&#39; takes a &#39;String&#39; and will return &#39;True&#39;</span></a>
<a class="sourceLine" id="cb413-2" data-line-number="2"><span class="co">-- if the &#39;String&#39; begins with a &#39;#&#39; and does not contain a space. </span></a>
<a class="sourceLine" id="cb413-3" data-line-number="3"><span class="ot">isValidChannelName ::</span> <span class="dt">String</span> <span class="ot">-&gt;</span> <span class="dt">Bool</span></a>
<a class="sourceLine" id="cb413-4" data-line-number="4">isValidChannelName [] <span class="fu">=</span> <span class="dt">False</span></a>
<a class="sourceLine" id="cb413-5" data-line-number="5">isValidChannelName s</a>
<a class="sourceLine" id="cb413-6" data-line-number="6">   <span class="fu">|</span> (head s) <span class="fu">/=</span> <span class="ch">&#39;#&#39;</span> <span class="fu">=</span> <span class="dt">False</span></a>
<a class="sourceLine" id="cb413-7" data-line-number="7">   <span class="fu">|</span> (elem <span class="ch">&#39; &#39;</span> s)    <span class="fu">=</span> <span class="dt">False</span></a>
<a class="sourceLine" id="cb413-8" data-line-number="8">   <span class="fu">|</span> otherwise       <span class="fu">=</span> <span class="dt">True</span></a></code></pre></div>
<p>We can also use <code>-- ^</code> to give details about individual arguments and the return value:</p>
<div class="sourceCode" id="cb414"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb414-1" data-line-number="1"><span class="co">-- |&#39;isValidChannelName&#39; takes a &#39;String&#39; and will return &#39;True&#39;</span></a>
<a class="sourceLine" id="cb414-2" data-line-number="2"><span class="co">-- if the &#39;String&#39; begins with a &#39;#&#39; and does not contain a space. </span></a>
<a class="sourceLine" id="cb414-3" data-line-number="3"><span class="ot">isValidChannelName ::</span> <span class="dt">String</span> <span class="co">-- ^ The channel name.</span></a>
<a class="sourceLine" id="cb414-4" data-line-number="4">                   <span class="ot">-&gt;</span> <span class="dt">Bool</span>   <span class="co">-- ^ &#39;True&#39; if the channel name is valid, &#39;False&#39; otherwise.</span></a>
<a class="sourceLine" id="cb414-5" data-line-number="5">isValidChannelName [] <span class="fu">=</span> <span class="dt">False</span></a>
<a class="sourceLine" id="cb414-6" data-line-number="6">isValidChannelName s</a>
<a class="sourceLine" id="cb414-7" data-line-number="7">   <span class="fu">|</span> (head s) <span class="fu">/=</span> <span class="ch">&#39;#&#39;</span> <span class="fu">=</span> <span class="dt">False</span></a>
<a class="sourceLine" id="cb414-8" data-line-number="8">   <span class="fu">|</span> (elem <span class="ch">&#39; &#39;</span> s)    <span class="fu">=</span> <span class="dt">False</span></a>
<a class="sourceLine" id="cb414-9" data-line-number="9">   <span class="fu">|</span> otherwise       <span class="fu">=</span> <span class="dt">True</span></a></code></pre></div>
<p>There’s a lot of special markup you can use to make your documentation prettier, you can read about it in the <a href="https://haskell-haddock.readthedocs.io/en/latest/markup.html#markup">Haddock documentation</a>.</p>
<p>Now, you can <em>build</em> your haddock documentation with stack using the <code>--haddock</code> flag. To build and test your code without optimization, plus build haddock, run <code>stack build --test --fast --haddock</code>. Now, Haddock often takes a long time to run, and you usually don’t really care that much about seeing your own haddock documentation, but instead you’re more interested in seeing the documentation of your dependencies (our current dependencies are <code>hspec</code>, <code>QuickCheck</code>, <code>lens</code>, and <code>network</code>). After the first time it’s much faster to only build those, and we can do that with <code>haddock-deps</code>, since it won’t run at all if we haven’t added new dependencies. This is our new command:</p>
<div class="sourceCode" id="cb415"><pre class="sourceCode bash"><code class="sourceCode bash"><a class="sourceLine" id="cb415-1" data-line-number="1"><span class="ex">stack</span> build --test --fast --haddock-deps</a></code></pre></div>
<p>Now, we can read the documentation for a dependency with <code>stack haddock --open &lt;something&gt;</code>. For example, we can look at the documentation for <code>lens</code> with <code>stack haddock --open lens</code>. However, it’s written in a somewhat intimidating style so I recommend looking at <code>hspec</code> instead. This is better than reading the docs online because you’re guaranteed to be reading the docs for the right version of whatever library you’re using.</p>
<p>You can also get a searchable version of these docs with <em>Hoogle</em>. You must first run a command to generate Hoogle’s index:</p>
<div class="sourceCode" id="cb416"><pre class="sourceCode bash"><code class="sourceCode bash"><a class="sourceLine" id="cb416-1" data-line-number="1"><span class="ex">stack</span> hoogle -- generate --local</a></code></pre></div>
<p>This will probably take some time, especially since it’ll probably have to download hoogle. You’ll have to rerun this whenever you add any more dependencies but it should be much faster after the first time. After this you just need to start a Hoogle server with one easy command:</p>
<div class="sourceCode" id="cb417"><pre class="sourceCode bash"><code class="sourceCode bash"><a class="sourceLine" id="cb417-1" data-line-number="1"><span class="ex">stack</span> hoogle -- server --local --port=8080</a></code></pre></div>
<p>Then go to <a href="http://localhost:8080" class="uri">http://localhost:8080</a> and try doing a search! Maybe look at the type of the <code>property</code> function we used for writing property tests in QuickCheck. By the way, if you ever add a new dependency, you need to re-run <code>stack hoogle -- generate --local</code>.</p>
<h2 id="warnings-and-editor-settings">Warnings and Editor Settings</h2>
<p>GHC had the concept of “warnings” in addition to errors. This is when GHC sees things that it thinks might be the source of bugs in the future. Most warnings are turned off by default, but you can put something in your <code>package.yaml</code> to turn them on. Open your <code>package.yaml</code> find the dependencies section:</p>
<div class="sourceCode" id="cb418"><pre class="sourceCode yaml"><code class="sourceCode yaml"><a class="sourceLine" id="cb418-1" data-line-number="1"><span class="fu">dependencies:</span></a>
<a class="sourceLine" id="cb418-2" data-line-number="2"><span class="kw">-</span> base &gt;= 4.7 &amp;&amp; &lt; 5</a>
<a class="sourceLine" id="cb418-3" data-line-number="3"><span class="kw">-</span> hspec</a>
<a class="sourceLine" id="cb418-4" data-line-number="4"><span class="kw">-</span> QuickCheck</a>
<a class="sourceLine" id="cb418-5" data-line-number="5"><span class="kw">-</span> lens</a>
<a class="sourceLine" id="cb418-6" data-line-number="6"><span class="kw">-</span> network</a></code></pre></div>
<p>We’re gonna add something right below it:</p>
<div class="sourceCode" id="cb419"><pre class="sourceCode yaml"><code class="sourceCode yaml"><a class="sourceLine" id="cb419-1" data-line-number="1"><span class="fu">dependencies:</span></a>
<a class="sourceLine" id="cb419-2" data-line-number="2"><span class="kw">-</span> base &gt;= 4.7 &amp;&amp; &lt; 5</a>
<a class="sourceLine" id="cb419-3" data-line-number="3"><span class="kw">-</span> hspec</a>
<a class="sourceLine" id="cb419-4" data-line-number="4"><span class="kw">-</span> QuickCheck</a>
<a class="sourceLine" id="cb419-5" data-line-number="5"><span class="kw">-</span> lens</a>
<a class="sourceLine" id="cb419-6" data-line-number="6"><span class="kw">-</span> network</a>
<a class="sourceLine" id="cb419-7" data-line-number="7"></a>
<a class="sourceLine" id="cb419-8" data-line-number="8"><span class="fu">ghc-options:</span></a>
<a class="sourceLine" id="cb419-9" data-line-number="9"><span class="kw">-</span> -Wall</a>
<a class="sourceLine" id="cb419-10" data-line-number="10"><span class="kw">-</span> -Wcompat</a>
<a class="sourceLine" id="cb419-11" data-line-number="11"><span class="kw">-</span> -Wincomplete-record-updates</a>
<a class="sourceLine" id="cb419-12" data-line-number="12"><span class="kw">-</span> -Wincomplete-uni-patterns</a>
<a class="sourceLine" id="cb419-13" data-line-number="13"><span class="kw">-</span> -Wredundant-constraints</a></code></pre></div>
<p>This turns on the following warnings: <code>Wall</code>, <code>Wcompat</code>, <code>Wincomplete-record-updates</code>, <code>Wincomplete-uni-patterns</code>, and <code>Wredundant-constraints</code>. I won’t explain what all of these do, but they aren’t too restrictive and if you see a warning you should fix it. In fact, you should try your hardest to never check in code with warnings to version control. This is under the section <code>ghc-options</code> because these are just regular options passed to GHC - you don’t have to build your project with Stack, you could call GHC manually, but stack handling everything for you makes things much more convenient and reliable.</p>
<p>Next up is the topic of GHC language extensions. Haskell is a very nice language but sometimes it has some room for improvement through unofficial extensions implemented in GHC. To do this, we’re going to add another section beneath <code>ghc-options</code>, called <code>default-extensions</code>. You can turn an extension on by writing a special comment at the top of your source files, but this turns them on for all files and is much more convenient. This is a long list of extensions, and lots of them are fairly complicated so I’m not going to explain them all yet. I got this list from Alexis King, and some of the extensions are too complicated for me to easily explain here. Most I will be addressing through the course of this book, though, so stay tuned. If you’re interested in what a particular extension does, you can look it up on <a href="https://downloads.haskell.org/~ghc/8.2.2/docs/html/users_guide/glasgow_exts.html">the GHC docs</a>.</p>
<div class="sourceCode" id="cb420"><pre class="sourceCode yaml"><code class="sourceCode yaml"><a class="sourceLine" id="cb420-1" data-line-number="1"></a>
<a class="sourceLine" id="cb420-2" data-line-number="2"><span class="fu">ghc-options:</span></a>
<a class="sourceLine" id="cb420-3" data-line-number="3"><span class="kw">-</span> -Wall</a>
<a class="sourceLine" id="cb420-4" data-line-number="4"><span class="kw">-</span> -Wcompat</a>
<a class="sourceLine" id="cb420-5" data-line-number="5"><span class="kw">-</span> -Wincomplete-record-updates</a>
<a class="sourceLine" id="cb420-6" data-line-number="6"><span class="kw">-</span> -Wincomplete-uni-patterns</a>
<a class="sourceLine" id="cb420-7" data-line-number="7"><span class="kw">-</span> -Wredundant-constraints</a>
<a class="sourceLine" id="cb420-8" data-line-number="8"></a>
<a class="sourceLine" id="cb420-9" data-line-number="9"><span class="fu">default-extensions:</span></a>
<a class="sourceLine" id="cb420-10" data-line-number="10"><span class="kw">-</span> BangPatterns</a>
<a class="sourceLine" id="cb420-11" data-line-number="11"><span class="kw">-</span> ConstraintKinds</a>
<a class="sourceLine" id="cb420-12" data-line-number="12"><span class="kw">-</span> DataKinds</a>
<a class="sourceLine" id="cb420-13" data-line-number="13"><span class="kw">-</span> DefaultSignatures</a>
<a class="sourceLine" id="cb420-14" data-line-number="14"><span class="kw">-</span> DeriveFoldable</a>
<a class="sourceLine" id="cb420-15" data-line-number="15"><span class="kw">-</span> DeriveFunctor</a>
<a class="sourceLine" id="cb420-16" data-line-number="16"><span class="kw">-</span> DeriveGeneric</a>
<a class="sourceLine" id="cb420-17" data-line-number="17"><span class="kw">-</span> DeriveLift</a>
<a class="sourceLine" id="cb420-18" data-line-number="18"><span class="kw">-</span> DeriveTraversable</a>
<a class="sourceLine" id="cb420-19" data-line-number="19"><span class="kw">-</span> DerivingStrategies</a>
<a class="sourceLine" id="cb420-20" data-line-number="20"><span class="kw">-</span> EmptyCase</a>
<a class="sourceLine" id="cb420-21" data-line-number="21"><span class="kw">-</span> ExistentialQuantification</a>
<a class="sourceLine" id="cb420-22" data-line-number="22"><span class="kw">-</span> FlexibleContexts</a>
<a class="sourceLine" id="cb420-23" data-line-number="23"><span class="kw">-</span> FlexibleInstances</a>
<a class="sourceLine" id="cb420-24" data-line-number="24"><span class="kw">-</span> FunctionalDependencies</a>
<a class="sourceLine" id="cb420-25" data-line-number="25"><span class="kw">-</span> GADTs</a>
<a class="sourceLine" id="cb420-26" data-line-number="26"><span class="kw">-</span> GeneralizedNewtypeDeriving</a>
<a class="sourceLine" id="cb420-27" data-line-number="27"><span class="kw">-</span> InstanceSigs</a>
<a class="sourceLine" id="cb420-28" data-line-number="28"><span class="kw">-</span> KindSignatures</a>
<a class="sourceLine" id="cb420-29" data-line-number="29"><span class="kw">-</span> LambdaCase</a>
<a class="sourceLine" id="cb420-30" data-line-number="30"><span class="kw">-</span> MultiParamTypeClasses</a>
<a class="sourceLine" id="cb420-31" data-line-number="31"><span class="kw">-</span> MultiWayIf</a>
<a class="sourceLine" id="cb420-32" data-line-number="32"><span class="kw">-</span> NamedFieldPuns</a>
<a class="sourceLine" id="cb420-33" data-line-number="33"><span class="kw">-</span> OverloadedStrings</a>
<a class="sourceLine" id="cb420-34" data-line-number="34"><span class="kw">-</span> PatternSynonyms</a>
<a class="sourceLine" id="cb420-35" data-line-number="35"><span class="kw">-</span> RankNTypes</a>
<a class="sourceLine" id="cb420-36" data-line-number="36"><span class="kw">-</span> ScopedTypeVariables</a>
<a class="sourceLine" id="cb420-37" data-line-number="37"><span class="kw">-</span> StandaloneDeriving</a>
<a class="sourceLine" id="cb420-38" data-line-number="38"><span class="kw">-</span> TupleSections</a>
<a class="sourceLine" id="cb420-39" data-line-number="39"><span class="kw">-</span> TypeApplications</a>
<a class="sourceLine" id="cb420-40" data-line-number="40"><span class="kw">-</span> TypeFamilies</a>
<a class="sourceLine" id="cb420-41" data-line-number="41"><span class="kw">-</span> TypeFamilyDependencies</a>
<a class="sourceLine" id="cb420-42" data-line-number="42"><span class="kw">-</span> TypeOperators</a>
<a class="sourceLine" id="cb420-43" data-line-number="43"><span class="kw">-</span> TemplateHaskell</a>
<a class="sourceLine" id="cb420-44" data-line-number="44"><span class="kw">-</span> QuasiQuotes</a></code></pre></div>
<h2 id="what-are-all-these-files-anyway">What Are All These Files, Anyway</h2>
<p>You may have noticed we have 3 different files here, <code>stack.yaml</code>. <code>package.yaml</code>, and <code>irc.cabal</code>. Here’s the good news: you don’t have to worry about <code>irc.cabal</code>. In fact, you can delete it if you want (although it will reappear). Let me explain.</p>
<p>In the beginning, there was just GHC. If you wanted to compile a program, you passed a list of all the files and all the settings to GHC, and GHC gave you an executable. Of course, this isn’t very good from a usability perspective. Because of that, Cabal was created. Cabal is a program which reads a file like <code>irc.cabal</code> and uses the information inside that file to tell GHC to build a program. You can tell it what options you want to provide GHC, what files to build, what your dependencies are, etc. and Cabal would automatically manage it all for you. But Cabal had lots of issues, and a poor user interface, so Stack was created. This added an additional file, <code>stack.yaml</code>, where you could write some extra information and then Stack would handle calling Cabal for you, and downloading packages, running tests, and some other things. You rarely need to mess with <code>stack.yaml</code>, thankfully. But then some people realized that Cabal’s file format was actually pretty bad - it’s verbose and often requires you write the same thing multiple times. That’s why the Hpack file format was created - it’s just a file named <code>package.yaml</code> which gets converted to a <code>.cabal</code> file in a fairly straightforward process. This means you can edit the much nicer <code>package.yaml</code> instead of the messier <code>irc.cabal</code>. In practice, you’ll spend most of your time editing <code>package.yaml</code>, occasionally editing <code>stack.yaml</code>, and you should never have to edit <code>irc.cabal</code>.</p>
<p>When you want to add a dependency, you put it in the <code>dependencies</code> section in your <code>package.yaml</code>. Stack then looks in a library called “Stackage LTS” for a library by that name and downloads that one if it finds it. There are multiple versions of Stackage LTS, and the one Stack looks at is determined by the <em>resolver</em> in <code>stack.yaml</code>. The reason for this complexity is for the goal of reproducible builds. You don’t write the version number of the library you’re using, you only write the name, and there’s only one version of each library of any particular instance of Stackage LTS. If you’d like to use a different version, or a version not in Stackage LTS, you must also specify a version number in <code>stack.yaml</code>. You’re essentially saying “if you have a need for this package, use this version”. If you forget to do this, Stack will fail to build since it won’t know which version to use, but it will give you a nice error message that will typically tell you what to add to the <code>extra-deps</code> section of your <code>stack.yaml</code> in order to fix it. In practice, most libraries you need should be in Stackage LTS so you don’t have to edit <code>stack.yaml</code> too much.</p>
<p>Hopefully, this cleared up some lingering confusion you may have had. Now that we’ve explained that, let’s write our IRC client!</p>
<h2 id="how-to-develop-and-debug">How to Develop and Debug</h2>
<p>The nice thing about having automatic tests for all your code is that Stack makes it very simple to develop this way. You can add the <code>--file-watch</code> flag to your stack command, and this will cause Stack to automatically rebuild your code and rerun your tests every time you change your code. The full command with everything we’ve added is as follows:</p>
<div class="sourceCode" id="cb421"><pre class="sourceCode bash"><code class="sourceCode bash"><a class="sourceLine" id="cb421-1" data-line-number="1"><span class="ex">stack</span> build --test --fast --haddock-deps --file-watch</a></code></pre></div>
<p>If you’ve been writing tests for all your functions, preferably before you even implement them, this becomes a very nice way to develop. Another option is to open your project in <code>stack ghci</code> and run your code with <code>main</code>, and reload your code with <code>:r</code> when you make a change. You can also run your actual project after you’ve built it with:</p>
<div class="sourceCode" id="cb422"><pre class="sourceCode bash"><code class="sourceCode bash"><a class="sourceLine" id="cb422-1" data-line-number="1"><span class="ex">stack</span> exec irc-exe</a></code></pre></div>
<p>Change <code>irc</code> to something else if your project is named differently. Eventually, there will be a <code>stack run</code> command which should remove the need to build before running.</p>
<p>Debugging in Haskell is somewhat difficult. The general process should be:</p>
<ol type="1">
<li><p>Observe a bug.</p></li>
<li><p>Figure out how to reproduce the bug consistently.</p></li>
<li><p>Try to think about what functions are involved in that bug.</p></li>
<li><p>Think about what those functions inputs and outputs should be in the case that causes the bug.</p></li>
<li><p>Start writing tests for how your function <em>should</em> work - when these tests fail, you’ve probably identified one bug or another.</p></li>
<li><p>Change your functions to fix whatever was causing the tests to fail.</p></li>
<li><p>Check if the bug still exists. If so, return to step 4.</p></li>
</ol>
<p>One very helpful tool is the <code>trace</code> function. Inside <code>Debug.Trace</code>, the <code>trace</code> function takes a <code>String</code> and a value and returns that value. But invisibly in the background, it also prints the <code>String</code> you passed in. There is also <code>traceShow</code> which takes any value in the <code>Show</code> typeclass instead of a <code>String</code>. If you want to see if a function is being called, you can replace its output with <code>trace &quot;yep, it's being called&quot; &lt;output&gt;</code>. If a function is returning <code>x</code>, you can see that with <code>traceShow x x</code>. This is common so you can use <code>traceIdShow</code> which just prints and returns whatever you pass it.</p>
<h1 id="generalized-algebraic-data-types-and-data-kinds">Generalized Algebraic Data Types and Data Kinds</h1>
<p>I’m about to explain some <em>advanced</em> Haskell features here. It’s our first foray into Haskell’s language extensions, and we’re starting off with a good one. It’s called Generalized Algebraic Data Types, or GADTs for short. Hopefully you remember data types, they look like this:</p>
<div class="sourceCode" id="cb423"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb423-1" data-line-number="1"><span class="kw">data</span> <span class="dt">Bool</span> <span class="fu">=</span> <span class="dt">False</span> <span class="fu">|</span> <span class="dt">True</span>  </a></code></pre></div>
<p>Here, <code>Bool</code> is a type and <code>False</code> and <code>True</code> are values. Instead of plain values, you can also have <em>data constructors</em>, like so:</p>
<div class="sourceCode" id="cb424"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb424-1" data-line-number="1"><span class="kw">data</span> <span class="dt">Currency</span> <span class="fu">=</span> <span class="dt">Dollars</span> <span class="dt">Double</span> <span class="fu">|</span> <span class="dt">Yen</span> <span class="dt">Double</span> <span class="fu">|</span> <span class="dt">Euros</span> <span class="dt">Double</span>     <span class="kw">deriving</span> (<span class="dt">Show</span>)</a></code></pre></div>
<p>Now <code>Dollars</code> is a function which takes an <code>Int</code> and returns a value of type <code>Currency</code>.</p>
<div class="sourceCode" id="cb425"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb425-1" data-line-number="1"><span class="dt">Prelude</span><span class="fu">&gt;</span> <span class="dt">Dollars</span> <span class="dv">2</span></a>
<a class="sourceLine" id="cb425-2" data-line-number="2"><span class="dt">Dollars</span> <span class="fl">2.0</span></a></code></pre></div>
<p>We can pattern match on these, which is what makes them useful. Let’s write a <code>convertToDollars</code> function.</p>
<div class="sourceCode" id="cb426"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb426-1" data-line-number="1"><span class="co">-- convertToDollars.hs</span></a>
<a class="sourceLine" id="cb426-2" data-line-number="2"><span class="kw">data</span> <span class="dt">Currency</span> <span class="fu">=</span> <span class="dt">Dollars</span> <span class="dt">Double</span> <span class="fu">|</span> <span class="dt">Yen</span> <span class="dt">Double</span> <span class="fu">|</span> <span class="dt">Euros</span> <span class="dt">Double</span>     <span class="kw">deriving</span> (<span class="dt">Show</span>)</a>
<a class="sourceLine" id="cb426-3" data-line-number="3"></a>
<a class="sourceLine" id="cb426-4" data-line-number="4"><span class="ot">convertToDollars ::</span> <span class="dt">Currency</span> <span class="ot">-&gt;</span> <span class="dt">Currency</span></a>
<a class="sourceLine" id="cb426-5" data-line-number="5">convertToDollars (<span class="dt">Dollars</span> d) <span class="fu">=</span> <span class="dt">Dollars</span> d</a>
<a class="sourceLine" id="cb426-6" data-line-number="6">convertToDollars (<span class="dt">Yen</span> y)     <span class="fu">=</span> <span class="dt">Dollars</span> (y <span class="fu">*</span> <span class="fl">0.0089</span>)</a>
<a class="sourceLine" id="cb426-7" data-line-number="7">convertToDollars (<span class="dt">Euros</span> e  ) <span class="fu">=</span> <span class="dt">Dollars</span> (e <span class="fu">*</span> <span class="fl">1.14</span>)</a></code></pre></div>
<p>We can use this to convert any <code>Currency</code> to <code>Dollars</code>.</p>
<div class="sourceCode" id="cb427"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb427-1" data-line-number="1"><span class="dt">Prelude</span><span class="fu">&gt;</span> convertToDollars (<span class="dt">Yen</span> <span class="dv">3000</span>)</a>
<a class="sourceLine" id="cb427-2" data-line-number="2"><span class="dt">Dollars</span> <span class="fl">26.7</span></a></code></pre></div>
<p>To reiterate, <code>Yen</code>, <code>Euro</code> and <code>Dollars</code> are special functions called <em>data constructors</em>. In our case, they take a <code>Double</code> and return a value of type <code>Currency</code>.</p>
<p>So that’s is data constructors, but we can also have type constructors. These are pretty useful, especially for situations like <code>Maybe</code>. Here’s how <code>Maybe</code> is defined:</p>
<div class="sourceCode" id="cb428"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb428-1" data-line-number="1"><span class="kw">data</span> <span class="dt">Maybe</span> a <span class="fu">=</span> <span class="dt">Nothing</span> <span class="fu">|</span> <span class="dt">Just</span> a  </a></code></pre></div>
<p><code>Maybe</code> is a <em>type constructor</em>, which is similar to a a function but it takes a type and returns a type. <code>Just</code> is a <em>data constructor</em>, which takes a value of type <code>a</code> and returns a value of type <code>Maybe a</code>.</p>
<div class="sourceCode" id="cb429"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb429-1" data-line-number="1"><span class="dt">Prelude</span><span class="fu">&gt;</span> <span class="fu">:</span>t <span class="dt">Just</span> <span class="st">&quot;hello&quot;</span></a>
<a class="sourceLine" id="cb429-2" data-line-number="2"><span class="dt">Just</span> <span class="st">&quot;hello&quot;</span><span class="ot"> ::</span> <span class="dt">Maybe</span> [<span class="dt">Char</span>]</a></code></pre></div>
<p>This should seem pretty familiar. We’ve also discussed <em>recursive data structures</em>. A recursive data structure can contain itself, which is useful for making data structures that can be infinitely large, such as a <em>List</em>. Here’s how we’d do that to make a data structure capable of holding a list of <code>Int</code>s.</p>
<div class="sourceCode" id="cb430"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb430-1" data-line-number="1"><span class="kw">data</span> <span class="dt">IntList</span> <span class="fu">=</span> <span class="dt">End</span> <span class="fu">|</span> <span class="dt">Cons</span> <span class="dt">Int</span> <span class="dt">IntList</span>     <span class="kw">deriving</span> (<span class="dt">Show</span>, <span class="dt">Read</span>, <span class="dt">Eq</span>)  </a></code></pre></div>
<p>This seems pretty complicated, but it’s actually quite simple. <code>IntList</code> is the name of our type. There are two ways to construct one. The first is with just a plain <code>End</code>.</p>
<div class="sourceCode" id="cb431"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb431-1" data-line-number="1"><span class="dt">Prelude</span><span class="fu">&gt;</span> <span class="dt">End</span></a>
<a class="sourceLine" id="cb431-2" data-line-number="2"><span class="dt">End</span></a>
<a class="sourceLine" id="cb431-3" data-line-number="3"><span class="dt">Prelude</span><span class="fu">&gt;</span> <span class="fu">:</span>t <span class="dt">End</span></a>
<a class="sourceLine" id="cb431-4" data-line-number="4"><span class="dt">End</span><span class="ot"> ::</span> <span class="dt">IntList</span></a></code></pre></div>
<p>The second is by passing <code>Cons</code> an <code>Int</code> and another <code>IntList</code>.<label for="marginnote-127" class="margin-toggle">⊕</label> <input type="checkbox" id="marginnote-127" class="margin-toggle"/> <span class="marginnote"><code>Cons</code> stands for <em>constructor</em>.</span></p>
<div class="sourceCode" id="cb432"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb432-1" data-line-number="1"><span class="dt">Prelude</span><span class="fu">&gt;</span> <span class="dt">Cons</span> <span class="dv">3</span> <span class="dt">End</span></a>
<a class="sourceLine" id="cb432-2" data-line-number="2"><span class="dt">Cons</span> <span class="dv">3</span> <span class="dt">End</span></a>
<a class="sourceLine" id="cb432-3" data-line-number="3"><span class="dt">Prelude</span><span class="fu">&gt;</span> <span class="dt">Cons</span> <span class="dv">3</span> (<span class="dt">Cons</span> <span class="dv">4</span> <span class="dt">End</span>)</a>
<a class="sourceLine" id="cb432-4" data-line-number="4"><span class="dt">Cons</span> <span class="dv">3</span> (<span class="dt">Cons</span> <span class="dv">4</span> <span class="dt">End</span>)</a>
<a class="sourceLine" id="cb432-5" data-line-number="5"><span class="dt">Prelude</span><span class="fu">&gt;</span> <span class="dt">Cons</span> <span class="dv">3</span> (<span class="dt">Cons</span> <span class="dv">4</span> (<span class="dt">Cons</span> <span class="dv">5</span> <span class="dt">End</span>))</a>
<a class="sourceLine" id="cb432-6" data-line-number="6"><span class="dt">Cons</span> <span class="dv">3</span> (<span class="dt">Cons</span> <span class="dv">4</span> (<span class="dt">Cons</span> <span class="dv">5</span> <span class="dt">End</span>))</a></code></pre></div>
<p>Notice that our list always ends with <code>End</code>. Of course, we can make our <code>IntList</code> work with all types by using an algebraic data type.</p>
<div class="sourceCode" id="cb433"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb433-1" data-line-number="1"><span class="kw">data</span> <span class="dt">List</span> a <span class="fu">=</span> <span class="dt">End</span> <span class="fu">|</span> <span class="dt">Cons</span> a (<span class="dt">List</span> a)     <span class="kw">deriving</span> (<span class="dt">Show</span>, <span class="dt">Read</span>, <span class="dt">Eq</span>)  </a></code></pre></div>
<p>Which is very convenient, since it saves us from having to make a new list type manually every time we need one.</p>
<div class="sourceCode" id="cb434"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb434-1" data-line-number="1"><span class="dt">Prelude</span><span class="fu">&gt;</span> <span class="dt">Cons</span> <span class="ch">&#39;a&#39;</span> <span class="dt">End</span></a>
<a class="sourceLine" id="cb434-2" data-line-number="2"><span class="dt">Cons</span> <span class="ch">&#39;a&#39;</span> <span class="dt">End</span></a>
<a class="sourceLine" id="cb434-3" data-line-number="3"><span class="dt">Prelude</span><span class="fu">&gt;</span> <span class="dt">Cons</span> <span class="dv">3</span> <span class="dt">End</span></a>
<a class="sourceLine" id="cb434-4" data-line-number="4"><span class="dt">Cons</span> <span class="dv">3</span> <span class="dt">End</span></a></code></pre></div>
<p>This is actually very similar to how lists in Haskell are actually implemented! But they use <code>:</code> instead of <code>Cons</code> and <code>[]</code> instead of <code>End</code>.</p>
<div class="sourceCode" id="cb435"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb435-1" data-line-number="1"><span class="dt">Prelude</span><span class="fu">&gt;</span> <span class="dv">3</span><span class="fu">:</span>[]</a>
<a class="sourceLine" id="cb435-2" data-line-number="2">[<span class="dv">3</span>]</a>
<a class="sourceLine" id="cb435-3" data-line-number="3"><span class="dt">Prelude</span><span class="fu">&gt;</span> <span class="dv">3</span><span class="fu">:</span><span class="dv">4</span><span class="fu">:</span><span class="dv">5</span><span class="fu">:</span>[]</a>
<a class="sourceLine" id="cb435-4" data-line-number="4">[<span class="dv">3</span>,<span class="dv">4</span>,<span class="dv">5</span>]</a></code></pre></div>
<p>Type constructors take some types and return a new type, and GADTs drastically increase the power of type constructors. To test it out, we need to tell GHC that we want to enable <code>GADTs</code>. We do this by adding something called a <em>language pragma</em> to the top of our file. In practice, we just write <code>{-# LANGUAGE &lt;Extension&gt; #-}</code> at the top of our file. Our extension is <code>GADTs</code>, so we use <code>{-# LANGUAGE GADTs #-}</code><label for="marginnote-128" class="margin-toggle">⊕</label> <input type="checkbox" id="marginnote-128" class="margin-toggle"/> <span class="marginnote">We can also specify this in our <code>package.yaml</code>, which makes the extension available to our whole project without having to write any special extensions.</span>. The most basic thing we can do with GADTs is have what’s called an <em>uninhabited type</em>, a type with no values. These are pretty much only useful with GADTs so they’re not available outside of that.</p>
<div class="sourceCode" id="cb436"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb436-1" data-line-number="1"><span class="co">-- GADTsTest.hs</span></a>
<a class="sourceLine" id="cb436-2" data-line-number="2"><span class="ot">{-# LANGUAGE GADTs #-}</span></a>
<a class="sourceLine" id="cb436-3" data-line-number="3"></a>
<a class="sourceLine" id="cb436-4" data-line-number="4"><span class="kw">data</span> <span class="dt">Uninhabited</span> </a></code></pre></div>
<p><code>Uninhabited</code> is a type that contains no values<label for="marginnote-129" class="margin-toggle">⊕</label> <input type="checkbox" id="marginnote-129" class="margin-toggle"/> <span class="marginnote"><code>Uninhabited</code> actually does contain the special value <code>undefined</code>, which is contained by all types. But we’ll ignore <code>undefined</code> for now.</span> This means <code>Uninhabited</code> is almost entirely useless. Functions need to do two things: take and return values. If a function takes a value of type <code>Uninhabited</code>, we can never call it, because we’d have to pass it a value of type <code>Uninhabited</code> and there just aren’t any. And if a function returned type <code>Uninhabited</code>, there’d be no way to even write it! For this reason it’s called a <em>phantom type</em>, a type which exists but we can’t use it to write any useful functions.</p>
<p>But we can use phantom types in a useful way, with type constructors! Those take types, not values, so the fact that our type doesn’t have any values isn’t an issue. <code>Maybe</code> is a type constructor which takes one types, so we can have <code>Maybe Int</code>, <code>Maybe Char</code>, and even <code>Maybe Uninhabited</code>. We can actually make a value of type <code>Maybe Uninhabited</code>, too!</p>
<div class="sourceCode" id="cb437"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb437-1" data-line-number="1"><span class="dt">Prelude</span><span class="fu">&gt;</span> <span class="fu">:</span>l GADTsTest1.hs</a>
<a class="sourceLine" id="cb437-2" data-line-number="2"><span class="fu">*</span><span class="dt">Main</span><span class="fu">&gt;</span> myStrangeValue <span class="fu">=</span> (<span class="dt">Nothing</span><span class="ot"> ::</span> <span class="dt">Maybe</span> <span class="dt">Uninhabited</span>)</a></code></pre></div>
<p><code>Maybe</code> takes a value of type <code>a</code>, but we don’t need a value of type <code>a</code> to make a <code>Nothing</code>, so this works (although there’s still not a good reason to use the type <code>Maybe Uninhabited</code> anywhere).</p>
<p>A common use of GADTs is to use an uninhabited type as a “tag” for another type, which is possible because the GADTs extension allows us to use <code>where</code> to make data constructors more powerfully than we could before. This allows us to put more information into the type system, which results in safer functions and fewer bugs in our code. To demonstrate, we’ll write a new <code>List</code> type which will use two phantom types as tags to keep track of whether the list is <code>Empty</code> or <code>NonEmpty</code>. We can then use that to write a version of <code>head</code> which will only work on nonempty lists.</p>
<div class="sourceCode" id="cb438"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb438-1" data-line-number="1"><span class="co">-- SafeHead.hs</span></a>
<a class="sourceLine" id="cb438-2" data-line-number="2"><span class="ot">{-# LANGUAGE GADTs #-}</span></a>
<a class="sourceLine" id="cb438-3" data-line-number="3"></a>
<a class="sourceLine" id="cb438-4" data-line-number="4"><span class="kw">data</span> <span class="dt">Empty</span></a>
<a class="sourceLine" id="cb438-5" data-line-number="5"><span class="kw">data</span> <span class="dt">NonEmpty</span></a>
<a class="sourceLine" id="cb438-6" data-line-number="6"></a>
<a class="sourceLine" id="cb438-7" data-line-number="7"><span class="kw">data</span> <span class="dt">List</span> a tag <span class="kw">where</span></a>
<a class="sourceLine" id="cb438-8" data-line-number="8">        <span class="dt">End</span><span class="ot">  ::</span> <span class="dt">List</span> a <span class="dt">Empty</span></a>
<a class="sourceLine" id="cb438-9" data-line-number="9">        <span class="dt">Cons</span><span class="ot"> ::</span> a <span class="ot">-&gt;</span> <span class="dt">List</span> a tag <span class="ot">-&gt;</span> <span class="dt">List</span> a <span class="dt">NonEmpty</span></a>
<a class="sourceLine" id="cb438-10" data-line-number="10"></a>
<a class="sourceLine" id="cb438-11" data-line-number="11"><span class="ot">safeHead ::</span> <span class="dt">List</span> a <span class="dt">NonEmpty</span> <span class="ot">-&gt;</span> a</a>
<a class="sourceLine" id="cb438-12" data-line-number="12">safeHead (<span class="dt">Cons</span> a b) <span class="fu">=</span> a</a></code></pre></div>
<p>Don’t worry about the specifics of <code>where</code> but just yet, let’s jump to actually using <code>List</code>.</p>
<p>Let’s make a <code>List</code> of <code>Char</code>s.</p>
<div class="sourceCode" id="cb439"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb439-1" data-line-number="1"><span class="dt">Prelude</span><span class="fu">&gt;</span> <span class="fu">:</span>l SafeHead.hs</a>
<a class="sourceLine" id="cb439-2" data-line-number="2"><span class="fu">*</span><span class="dt">Main</span><span class="fu">&gt;</span> myList <span class="fu">=</span> <span class="dt">Cons</span> <span class="ch">&#39;a&#39;</span> (<span class="dt">Cons</span> <span class="ch">&#39;b&#39;</span> <span class="dt">End</span>)</a></code></pre></div>
<p><code>myList</code> is a value of type <code>List</code>. The <code>List</code> contains two elements, <code>'a'</code> and <code>'b'</code>. But if you use <code>:t</code> to inspect the value of <code>myList</code>, you can see it’s got the type <code>NonEmpty</code> in its second parameter.</p>
<div class="sourceCode" id="cb440"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb440-1" data-line-number="1"><span class="fu">*</span><span class="dt">Main</span><span class="fu">&gt;</span> <span class="fu">:</span>t myList</a>
<a class="sourceLine" id="cb440-2" data-line-number="2"><span class="ot">myList ::</span> <span class="dt">List</span> <span class="dt">Char</span> <span class="dt">NonEmpty</span></a></code></pre></div>
<p>Our function <code>safeHead</code> takes a value of type <code>List a NonEmpty</code>. This means we can pass it <code>myList</code>.</p>
<div class="sourceCode" id="cb441"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb441-1" data-line-number="1"><span class="fu">*</span><span class="dt">Main</span><span class="fu">&gt;</span> safeHead myList</a>
<a class="sourceLine" id="cb441-2" data-line-number="2"><span class="ch">&#39;a&#39;</span></a></code></pre></div>
<p>It successfully extracted the first type! <code>safeHead</code> is pattern matching against <code>Cons a b</code>, and returning <code>a</code>. This works because <code>a</code> will be the first value in our list, and <code>b</code> will be the rest of the list (which is <code>Cons 'b' End</code>). Running <code>safeHead End</code> would give us a compile error, which is exactly what we want. Any time you can make your code give you a compile error instead of a runtime error is a win!</p>
<p>Now, let’s dig into the actual type definitions.</p>
<div class="sourceCode" id="cb442"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb442-1" data-line-number="1"><span class="kw">data</span> <span class="dt">Empty</span></a>
<a class="sourceLine" id="cb442-2" data-line-number="2"><span class="kw">data</span> <span class="dt">NonEmpty</span></a>
<a class="sourceLine" id="cb442-3" data-line-number="3"></a>
<a class="sourceLine" id="cb442-4" data-line-number="4"><span class="kw">data</span> <span class="dt">List</span> a tag <span class="kw">where</span></a>
<a class="sourceLine" id="cb442-5" data-line-number="5">        <span class="dt">End</span><span class="ot">  ::</span> <span class="dt">List</span> a <span class="dt">Empty</span></a>
<a class="sourceLine" id="cb442-6" data-line-number="6">        <span class="dt">Cons</span><span class="ot"> ::</span> a <span class="ot">-&gt;</span> <span class="dt">List</span> a tag <span class="ot">-&gt;</span> <span class="dt">List</span> a <span class="dt">NonEmpty</span></a></code></pre></div>
<p><code>data Empty</code> and <code>data NonEmpty</code> are pretty simple - they’re phantom types which contain no values. They’re used so we can “tag” our <code>List</code> type with useful values. The interesting definition is actually the <code>List</code> type, because it uses some syntax we haven’t seen before. Earlier in this chapter we defined <code>List</code> with <code>data List a = End | Cons a (List a)</code>, where <code>End</code> and <code>Cons</code> were the data constructors. GADTs lets us do this in a more powerful way, with <code>where</code>. We still define two data constructors, <code>End</code> and <code>Where</code>, but because we’re using <code>where</code> we get to specify the output type of our data constructor.</p>
<p>Before, <code>End</code> was a list of type <code>List a</code>. Now, <code>End</code> is a list of type <code>List a Empty</code>.</p>
<p>Before, <code>Cons</code> took an <code>a</code> and a type <code>List a</code> and returned a <code>List a</code>. Now, <code>Cons</code> takes a value of type <code>a</code> and a value of type type <code>List a tag</code> and returns a value of type <code>List a NonEmpty</code>.</p>
<p>This may all seem very confusing, so don’t worry if it seems a bit hazy. There’s another language extension that makes GADTs much more useful, called <code>DataKinds</code>, which we’ll introduce now and hopefully reinforce GADTs. It makes it very easy to write a safe <code>tail</code> function, which is what we’ll try next.</p>
<p><code>DataKinds</code> lets us use a value where Haskell expects a type by putting a <code>'</code> in front of it<label for="marginnote-130" class="margin-toggle">⊕</label> <input type="checkbox" id="marginnote-130" class="margin-toggle"/> <span class="marginnote">It also lets you use a type where haskell expects a <em>kind</em>, which is like the type of a type. We won’t be discussing kinds just yet.</span>.</p>
<p>So for example, instead of saying a function takes an <code>Bool</code>, we could say it takes a <code>'True</code><label for="marginnote-131" class="margin-toggle">⊕</label> <input type="checkbox" id="marginnote-131" class="margin-toggle"/> <span class="marginnote">GHC will sometimes allow us to leave out the <code>'</code> even when referring to <code>True</code> as a type, but it’s best practice to leave it in.</span>. Haskell will then check at compile time that this function never gets passed a <code>False</code>. This becomes very useful when combined with GADTs because it makes it allows us to put a lot of useful information into our types.</p>
<div class="sourceCode" id="cb443"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb443-1" data-line-number="1"><span class="co">-- SafeHeadTail.hs</span></a>
<a class="sourceLine" id="cb443-2" data-line-number="2"><span class="ot">{-# LANGUAGE GADTs #-}</span></a>
<a class="sourceLine" id="cb443-3" data-line-number="3"><span class="ot">{-# LANGUAGE DataKinds #-}</span></a>
<a class="sourceLine" id="cb443-4" data-line-number="4"></a>
<a class="sourceLine" id="cb443-5" data-line-number="5"><span class="kw">data</span> <span class="dt">Nat</span> <span class="fu">=</span> <span class="dt">Zero</span> <span class="fu">|</span> <span class="dt">Succ</span> <span class="dt">Nat</span></a>
<a class="sourceLine" id="cb443-6" data-line-number="6"></a>
<a class="sourceLine" id="cb443-7" data-line-number="7"><span class="kw">data</span> <span class="dt">List</span> a n <span class="kw">where</span></a>
<a class="sourceLine" id="cb443-8" data-line-number="8">    <span class="dt">End</span><span class="ot">  ::</span> <span class="dt">List</span> a &#39;<span class="dt">Zero</span> </a>
<a class="sourceLine" id="cb443-9" data-line-number="9">    <span class="dt">Cons</span><span class="ot"> ::</span> a <span class="ot">-&gt;</span> <span class="dt">List</span> a n <span class="ot">-&gt;</span> <span class="dt">List</span> a (&#39;<span class="dt">Succ</span> n)</a>
<a class="sourceLine" id="cb443-10" data-line-number="10"></a>
<a class="sourceLine" id="cb443-11" data-line-number="11"><span class="ot">safeHead ::</span> <span class="dt">List</span> a (&#39;<span class="dt">Succ</span> n) <span class="ot">-&gt;</span> a</a>
<a class="sourceLine" id="cb443-12" data-line-number="12">safeHead (<span class="dt">Cons</span> a as) <span class="fu">=</span> a</a>
<a class="sourceLine" id="cb443-13" data-line-number="13"></a>
<a class="sourceLine" id="cb443-14" data-line-number="14"><span class="ot">safeTail ::</span> <span class="dt">List</span> a (&#39;<span class="dt">Succ</span> n) <span class="ot">-&gt;</span> <span class="dt">List</span> a n</a>
<a class="sourceLine" id="cb443-15" data-line-number="15">safeTail (<span class="dt">Cons</span> a as) <span class="fu">=</span> as</a></code></pre></div>
<p>Now, what on earth is going on here? Well, first we make a simple recursive data type called <code>Nat</code>. This is short for <em>natural number</em>, which is a counting number like 0, 1, 2, 3, etc. Instead of having it encoded like that though, we make representations of these numbers with the data constructors <code>Zero</code> and <code>Succ Nat</code> (<code>Succ</code> is short for <em>successor</em>). We can stack as many <code>Succ</code>s on to a <code>Zero</code> as we want to make any natural number.</p>
<div class="sourceCode" id="cb444"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb444-1" data-line-number="1"><span class="dt">Prelude</span><span class="fu">&gt;</span> <span class="fu">:</span>l SafeHeadTail.hs</a>
<a class="sourceLine" id="cb444-2" data-line-number="2"><span class="fu">*</span><span class="dt">Main</span><span class="fu">&gt;</span> one <span class="fu">=</span> <span class="dt">Succ</span> <span class="dt">Zero</span></a>
<a class="sourceLine" id="cb444-3" data-line-number="3"><span class="fu">*</span><span class="dt">Main</span><span class="fu">&gt;</span> four <span class="fu">=</span> <span class="dt">Succ</span> (<span class="dt">Succ</span> (<span class="dt">Succ</span> one))</a></code></pre></div>
<p>Then we have our definition of <code>List</code>, which uses <code>n</code> instead of <code>tag</code>. <code>n</code> is going to represent a <code>Nat</code>, which will represent the length of our list. <code>End</code> is much the same as before, except instead of <code>NonEmpty</code> we use <code>'Zero</code>. Now, observe <code>Cons</code> because it’s very interesting:</p>
<div class="sourceCode" id="cb445"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb445-1" data-line-number="1">    <span class="dt">Cons</span><span class="ot"> ::</span> a <span class="ot">-&gt;</span> <span class="dt">List</span> a n <span class="ot">-&gt;</span> <span class="dt">List</span> a (&#39;<span class="dt">Succ</span> n)</a></code></pre></div>
<p>It takes an <code>a</code>, and a <code>List a n</code>, and returns a new <code>List a ('Succ n)</code>. Essentially it adds an extra <code>Succ</code> to the value which represents the length of our list! This means our lists start at length <code>Zero</code> and then get a <code>Succ</code> added to them every time we grow the list by one element. This means we can use information about the length of our list in type signatures, as we do in <code>safeHead</code> and <code>safeTail</code>!</p>
<p><code>safeHead</code>’s type signature is <code>safeHead :: List a ('Succ n) -&gt; a</code>. The <code>('Succ n)</code> will make it so it won’t work if our list’s <code>n</code> is <code>Zero</code>, but will work if it’s <code>Succ Zero</code> or <code>Succ (Succ Zero)</code>. This is serving the same purpose as <code>NonZero</code> in the last example.</p>
<p><code>safeTail</code>’s type signature is <code>safeTail :: List a ('Succ n) -&gt; List a n</code>. This is the thing we couldn’t do when we only had <code>Empty</code> and <code>NonEmpty</code>. <code>SafeTail</code> returns a list of all the values except the first, and it properly represents that the new list is one element shorter (it has one less <code>Succ</code>).</p>
<p>Let’s see these in action!</p>
<div class="sourceCode" id="cb446"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb446-1" data-line-number="1"><span class="fu">*</span><span class="dt">Main</span><span class="fu">&gt;</span> <span class="fu">:</span>l SafeHeadTail.hs</a>
<a class="sourceLine" id="cb446-2" data-line-number="2"><span class="fu">*</span><span class="dt">Main</span><span class="fu">&gt;</span> myList <span class="fu">=</span> <span class="dt">Cons</span> <span class="dv">1</span> (<span class="dt">Cons</span> <span class="dv">2</span> <span class="dt">End</span>)</a>
<a class="sourceLine" id="cb446-3" data-line-number="3"><span class="fu">*</span><span class="dt">Main</span><span class="fu">&gt;</span> safeHead <span class="fu">.</span> safeTail <span class="fu">$</span> myList</a>
<a class="sourceLine" id="cb446-4" data-line-number="4"><span class="dv">2</span></a></code></pre></div>
<p>Now, what if we made an error and accidentally tacked on one too many <code>safeTail</code>s? If we were just using <code>tail</code> this would fail at runtime, but since we’ve encoded the length in the type system it fails at compile time instead, which is much better!</p>
<div class="sourceCode" id="cb447"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb447-1" data-line-number="1"><span class="fu">*</span><span class="dt">Main</span><span class="fu">&gt;</span> safeHead <span class="fu">.</span> safeTail <span class="fu">.</span> safeTail <span class="fu">$</span> myList</a>
<a class="sourceLine" id="cb447-2" data-line-number="2"><span class="co">-- compile error, *not* a runtime exception!</span></a></code></pre></div>
<p>This has been just a brief taste of the <code>GADTs</code> and <code>DataKinds</code> extensions. They’re very powerful and we’ve only scratched the surface.</p>
</body>
</html>
